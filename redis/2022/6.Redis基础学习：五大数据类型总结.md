# Redis基础学习：五大数据类型总结

通过之前的学习，我们已经了解了 Redis 中五大数据类型相关的一些命令，通过这些命令操作其实也能知道这五种数据类型都能够应用在哪些场景中。但是，今天我们依然要总结一下，为什么呢？因为这五大数据类型是非常常见的面试题呀。

如果你在简历上写了用过 Redis ，或者说写了“精通” Redis 的话，那么大部分面试官第一个问题就是用过哪些数据类型，都用在什么场景解决了什么问题。当然，也有可能会问你 Redis 和 Memcached 之间的区别。即使是问区别，Redis 丰富的数据类型也是它和 Memcached 之间的一个重点区别之一。

既然如此的话，那么今天我们就来总结一下这五大数据类型。

## String

字符串类型，就是我们最常见也最常使用的 k/v 形式的数据类型啦。最基础的缓存操作基本上都是基于这个数据类型的，同时在 Memcached 中也仅有这一种数据类型。你可以把它想象成我们程序代码中的一个字符串变量，key 就是变量名，value 就是变量的值。这个变量被定义在 Redis 服务器中，可以指定它的过期时间，也可以永久保存，不跟随程序的生命周期而结束。

对于 Redis 来说，字符串类型是二进制安全的，有 512M 的空间可以使用，也就是说，一个 key 可以存放最大 512M 的数据。同时，它也可以存储二进制数据，比如图片或者文件之类的二进制内容。

因此，我们可以直接缓存整个页面、整张图片、序列化后的 JSON 对象等等，前提是它们不会超过 512M 的大小。

## List

列表类型，或者说就是一个字符串列表，可以按照指定的顺序添加元素。同样的，将它想象成是我们 PHP 中的数组也是可以的，只不过这个数组同样是在程序之外运行在 Redis 服务上的。

列表最重要的一点就是可以方便地实现队列和栈的功能，它可以支持非常快的头尾数据插入和弹出，但是如果是访问中间的元素就非常慢了，毕竟这是一个链表实现的数据结构。

要实现队列，我们可以 LPUSH 之后 RPOP ，或者 RPUSH 之后 LPOP ，只要不是从同一边 POP 出来数据就是一个队列应用。而栈的话，只要同边操作就可以了，比如 LPUSH 之后 LPOP 。

更为方便的是使用阻塞操作，也就是 BLPOP/BRPOP ，之前在文章中也说过，在取队列的时候，我们往往要用一个守护进程不停的 POP 新数据，如果没有新数据了一般会 sleep() 一会程序。但有了阻塞操作之后，其实我们就可以不用 sleep() 了，直接进行阻塞获取就可以。

典型的应用场景上面已经说过了，就是队列和栈的应用。像我们实现微博的最新动态、消息之类的功能，就可以将用户发布的最新数据 PUSH 到 List 中。另外，发邮件、短信之类的耗时操作，都可以通过队列实现解耦。当然，经典的秒杀场景也是可以直接上队列实现的。

如果你的项目本身不大，每秒请求入库的量在几千或者几万的情况下，使用 Redis 来实现队列就足够了，完全没必要上专业的队列服务，比如 RabbitMQ 或者 Kafka 之类的。我之前最高的项目在最高峰有单机 2 万并发，每秒 2000 条左右的日志数据入 Redis 队列，使用的是阿里云单机版4G的 Redis ，完全无压力。（Redis理论读写可以达到 11万/秒 和 8万/秒 ，比 RabbitMQ 快）

## Hash

哈希类型，这个类型怎么说好呢？想象成是一个对象吧。一个 key 是我们的变量名，然后里面又存储了一堆键值对数据，就像我们对象里面的属性。或者叫它字典类型也是可以的，一个 key 里面的数据就像是一个数据字典。

对于一个少于 100 个字段的哈希类型来说，可以使用很少的空间来保存它，不过，哈希类型可以创建的字段数量远比100个多，在可使用内存的范围内你可以无限制的为它添加字段。话又说回来，其实这个意思也就是你可以创建很多哈希数据，比如数据库查询出来的列表，不想使用序列化存储成 String 或者 List 的话，那么就可以直接一个接一个的创建成 Hash 。在 PHP 中，直接使用 hGetAll 返回的就是一个数组，不需要再进行反序列化的操作，非常方便。

## Set

集合类型，同样可以看成是数组，不过它是值不能重复的数组。也就说，它是完全符合数学上集合定义的一种数据类型。通过 Set 类型，可以非常快速地添加、删除以及测试元素是否存在。一个集合可以包含 40 亿个元素，同时，因为是集合，所以交、并、差的计算命令都已经提供了，能够方便地实现这些运算。

通过集合类型，我们可以方便地实现一些标签操作，比如给文章打标签，合并同类标签之类的。另外还可以快速方便地获取随机的数据，统计不重复的访问IP等等。

## Sorted Set

有序集合，高大上了吧，在集合的基础上加上了一个 score 分数的设置，从而让集合实现有序排列。因为元素在插入的时候就会根据分数进行排序，所以可以很快地获得当前集合中的一个有序列表。应用场景不用我说大家也能想到了，排行榜、延时队列等等。

假如我们使用 Hash 存储了很多用户的信息，这时候我们想按用户的某一个属性返回一个排行数据，那么就可以将属性设置为 score ，将 Hash 的 key 设置为值。比如用户的年龄作为 score ，返回一个关于年龄的排行榜。当然，你直接把序列化后的整个用户对象属性全部放在值里也是没问题的。

而对于延时队列，则是在 ThinkPHP 的队列组件中看到的，同时 Laravel 中的延时队列也是用它实现的。分数使用时间戳，内容保存的是队列需要使用的数据。在弹出数据前，先查看时间是否到了，如果小于当前时间，就弹出这条数据并执行相应的操作，具体的源码大家可以查阅 TP 的  **think-queue** 组件，这个比 Laravel 的看得要简单一些。

## 总结

基础五大类型的内容就到这里了，我们后面还将继续学习其它基础方面的知识，毕竟是从头重新刷一遍文档，所以小伙伴们也不要着急哦。高阶面试八股文我们早晚也会学到，但是在这之前，基础才是更重要的，毕竟我们要真正的把知识学到，而不是仅仅为了通过面试而已。