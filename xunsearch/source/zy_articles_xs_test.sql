/*
 Navicat Premium Data Transfer

 Source Server         : 本地
 Source Server Type    : MySQL
 Source Server Version : 80012 (8.0.12)
 Source Host           : 127.0.0.1:3306
 Source Schema         : zyblog

 Target Server Type    : MySQL
 Target Server Version : 80012 (8.0.12)
 File Encoding         : 65001

 Date: 23/11/2023 17:02:30
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for zy_articles_xs_test
-- ----------------------------
DROP TABLE IF EXISTS `zy_articles_xs_test`;
CREATE TABLE `zy_articles_xs_test`  (
  `id` int(11) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标题',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '内容',
  `category_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '分类名称',
  `tags` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标签',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `pub_time` datetime NULL DEFAULT NULL COMMENT '发布时间',
  `status` tinyint(4) NULL DEFAULT NULL COMMENT '状态：1已发布，0未发布',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of zy_articles_xs_test
-- ----------------------------
INSERT INTO `zy_articles_xs_test` VALUES (1, '【PHP数据结构与算法1】在学数据结构和算法的时候我们究竟学的是啥？', '<h1>在学数据结构和算法的时候我们究竟学的是啥？</h1><p>一说到数据结构与算法，大家都会避之不及。这本来是一门专业基础课，但是大部分人都并没有学好，更不用说我这种半路出家的码农了。说实话，还是很羡慕科班出身的程序员，因为你们在日常工作或者面试中，只需要复习一下就好了，而我则是完全的从头开始学。不过，还好一切都不晚，在这里，我们就用 PHP 作为示例代码，来和大家一起真正的从头学一遍恐怖的数据结构与算法。</p><h2>数据结构</h2><p>什么是数据结构呢？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>数据结构是带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这是严蔚敏老师在《数据结构》第二版中对数据结构的定义。其实，就是关于数据的一种组合形式。就像你去一家书店，或者是图书馆，或者是你家的书柜。这些书应该怎么摆放呢？关于书的摆放形式，就是数据结构。你可以乱七八糟的摆放，也可以分门别类的摆放，也可以根据自己的兴趣爱好摆放，也可以将最常用的书放在手边，将不常看的书放在柜子的深处。这些都是数据结构。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在程序世界中，数据结构包含两种形式，一种是逻辑结构，一种是物理结构。</p><h3>逻辑结构</h3><p>即使你完全没有接触过数据结构，但只要你学习过编程，一定会多多少少地听说过这样一些名词：集合、线性表、树、图，它们指的就是数据结构中的逻辑结构。也就是从逻辑关系上描述数据，是具体问题抽象出来的数学模型。比如我们将书进行分类，每个分类下放着相对应的书籍，这就是一种树形结构。或者我们将书按书名拼音建立索引，然后在书架上贴上索引标签，这就是一种哈希结构。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>逻辑结构将是我们整个学习中的一个重点，因为各种算法都是针对这些结构的操作实现。这个我们在下面的算法解释中再进行详细的说明。</p><h3>物理结构</h3><p>物理结构主要是数据的物理存储方式，也叫做存储结构。这个非常好记，它只有两种形式，顺序存储结构和链式存储结构。通常，顺序存储结构我们使用数组来表示，而链式存储结构在 C语言 中使用结构体的指针来表示，但在 PHP 中，链式结构我们将使用类来表述。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上面说的那些逻辑结构，都可以用顺序或者链式的方式来实现，不管使用哪种方式，都可以完成对应逻辑结构的算法操作，但不同的形式或者算法又有不同的效率。而效率，正是整个数据结构和算法学习核心中的核心。</p><h2>算法</h2><p>接下来我们看看什么是算法。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>算法是一个有限指令集，它接受一些输入（有些情况下不需要输入），产生输出，并一定在有限步骤之后终止</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这是陈越老师在浙大版《数据结构》第二版中对于算法的定义。其实我们简单点理解的话，针对上面的数据结构的一系列操作，就是算法。比如说我们定义了一个树，如何遍历这颗树呢？这就是一个算法，遍历一颗树有先序、中序、后序，也可以进行层序遍历，有这么多种方法，哪种好？哪种不好？用哪种物理结构？线性还是链式？这些结论都以算法的执行效率为基础。可以说，算法种类繁多，效率也千差万别，但是，不能一棒子打死说某个算法一定不好，每种算法也有它不同的应用场景。这就是我们要研究算法的原因。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>关于算法，我们最关心的是它的效率，这个效率在这里我们使用的是时间复杂度和空间复杂度来定义的。</p><h3>时间复杂度</h3><p>时间复杂度一般使用 O(n) 来表示，它关心的是问题规模和语句频度，一般会以 n 表示问题规模 （注意，这个 n 是未知的，如果这个 n 是已知的，那么它就是常数阶）。这个 n 有可能是一个常数（n 明确等于多少），记成 O(1) 。这是最好的情况，也可以线性增长，如 O(n) 。当然也可能对数或指数级增长，O(logN) 、 O(N^2)，当然最要不得的是 O(2^N) 级的增长，这种情况下可能有生之年你都看不到运算的结果了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们可以看看简单的一段代码来分析它的时间复杂度：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\necho $a++, PHP_EOL; // O(1)\n\n$n = 10; // 假设一个数量用于测试，实际这个 n 是未知的，如果面试题代码中真的出现了这种已知 n 的情况，那么这个算法就是 O(1)\nfor($i = 0;$i&lt;$n;$i++){\n    echo $i, PHP_EOL;\n}\n// O(n)\n\nfor($i = 0;$i&lt;$n;$i*=2){\n    echo $i, PHP_EOL;\n}\n// O(logN)\n\nfor($i = 0;$i&lt;$n;$i++){\n    for($j = 0;$j&lt;$n;$j++){\n        echo $i, $j, PHP_EOL;\n    }\n}\n// O(N^2)</code></pre></div><p>从上面代码中可以看出，循环嵌套次数与 n 的增长有很大的关系，另外就是看在循环内部的操作也会影响到增长的情况。比如如果我们是这样一段代码：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$n = 10; // 假设一个数量，实际这个 n 是未知的\n$m = 3; // 假设一个数量，实际这个 m 是未知的\nfor($i = 0;$i&lt;$n;$i++){\n    for($j = 0;$j&lt;$m;$j++){\n        echo $i, $j, PHP_EOL;\n    }\n}</code></pre></div><p>那么它的时间复杂度就不是 O(N^2) 而是，O(NM) ，因为我们这两层循环并不是都是对最大的 N 的操作，而是 N * M 的操作。但是，如果当 M 很大甚至等于 N 的时候，那么这个算法也就成为了 N^2 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>对于时间复杂度的分析其实是需要一些数学功底的，但是对于我这种半吊子出身的码农来说，把握住循环层次以及循环内的操作情况就可以大致地分析出一段算法的时间复杂度了。当然，对于某些大厂比较刁钻的面试题来说，还是需要用数学方法进行分解求得正确的时间复杂度。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另外，在一段算法或者说一个函数中，时间复杂度以最大的那个为准，同时，也要考虑最好和最差时间复杂度，因为基于数据规模有可能在数据量大的时候时间复杂度会越来越惨。这个时候我们就会以最差时间复杂度来作为这一段算法的最终时间复杂度。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>关于时间复杂度的问题，可以参考各类算法书籍，当然最好是以大学教材及练习题为主，多做题就能掌握得更深入。</p><h3>空间复杂度</h3><p>相对时间复杂度来，空间复杂度在数据结构和算法中要关心的少一些，因为大部分情况下我们只借助一个第三方变量的话，这个空间复杂度就是 O(1) 。而如果需要借助一个数组或者链表来实现算法的话，这个算法的空间复杂度就是 O(n) 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>一般情况下我们不太会去过于的关注空间复杂度，因为大部分算法基本都会维持在 O(1) 或 O(n) 这个级别。当然，也就一些算法会出现占用非常大的空间复杂度的情况，这样分分钟就能撑爆你的内存。当在遇到这类算法的时候，我们会单独来说明空间复杂度的情况。</p><h1>总结</h1><p>第一篇文章都是以理论方面的东西为基础的，这也是学习数据结构与算法的实际情况，必须是理论与实际相结合的学习。让我们从此开始，迈向这个深不见底的超级大坑吧！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2022-03-12 14:28:51', 1);
INSERT INTO `zy_articles_xs_test` VALUES (2, '【PHP数据结构与算法2.1】线性表？顺序表？链表？别再傻傻分不清楚', '<h1>线性表？顺序表？链表？别再傻傻分不清楚</h1><p>遵从所有教材以及各类数据结构相关的书书籍，我们先从线性表开始入门。今天这篇文章更偏概念，是关于有线性表的一个知识点的汇总。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上文说过，物理结构是用于确定数据以何种方式存储的。其他的数据结构（树、图）、算法等基本都是建立在这样一个物理结构之上的，也可以说，物理结构就是数据结构的根本。在这里，我们先介绍两个物理结构，也是我们将来学习数据结构的基石，它们就是顺序表和链表。</p><h2>顺序表</h2><p>不扯复杂的定义，不扯什么数学表达式，我们最直观的理解，顺序表就是数组。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>是不是非常简单，没错，在 PHP 或者 C 的世界中，我们就把顺序表定义为数组，而相同的名词还包括：顺序存储、顺序结构等。只要看到这种名词，马上想到数组就可以了。当然，在 Java 中，我们也可以将 List 这类的集合当成是顺序存储结构。不过需要注意的是，Java 的 HashMap ，在 PHP 中是以键值对形式定义的数组，它们是哈希表（Hash），从形式上来说，他们并不是顺序的。在这里我们一定要记住，像数组下标递增这样顺序结构的才是顺序存储结构。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>顺序表一般占用连续的内存空间。不仅逻辑上，连物理空间上都是相邻连续的。</p><h2>链表</h2><p>链表一般在 C 中会定义为一个结构体，其中包括数据和指向下一个链表的指针，它不是顺序的，虽然逻辑是有顺序的（按指针指向），但在物理是可以分开的。也就是说，链表不用占用连续的内存空间，不需要在初始化的时候像数组一样给定长度。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在 PHP 中，我们没有结构体这种语法形式，所以我们直接使用类来表示链表结构。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nclass Node{\n    public $data;\n    public Node $next;\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>这就是一个简单的链表结构，我们可以把它叫做一个“结点”。data 中存放我们要保存的数据，可以是任意类型。而 next 则是我们下一个链表结点。如果我们需要简单的遍历链表，直接不停的调用 next 直到它为空即可。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nwhile($n-&gt;next){\n    $n = $n-&gt;next;\n    echo $n-&gt;data, PHP_EOL;\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p><img src=\"//img1.zyblog.com.cn/20220724/dc340de15364b501c915cce9057c2124.jpg\" alt=\"//img1.zyblog.com.cn/20220724/dc340de15364b501c915cce9057c2124.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上图就是关于链表的逻辑状态以及它的遍历方向。具体的链表操作相关函数我们将在后面的文章中进行讲解。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>链表有很多种形式，上面我们定义的是一个简单的单向链表。我们还可以定义双向链表（加一个 prev 指向上一个结点），循环链表（最后一个next指回第一个结点）以及双向循环链表（最后一个next指回第一个结点，第一个的 prev 指向最后一个结点）。关于这些内容，我们也会放到后面的文章中一一讲解。</p><h2>线性表</h2><p>了解了顺序表和链表之后，我们最后就来说说线性表。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>其实，顺序表和链表这两种物理结构在默认状态下所实现的就是“顺序表”这个逻辑数据结构。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>顺序表：由n(n&gt;0)个数据特性相同的元素构成的有限序列</em>（严蔚敏版）</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>注意几个关键点：</p><ul><li><p>有限：数组长度、链表内存大小</p></li><li><p>序列：逻辑有序（数组是逻辑和物理都有序，链表是逻辑有序而物理无序）</p></li><li><p>数据特性相同：PHP 中不明显，C 或 Java 中数组是固定类型的，而且也要给一个初始长度</p></li></ul><p>为什么说线性表这么重要呢？我们想想 MySQL 这样一行一行存储数据的关系型数据库，一张数据表不就是一个线性表吗？特别是我们做 PHP 的程序员，天天都是在和数组（数据库读出来的数据一般都放到数据中）打交道（当然，我们用哈希可能更多些），也就是说，我们在做开发的时候，天天都在接触这个东西，你说它重要不重要。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>而 树 和 图 这些数据结构却并不是线性表，在现实的归类中，它们是属于 非线性表 的范畴的。线性表在个很大的特点是只有前后关系，不管是链表还是数组，它们都是遵循着这种前后关系的，但是在 树 和 图 中，除了前后之外，还有上下左右等更复杂的关系。虽说它们的基本表现形式依然是使用数组和链表，但是从严格的角度来说，或者从考试面试的角度来说，它们真的不属于线性结构，而应该划分到 非线性结构 中。</p><h2>总结</h2><p>今天这篇文章是学习数据结构中基础的基础。当然，有条件的最好还是看看 C 用结构体是如何定义数组、链表的，PHP 在底层已经帮我们解决了太多问题，所以这些原始的语法结构我们已经用不到了。能够用 C 来学习数据结构是更加推荐的形式。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>下一篇文章我们将介绍的是顺序表（数组）的线性表相关逻辑操作。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2022-01-31 03:30:41', 1);
INSERT INTO `zy_articles_xs_test` VALUES (3, '【PHP数据结构与算法2.2】顺序表（数组）的相关逻辑操作', '<h1>PHP数据结构-顺序表（数组）的相关逻辑操作</h1><p>在定义好了物理结构，也就是存储结构之后，我们就需要对这个存储结构进行一系列的逻辑操作。在这里，我们就从顺序表入手，因为这个结构非常简单，就是我们最常用的数组。那么针对数组，我们通常都会有哪些操作呢？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>不用想得太复杂，我们只需要这几个简单的操作就可以了：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>1.查找</p><p>2.插入</p><p>3.删除</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>是不是很简单？为什么没有遍历呢？我们经常要去遍历一个数组呀？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>请注意，在这里，我们是以数据结构的角度来讲顺序表这个物理结构。遍历操作一般针对的会是更复杂的一些结构，比如树、图，从一个结点开始去遍历所有的路径之类的。而对于顺序表这个物理结构来说来说，我们只需要掌握上述那三个操作，不需要包含遍历。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>又有同学说了，在 PHP 中，这三个操作简直太简单好不好，完全没有技术含量呀！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>小心不要入坑了哦，查找我们说的是找到这个值所在的下标，而不是给你一个下标简单的输出一个值。另外，插入和删除我们是需要考虑一个问题的，那就是我们第 i 个位置插入或者删除数据之后，i+1 及其之后的数据是不是也要相应的移动呢？要小心，我们是插入和删除一个下标位置的内容，而不是修改替换这个下标的内容！！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>好吧，还是直接以实例来说明。</p><h2>插入</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 数组插入\n * @param array $list 顺序表数组\n * @param int $i 插入数据下标\n * @param mixed $e 数组元素\n * return bool 成功失败结果\n */\nfunction ListInsert(array &amp;$list, int $i, $e)\n{\n    $c = count($list);\n    if ($i &lt; 0 || $i &gt; $c) {\n        return false;\n    }\n\n    $j = $c - 1;\n    while ($j &gt;= $i) {\n        // 从后往前，下一个位置的值变成现在这个位置的值\n        // 数据向后挪动\n        $list[$j + 1] = $list[$j];\n        $j--;\n    }\n    // 在指定位置插入值\n    $list[$i] = $e;\n    return true;\n}</code></pre></div><p>插入操作首先要判断是否下标越界。接下来就从后往前地将插入位置之后的数据向后挪动一位，最后将新增加的数据放到指定的位置。需要注意的是，在这个操作中，我们最主要关心的就是这个数据位置的移动。我们为什么要从数组最后一位开始进行挪动，而不是从插入位置开始移动呢？如果从插入位置开始，那么后面的数据就会都是一个数据了，也就是插入位置的下一个数据。大家有兴趣的可以自己尝试一下。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$arr = [1, 2, 3, 4, 5, 6, 7];\n\nListInsert($arr, 3, 55);\nprint_r($arr);\n// Array\n// (\n//     [0] =&gt; 1\n//     [1] =&gt; 2\n//     [2] =&gt; 3\n//     [3] =&gt; 55\n//     [4] =&gt; 4\n//     [5] =&gt; 5\n//     [6] =&gt; 6\n//     [7] =&gt; 7\n// )</code></pre></div><p>在上面的测试代码中，我们往数据的位置 3 处插入一个数据 55 。可以看到输出的结果，数组长度增加了一位，并且从下标 3 的位置开始，后面的数据都向后移动了一位。</p><h2>删除</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 删除指定下标元素\n * @param array $list 顺序表数组\n * @param int $i 插入数据下标\n * return bool 成功失败结果\n */\nfunction ListDelete(array &amp;$list, int $i)\n{\n    $c = count($list);\n    if ($i &lt; 0 || $i &gt; $c - 1) {\n        return false;\n    }\n\n    $j = $i;\n    while ($j &lt; $c) {\n        // 当前位置的值变成下一个位置的值\n        // 数据向前挪动\n        $list[$j] = $list[$j+1];\n        $j++;\n    }\n    // 去掉最后一个数据\n    unset($list[$c - 1]);\n    return true;\n}</code></pre></div><p>学习了上面的插入操作之后，相信大部分同学也能想象到删除元素的操作正好跟插入是返过来的。第一步依然还是判断下标是否合规。接下来就是把指定删除的下标元素之后的元素向前挪动一位。在这里，我们是从删除下标开始将元素依次向前移动一位，最后再删除掉重复的最后一位数据，也就是实现数组元素数量的减 1 操作。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$arr = [1, 2, 3, 4, 5, 6, 7];\nListDelete($arr, 5);\nprint_r($arr);\n// Array\n// (\n//     [0] =&gt; 1\n//     [1] =&gt; 2\n//     [2] =&gt; 3\n//     [3] =&gt; 4\n//     [4] =&gt; 5\n//     [5] =&gt; 7\n// )</code></pre></div><p>测试结果也很清楚，原来在下标 5 位置的元素是 6 。我们删除了下标为 5 的元素后，整个数据的元素数量减少了一位，后面的元素要移动上来，也就是元素 7 要移动到 5 的位置上来。</p><h2>查找</h2><p>查找就是简单的做一个线性查找即可，也就是一个一个的去比对数据，看我们需要的数据在数组的哪个位置。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 查找\n * @param array $list 顺序表数组\n * @param mixed $e 数组元素\n * return int 查找结果下标\n */\nfunction LocateElem(array $list, $e)\n{\n    $c = count($list);\n    for ($i = 0; $i &lt; $c; $i++) {\n        if ($list[$i] == $e) {\n            return $i;\n        }\n    }\n    return -1;\n}</code></pre></div><p>如果找到了数据，我们就返回当前数据所在位置的下标。如果到最后依然没有找到对应的数据，就返回一个 -1 表示我们没有找到对应的数据。</p><h2>总结</h2><p>欢迎进入数据结构与算法的世界，意不意外，惊不惊喜，今天第一次写这么多代码，但是写出来的是不是感觉和我们平常写的不太一样？就像插入和删除的数据移动一样，如果平常没注意的话可能还真的不知道我们应该反过来移动才能得到正确的结果。这就是数据结构和算法学习的乐趣，挑战自己，每一天都是超越！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/2.%E7%BA%BF%E6%80%A7%E8%A1%A8/source/2.2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89%E7%9A%84%E7%9B%B8%E5%85%B3%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/2.线性表/source/2.2%20顺序表（数组）的相关逻辑操作.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2021-03-01 05:26:23', 1);
INSERT INTO `zy_articles_xs_test` VALUES (4, '【PHP数据结构与算法2.3】链表的相关逻辑操作', '<h1>链表的相关逻辑操作</h1><p>链表的操作相对顺序表（数组）来说就复杂了许多。因为 PHP 确实已经为我们解决了很多数组操作上的问题，所以我们可以很方便的操作数组，也就不用为数组定义很多的逻辑操作。比如在 C 中，数组是有长度限制的，而在 PHP 中我们就不会考虑这个问题。如果是使用 C 的话，这个长度限制就是数组结构的一大劣势，而链表，不管是在 C 还是在 PHP 中，都不会受到长度问题的限制。能够限制链表的只有内存的大小。另外，链表的链式结构也能够为我们带来一种全新的不同于数组操作的体验，对某些功能算法来说，链表也更有优势。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>话不多说，直接来进入今天的内容吧！</p><h2>链式结构的定义</h2><p>首先，在之前的关于线性表的第一篇文章中我们就说过链表的定义，在这里，我们再复习一下之前的那个关于链表的图来更清晰的理解链表的概念。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/20220724/dc340de15364b501c915cce9057c2124.jpg\" alt=\"//img1.zyblog.com.cn/20220724/dc340de15364b501c915cce9057c2124.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们将图中的节点 Node 用类来表示：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 链表结构\n */\nclass LinkedList\n{\n    public $data;\n    public $next;\n}</code></pre></div><p>一个链表类就看可以看做是链表中的一个节点，它包含两个内容，data 表示数据，next 表示下一个节点的指针。就像链条一样一环套一环，这就是传说中的链表结构。</p><h2>生成链表及初始化操作</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 生成链表\n */\nfunction createLinkedList()\n{\n    $list = new LinkedList();\n    $list-&gt;data = null;\n    $list-&gt;next = null;\n    return $list;\n}\n\n/**\n * 初始化链表\n * @param array $data 链表中要保存的数据，这里以数组为参考\n * @return LinkedList 链表数据\n */\nfunction Init(array $data)\n{\n    // 初始化\n    $list = createLinkedList();\n    $r = $list;\n    foreach ($data as $key =&gt; $value) {\n        $link = new LinkedList();\n        $link-&gt;data = $value;\n        $link-&gt;next = null;\n        $r-&gt;next = $link;\n        $r = $link;\n    }\n    return $list;\n}\n\n$link = Init(range(1, 10));\n\nprint_r($link);\n// LinkedList Object\n// (\n//     [data] =&gt;\n//     [next] =&gt; LinkedList Object\n//         (\n//             [data] =&gt; 1\n//             [next] =&gt; LinkedList Object\n//                 (\n//                     [data] =&gt; 2\n//                     [next] =&gt; LinkedList Object\n//                         (\n//                             [data] =&gt; 3\n//                             [next] =&gt; LinkedList Object\n//                                 (\n//                                     [data] =&gt; 4\n//                                     [next] =&gt; LinkedList Object\n//                                         (\n//                                             [data] =&gt; 5\n//                                             [next] =&gt; LinkedList Object\n//                                                 (\n//                                                     [data] =&gt; 6\n//                                                     [next] =&gt; LinkedList Object\n//                                                         (\n//                                                             [data] =&gt; 7\n//                                                             [next] =&gt; LinkedList Object\n//                                                                 (\n//                                                                     [data] =&gt; 8\n//                                                                     [next] =&gt; LinkedList Object\n//                                                                         (\n//                                                                             [data] =&gt; 9\n//                                                                             [next] =&gt; LinkedList Object\n//                                                                                 (\n//                                                                                     [data] =&gt; 10\n//                                                                                     [next] =&gt;\n//                                                                                 )\n\n//                                                                         )\n\n//                                                                 )\n\n//                                                         )\n\n//                                                 )\n\n//                                         )\n\n//                                 )\n\n//                         )\n\n//                 )\n\n//         )\n\n// )</code></pre></div><p>在使用链表的时候，我们一般会让第一个结点不包含任何数据，仅仅是做为一个空的结点来指向第一个有数据的结点。这种结点我们可以称之为头结点，如果需要判断链表是否为空的话，只需要判断第一个结点的 next 是否为空就可以了。在上面的代码中，创建链表 createLinkedList() 函数其实就是生成了这样一个头结点。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>然后，我们通过 Init() 初始化函数来构造这个链表。构造过程还是比较简单的，这里我们是固定的传递进来一个数组，按照这个数组结构来构造这个链表，当然，在实际应用中，我们可以使用任何数据来构造链表。构造过程也并不复杂，将当前结点赋值给 r 变量，然后创建一个新结点，让 r-&gt;next 等于这个新创建的节点就可以了。构造好的链表直接打印出来的结构就是注释中的形式。</p><h2>遍历链表</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function IteratorLinkedList(LinkedList $link)\n{\n    while (($link = $link-&gt;next) != null) {\n        echo $link-&gt;data, \',\';\n    }\n    echo PHP_EOL;\n}</code></pre></div><p>链表的遍历是不是非常像某些数据库的游标操作，或者像迭代器模式的操作一样。没错，其实游标和迭代器的结构就是链表的一种表现形式。我们不停的寻找 $next 直到没有下一个结点为止，这样就完成了一次链表的遍历。可以看出，这个过程的时间复杂度是 O(n) 。</p><h2>插入、删除</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 链表指定位置插入元素\n * @param LinkedList $list 链表数据\n * @param int $i 位置\n * @param mixed $data 数据\n */\nfunction Insert(LinkedList &amp;$list, int $i, $data)\n{\n    $j = 0;\n    $item = $list;\n    // 遍历链表，找指定位置的前一个位置\n    while ($j &lt; $i - 1) {\n        $item = $item-&gt;next;\n        $j++;\n    }\n\n    // 如果 item 不存在或者 $i &gt; n+1 或者 $i &lt; 0\n    if ($item == null || $j &gt; $i - 1) {\n        return false;\n    }\n\n    // 创建一个新节点\n    $s = new LinkedList();\n    $s-&gt;data = $data;\n\n    // 新创建节点的下一个节点指向原 i-1 节点的下一跳节点，也就是当前的 i 节点\n    $s-&gt;next = $item-&gt;next;\n    // 将 i-1 节点的下一跳节点指向 s ，完成将 s 插入指定的 i 位置，并让原来的 i 位置元素变成 i+1 位置\n    $item-&gt;next = $s;\n\n    return true;\n}\n\n/**\n * 删除链表指定位置元素\n * @param LinkedList $list 链表数据\n * @param int $i 位置\n */\nfunction Delete(LinkedList &amp;$list, int $i)\n{\n    $j = 0;\n    $item = $list;\n    // 遍历链表，找指定位置的前一个位置\n    while ($j &lt; $i - 1) {\n        $item = $item-&gt;next;\n        $j++;\n    }\n    // 如果 item 不存在或者 $i &gt; n+1 或者 $i &lt; 0\n    if ($item == null || $j &gt; $i - 1) {\n        return false;\n    }\n\n    // 使用一个临时节点保存当前节点信息，$item 是第 i-1 个节点，所以 $item-&gt;next 就是我们要找到的当前这个 i 节点\n    $temp = $item-&gt;next;\n    // 让当前节点，也就是目标节点的上一个节点， i-1 的这个节点的下一跳（原来的 i 位置的节点）变成原来 i 位置节点的下一跳 next 节点，让i位置的节点脱离链条\n    $item-&gt;next = $temp-&gt;next;\n\n    return true;\n}\n\n// 插入\nInsert($link, 5, 55);\n// 遍历链表\nIteratorLinkedList($link); // 1,2,3,4,55,5,6,7,8,9,10,\n\n// 删除\nDelete($link, 7);\n// 遍历链表\nIteratorLinkedList($link); // 1,2,3,4,55,5,7,8,9,10,</code></pre></div><p>链表的插入和删除其实很类似，都是需要寻找到插入或删除位置的前一个元素，也就是第 i-1 这个位置的元素。然后通过对这个元素的 next 指针的操作来实现链表元素的插入删除操作。它们在遍历和位置判断这两个功能中的代码其实都是一样的，不同的是创建时要新创建一个结点，然后让这个结点的 next 指向之前 i-1 位置元素的 next ，再将 i-1 位置元素的 next 指向新创建的这个结点。而删除操作则是保存要删除这个位置 i 的结点到一个临时变量中，然后将 i-1 位置元素的 next 指向删除位置 i 的 next 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上面的解释需要结合代码一步一步来看，当然，我们也可以结合下面的这个图来学习。插入和删除操作是链表操作的核心，也是最复杂的部分，需要多多理解掌握。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/20220724/9af7972da733d93d71526110fad6fff1.jpg\" alt=\"//img1.zyblog.com.cn/20220724/9af7972da733d93d71526110fad6fff1.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><h2>根据位置查找、根据数据查找</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 根据位置查找元素位置\n * @param LinkedList $list 链表数据\n * @param int $i 位置\n */\nfunction GetElem(LinkedList &amp;$list, int $i)\n{\n    $item = $list;\n    $j = 1; // 从第一个开始查找，0是头结点 \n    while ($item &amp;&amp; $j &lt;= $i) {\n        $item = $item-&gt;next;\n        $j++;\n    }\n\n    if (!$item || $j &gt; $i + 1) {\n        return false;\n    }\n    return $item-&gt;data;\n\n}\n\n/**\n * 根据数据查找数据元素所在位置\n * @param LinkedList $list 链表数据\n * @param mixed $data 数据\n */\nfunction LocateElem(LinkedList &amp;$list, $data)\n{\n    $item = $list;\n    $j = 1; // 从第一个开始查找，0是头结点 \n    while (($item = $item-&gt;next)!=null) {\n        if($item-&gt;data == $data){\n            return $j;\n        }\n        $j++;\n    }\n\n    return false;\n}\n\n// 获取指定位置的元素内容\nvar_dump(GetElem($link, 5)); // int(55)\n\n// 获取指定元素所在的位置\nvar_dump(LocateElem($link, 55)); // int(5)</code></pre></div><p>链表的查找有两种形式，一种是给一个位置，比如要我要第五个位置的元素内容，那么就是根据指定位置查找元素的值，就像数组的下标一样。不过需要注意的是，链表的下标是从 1 开始的，因为 0 的位置是我们的头结点了。当然，我们也可以变换代码忽略掉头结点让它和数组保持一致，但这样的话，链表的特点就不明显了，所以这里的测试代码我们还是以 1 为起始。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另一种查找就是给定一个数据内容，查找它在链表的什么位置。其实这两种算法都是在遍历整个链表，本质上没有什么区别。由于链表不像数组一样有下标的能力，所以它的这些查找操作的时间复杂度都是 O(n) 。</p><h2>总结</h2><p>怎么样，难度上来了吧。链表的操作一下就复杂了很多吧，别急，这只是开胃菜。后面学习的内容基本上都会围绕着顺序表（数组）和链表这两种形式进行。而且我们的链表学习还没有结束，下一篇文章，我们将更深入的了解一下链表的另外几种形式：双向链表、循环链表、双向循环链表。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/2.%E7%BA%BF%E6%80%A7%E8%A1%A8/source/2.3%20%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/2.线性表/source/2.3%20链表的相关逻辑操作.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2020-08-22 03:04:03', 1);
INSERT INTO `zy_articles_xs_test` VALUES (5, '【PHP数据结构与算法2.4】链表的其它形式', '<h1>链表的其它形式</h1><p>在上篇文章中，我们已经说过了链表除了简单的那一种单向链表外，还有其它的几种形式。当然，这也是链表这种结构的一大特点，非常地灵活和方便。我们简单的想一想，如果让最后一个节点的 next 指回第一个节点，那么这就样就形成了一个环，这就是一个循环链表了。如果我们在每个节点上增加一个指向上一个节点的 prev 属性，那么这个链表就变成了一个双向链表了。如果我们在双向链表的基础上也让最后一个节点的 next 指向第一个节点，同时让第一个节点的 prev 指向最后一个节点，这不就是一个双向循环链表了嘛。下面我们就来具体的看一看。</p><h2>循环链表</h2><p>就像上文所说的，我们让最后一个节点指向第一个节点，这样形成的链表就是一个循环链表，如下图所示：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/e3c01ff226a05a1df74ff6d680bb0a2a.jpg\" alt=\"//img1.zyblog.com.cn/old/e3c01ff226a05a1df74ff6d680bb0a2a.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>关于循环的链表的操作我们不做详细的说明，其实大部分代码和单向链表是一样的，只是需要注意两个地方：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>1.初始化、插入操作的时候，注意最后一个节点的指向，最后一个节点的 next 要指向第一个节点</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>2.判断链表遍历是否完成的条件为 item-&gt;next == head ，也就是说，判断这个节点的下一个节点如果是头节点的话，链表就遍历完成了。</p><h2>双向链表</h2><p>双向链表则是在 LinkedList 这个类里面增加一个属性来指向上一个节点。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 双向链表\nclass LinkedList\n{\n    public $data;\n\n    public $prev;\n    public $next;\n}</code></pre></div><p><img src=\"//img1.zyblog.com.cn/old/2e18bfdcd4035324fe851b6cfc9ac531.jpg\" alt=\"//img1.zyblog.com.cn/old/2e18bfdcd4035324fe851b6cfc9ac531.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来，我们初始化一个双向链表。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 生成链表\n */\nfunction createLinkedList()\n{\n    $list = new LinkedList();\n    $list-&gt;data = null;\n    $list-&gt;next = null;\n    $list-&gt;prev = null; // ** 全部都初始化为 null **\n    return $list;\n}\n\n/**\n * 初始化链表\n * @param array $data 链表中要保存的数据，这里以数组为参考\n * @return LinkedList 链表数据\n */\nfunction Init(array $data)\n{\n    // 初始化\n    $list = createLinkedList();\n    $r = $list;\n    foreach ($data as $key =&gt; $value) {\n        $link = new LinkedList();\n        $link-&gt;data = $value;\n        $link-&gt;next = null;\n        $r-&gt;next = $link;\n        $link-&gt;prev = $r; // ** 增加上级指向 **\n        $r = $link;\n    }\n    return $list;\n}\n\n$link = Init(range(1, 10));\n\nvar_dump($link);\nvar_dump($link-&gt;next-&gt;next-&gt;next-&gt;next);\n// object(LinkedList)#5 (3) {\n//     [\"data\"]=&gt;\n//     int(4)\n//     [\"prev\"]=&gt;\n//     object(LinkedList)#4 (3) {\n//       [\"data\"]=&gt;\n//       int(3)\n//       [\"prev\"]=&gt;\n//       object(LinkedList)#3 (3) {\n//         [\"data\"]=&gt;\n//         int(2)\n//         [\"prev\"]=&gt;\n//         object(LinkedList)#2 (3) {\n//           [\"data\"]=&gt;\n//           int(1)\n//           [\"prev\"]=&gt;\n//           object(LinkedList)#1 (3) {\n//             [\"data\"]=&gt;\n//             NULL\n//             [\"prev\"]=&gt;\n//             NULL\n//             [\"next\"]=&gt;\n//             *RECURSION*\n//           }\n//           [\"next\"]=&gt;\n//           *RECURSION*\n//         }\n//         [\"next\"]=&gt;\n//         *RECURSION*\n//       }\n//       [\"next\"]=&gt;\n//       *RECURSION*\n//     }\n//     [\"next\"]=&gt;\n//     object(LinkedList)#6 (3) {\n//       [\"data\"]=&gt;\n//       int(5)\n//       [\"prev\"]=&gt;\n//       *RECURSION*\n//       [\"next\"]=&gt;\n//       object(LinkedList)#7 (3) {\n//         [\"data\"]=&gt;\n//         int(6)\n//         [\"prev\"]=&gt;\n//         *RECURSION*\n//         [\"next\"]=&gt;\n//         object(LinkedList)#8 (3) {\n//           [\"data\"]=&gt;\n//           int(7)\n//           [\"prev\"]=&gt;\n//           *RECURSION*\n//           [\"next\"]=&gt;\n//           object(LinkedList)#9 (3) {\n//             [\"data\"]=&gt;\n//             int(8)\n//             [\"prev\"]=&gt;\n//             *RECURSION*\n//             [\"next\"]=&gt;\n//             object(LinkedList)#10 (3) {\n//               [\"data\"]=&gt;\n//               int(9)\n//               [\"prev\"]=&gt;\n//               *RECURSION*\n//               [\"next\"]=&gt;\n//               object(LinkedList)#11 (3) {\n//                 [\"data\"]=&gt;\n//                 int(10)\n//                 [\"prev\"]=&gt;\n//                 *RECURSION*\n//                 [\"next\"]=&gt;\n//                 NULL\n//               }\n//             }\n//           }\n//         }\n//       }\n//     }\n//   }\n\necho $link-&gt;next-&gt;next-&gt;next-&gt;next-&gt;data, PHP_EOL; // 4\necho $link-&gt;next-&gt;next-&gt;next-&gt;next-&gt;prev-&gt;data, PHP_EOL; // 3</code></pre></div><p>可以看出，与单向链表不同的地方就在于多增加了对于 prev 属性的操作。这里还是比较好理解的。直接打印链表会显示很多的 *RECURSION* 内容，这是 PHP 的一种输出的保护机制，这个标识说明当前这个属性变量是有递归类型的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 链表指定位置插入元素\n * @param LinkedList $list 链表数据\n * @param int $i 位置\n * @param mixed $data 数据\n */\nfunction Insert(LinkedList &amp;$list, int $i, $data)\n{\n    $j = 0;\n    $item = $list;\n    // 遍历链表，找指定位置的前一个位置\n    while ($j &lt; $i - 1) {\n        $item = $item-&gt;next;\n        $j++;\n    }\n\n    // 如果 item 不存在或者 $i &gt; n+1 或者 $i &lt; 0\n    if ($item == null || $j &gt; $i - 1) {\n        return false;\n    }\n\n    // 创建一个新节点\n    $s = new LinkedList();\n    $s-&gt;data = $data;\n\n    // 新创建节点的下一个节点指向原 i-1 节点的下一跳节点，也就是当前的 i 节点\n    $s-&gt;next = $item-&gt;next;\n\n    // ** 增加当前新创建的节点的上级指向 **\n    $s-&gt;prev = $item;\n\n    // 将 i-1 节点的下一跳节点指向 s ，完成将 s 插入指定的 i 位置，并让原来的 i 位置元素变成 i+1 位置\n    $item-&gt;next = $s;\n\n    // ** 将下级节点的 prev 指向新创建的这个节点 **\n    $s-&gt;next-&gt;prev = $s;\n\n    return true;\n}</code></pre></div><p>链表的插入其实就是增加了两行代码，一个是当前新创建的节点的上级的指向，也就是将这个新节点的上级指定为 i-1 个节点。而另一个是将原来 i 位置节点的上级指向修改为当前新创建的这个节点。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 删除链表指定位置元素\n * @param LinkedList $list 链表数据\n * @param int $i 位置\n */\nfunction Delete(LinkedList &amp;$list, int $i)\n{\n    $j = 0;\n    $item = $list;\n    // 遍历链表，找指定位置的前一个位置\n    while ($j &lt; $i - 1) {\n        $item = $item-&gt;next;\n        $j++;\n    }\n    // 如果 item 不存在或者 $i &gt; n+1 或者 $i &lt; 0\n    if ($item == null || $j &gt; $i - 1) {\n        return false;\n    }\n\n    // 使用一个临时节点保存当前节点信息，$item 是第 i-1 个节点，所以 $item-&gt;next 就是我们要找到的当前这个 i 节点\n    $temp = $item-&gt;next;\n    // 让当前节点，也就是目标节点的上一个节点， i-1 的这个节点的下一跳（原来的 i 位置的节点）变成原来 i 位置节点的下一跳 next 节点，让i位置的节点脱离链条\n    $item-&gt;next = $temp-&gt;next;\n\n    // ** 让目标下一个节点的上级指针指向当前这个节点 **\n    $temp-&gt;next-&gt;prev = $item;\n\n    return true;\n}</code></pre></div><p>与插入节点操作类似，删除节点操作除了将 i-1 个位置节点的数据的下一个节点的指向变为 i 节点的下一级节点的指向之外，还要将 i 的下一级节点的上级节点指向改为 i-1 节点。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>其实，双向链表的定义和操作相比单向链表来说差别并不大，就是多了一个 prev 用来指向上一级节点而已，本质上也只是多了对于 prev 这个属性的操作而已。那么，多出来的这一个上级指针能带来什么好处呢？在遍历链表的时候，我们通过 prev ，就多了一种遍历方式，也就是反向的对链表进行遍历。在查找某个元素的时候，我们可以从两个方向同时进行查找，效率是不是一下子就提升了一倍。原来 O(n) 的时间复杂度瞬间可以变成 O(n/2) 的时间复杂度。</p><h2>双向循环链表</h2><p>最后，我们也简单的来介绍一下双向循环链表。顾名思义，它就是在双向链表的基础上加上循环链表的概念。让最后一个节点的 next 指向头节点，让头节点的 prev 指向最后一个节点。说起来容易但实现起来其实要复杂很多，因为你不仅要关注最后一个节点的下级节点指向问题，而且还要关注头节点的上级指向问题。所以在这里我们就不多做代码演示了，最主要的就是在插入和删除头、尾节点的时候需要多注意它们上下级节点的指向。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/c979242c612ed6b9bce05aef13a0e08b.jpg\" alt=\"//img1.zyblog.com.cn/old/c979242c612ed6b9bce05aef13a0e08b.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><h2>总结</h2><p>突然发现新大陆了吧？链表原来还有这么多种形式。当然，这还没有说完，我们还有一个很高大上的十字链表没说，不过其实十字链表也只是增加了更多的指向属性而已，基本的数据域永远都还是那一个 data 。其实最普通的单向链表，也就是上一篇文章详细介绍的那个才是我们对于链表学习真正要掌握的重点。因此，大家不必焦虑，也不用恐慌，掌握好普通的单向链表你就可以秒杀绝大部分人了，而今天学习的这些呢？能掌握最好，掌握不了最少混个脸熟就可以了，做人，最重要的是开心了，不要把自己逼的太狠，太狠的话，要么成龙，要么成虫，认清自己的现状和能力才是最重要的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>关于线性表的内容到此为止。物理结构的存储问题就是这样了，接下来我们就要逻辑结构的世界了。也是从最简单的开始，那就是栈和队列，不要怕，它们和 树、图 比起来真的是洒洒水啦！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/2.%E7%BA%BF%E6%80%A7%E8%A1%A8/source/2.4%20%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%B6%E5%AE%83%E5%BD%A2%E5%BC%8F.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/2.线性表/source/2.4%20链表的其它形式.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2020-03-27 21:24:07', 1);
INSERT INTO `zy_articles_xs_test` VALUES (6, '【PHP数据结构与算法3.1】栈的相关逻辑操作', '<h1>栈的相关逻辑操作</h1><p>对于逻辑结构来说，我们也是从最简单的开始。堆栈、队列，这两个词对于大部分人都不会陌生，但是，堆和栈其实是两个东西。在面试的时候千万不要被面试官绕晕了。堆是一种树结构，或者说是完全二叉树的结构。而今天，我们主要讲的就是这个栈的应用。</p><h2>什么是栈？</h2><p>栈一般就是一种顺序的数据结构。它最大的特点就是后进先出（LIFO），或者反过来说先进后出（FILO）也是可以的。这两句话到底是什么意思呢？最典型的例子就是大家看电视剧时，特别是枪战片时绝对会看到的一样东西：弹匣。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/6b60db1c72c6f464bd042b8da4c1850b.jpeg\" alt=\"//img1.zyblog.com.cn/old/6b60db1c72c6f464bd042b8da4c1850b.jpeg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>弹匣在装弹的时候都是一个一个的将子弹压进弹匣的，也就是说，第一颗子弹是被压在最底下的，而开枪的时候则是按相反的顺序从弹匣的最顶部弹出来的，第一颗放进去的子弹是最后一个才被打出来的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这个例子其实已经非常形象了，我们再统一一下术语。将子弹压进弹匣叫做“入栈”，第一颗子弹在最底下，这个位置叫做“栈底”，最后一颗子弹在最顶上，这个位置叫做“栈顶”，打出的这颗子弹是“栈顶”的那颗子弹，这个操作叫做“出栈”。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>通过上面术语的定义，我们就可以看出，栈的逻辑操作主要就是“入栈”和“出栈”，而逻辑结构最需要关心的是这个“栈顶”和“栈底”在进行出入栈时的状态。当然，栈的逻辑结构使用顺序或链式结构都是没有问题的，我们就一个一个地来看一下。</p><h2>顺序栈</h2><p>首先还是比较简单的顺序栈的实现。既然是顺序结构，那么就是用数组了。不过，我们还需要记录一下“栈顶”或“栈底”的情况，所以我们将顺序栈的这个数组封装到一个类中。同时，在这个类中定义一个属性来标明当前栈的“栈顶”或“栈底”指针，其实就是当前“栈顶”或“栈底”在数组中的下标位置。通常来说，我们只需要记录“栈顶”的位置就可以了，将“栈底”默认为 -1 即可。因为数组下标本身是从 0 开始的，所以当“栈顶”属性为 -1 时，这个栈就是一个空栈，因为它的“栈顶”和“栈底”在一起，里面并没有元素。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class SqStack\n{\n    public $data;\n    public $top;\n}</code></pre></div><p>初始化顺序栈很简单，一个空的数组并将 $top 设置为 -1 。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function InitSqStack()\n{\n    $stack = new SqStack();\n    $stack-&gt;data = [];\n    $stack-&gt;top = -1;\n    return $stack;\n}</code></pre></div><p>接下来就是“入栈”和“出栈”的操作了，先看代码。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function PushSqStack(SqStack &amp;$stack, $x){\n    $stack-&gt;top ++;\n    $stack-&gt;data[$stack-&gt;top] = $x;\n}\n\nfunction PopSqStack(SqStack &amp;$stack){\n    // 栈空\n    if($stack-&gt;top == -1){\n        return false;\n    }\n\n    $v = $stack-&gt;data[$stack-&gt;top];\n    $stack-&gt;top--;\n    return $v;\n}</code></pre></div><p>入栈很简单，给数组元素添加内容，然后 $top++ 就可以了。不过如果是 C 语言的话，因为它有数组长度的限制，所以在入栈的时候，我们也需要判断一下栈是否已经满了。当然，在 PHP 中我们就没有这个顾虑啦。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>顺序栈入栈图示</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/b3019e1944cfcac34088e7aa42b61039.jpg\" alt=\"//img1.zyblog.com.cn/old/b3019e1944cfcac34088e7aa42b61039.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>出栈的时候需要判断当前的栈是否已经空了，这个就不区分什么语言了，因为要是比 -1 还小的话，再次使用这个栈就会出现问题了。在出栈的时候如果栈已经空了就不要再给 $top-- 了，然后获取栈顶元素并返回就可以了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>顺序栈出栈图示</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/90717f073a5ef20f18ec31729b01c82e.jpg\" alt=\"//img1.zyblog.com.cn/old/90717f073a5ef20f18ec31729b01c82e.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们来看一下这个顺序栈的测试结果。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$stack = InitSqStack();\n\nPushSqStack($stack, \'a\');\nPushSqStack($stack, \'b\');\nPushSqStack($stack, \'c\');\n\nvar_dump($stack);\n// object(SqStack)#1 (2) {\n//     [\"data\"]=&gt;\n//     array(3) {\n//       [0]=&gt;\n//       string(1) \"a\"\n//       [1]=&gt;\n//       string(1) \"b\"\n//       [2]=&gt;\n//       string(1) \"c\"\n//     }\n//     [\"top\"]=&gt;\n//     int(2)\n//   }\n\necho PopSqStack($stack), PHP_EOL; // c\necho PopSqStack($stack), PHP_EOL; // b\necho PopSqStack($stack), PHP_EOL; // a\n\nvar_dump($stack);\n// object(SqStack)#1 (2) {\n//     [\"data\"]=&gt;\n//     array(3) {\n//       [0]=&gt;\n//       string(1) \"a\"\n//       [1]=&gt;\n//       string(1) \"b\"\n//       [2]=&gt;\n//       string(1) \"c\"\n//     }\n//     [\"top\"]=&gt;\n//     int(-1)\n//   }</code></pre></div><p>通过数组来操作栈是不是非常地简单。看完学习完链栈之后，我们还会讲到 PHP 已经为我们准备好的数组栈的操作函数哦，使用起来会更加的方便。</p><h2>链栈</h2><p>其实对于链式存储结构来说，核心的内容还是一样的，同样是要关心我们的栈顶，也同样要关心出入栈的操作。但是，在链式中，我们可以使有头插法，也就是让插入的数据保持在链的顶端来实现“栈顶”的效果。这样，我们就不需要一个专门的属性来保存当前的栈顶位置了。直接通过一个图来理解会更清晰。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/7788f4d72e70aed34c21ebf232dab7b8.jpg\" alt=\"//img1.zyblog.com.cn/old/7788f4d72e70aed34c21ebf232dab7b8.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class LinkStack{\n    public $data;\n    public $next;\n}</code></pre></div><p>数据的结构就是一个典型的链式结构就可以了，主要还是看出入栈的操作是如何进行的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function InitLinkStack(){\n    return null;\n}\n\nfunction PushLinkStack(?LinkStack &amp;$stack, $x){\n    $s = new LinkStack();\n    $s-&gt;data = $x;\n    $s-&gt;next = $stack;\n    $stack = $s;\n}\n\nfunction PopLinkStack(?LinkStack &amp;$stack){\n    if($stack == NULL){\n        return false;\n    }\n    $v = $stack-&gt;data;\n    $stack = $stack-&gt;next;\n    return $v;\n}</code></pre></div><p>在链栈中其实初始化空栈的操作意义不大。我们可以直接定义一个 null 变量然后针对它进行链式操作就可以了，但在这里我们还是与顺序栈保持统一。就像顺序栈中的栈底为 -1 一样，在链栈中，我们也约定好栈底为一个 null 对象节点。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来就是入栈操作了。这里我们使用的是头插法，其实就是将新元素放到链表的顶端。先实例化一个节点，然后将这个节点的 next 指向链表的头节点。接着再让当前这个节点成为链表的新的头节点，就像下图所示的那样。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/c1e4152c20215b24a2f1929fb96496cb.jpg\" alt=\"//img1.zyblog.com.cn/old/c1e4152c20215b24a2f1929fb96496cb.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>同理，出栈的操作其实也是类似的，将头节点变成当前头节点的 next 节点，直到当前节点变成 null ，也就是栈已经空了，如图所示：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/5642ccabcae2517483f75fbd6d65a90a.jpg\" alt=\"//img1.zyblog.com.cn/old/5642ccabcae2517483f75fbd6d65a90a.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>最后，我们同样的测试一下这一套链式栈的代码运行情况如何。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$stack = InitLinkStack();\n\nPushLinkStack($stack, \'a\');\nPushLinkStack($stack, \'b\');\nPushLinkStack($stack, \'c\');\n\nvar_dump($stack);\n// object(LinkStack)#3 (2) {\n//     [\"data\"]=&gt;\n//     string(1) \"c\"\n//     [\"next\"]=&gt;\n//     object(LinkStack)#2 (2) {\n//       [\"data\"]=&gt;\n//       string(1) \"b\"\n//       [\"next\"]=&gt;\n//       object(LinkStack)#1 (2) {\n//         [\"data\"]=&gt;\n//         string(1) \"a\"\n//         [\"next\"]=&gt;\n//         NULL\n//       }\n//     }\n//   }\n\necho PopLinkStack($stack), PHP_EOL; // c\necho PopLinkStack($stack), PHP_EOL; // b\necho PopLinkStack($stack), PHP_EOL; // a\n\nvar_dump($stack);\n// NULL</code></pre></div><p>是不是很多小伙伴已经看出之前我们花费了 4 篇文章的时间来讲述线性结构中的顺序表和链表的重要作用了吧。它们真的是一切其它逻辑结构的基础。不光是栈，在队列、树、图中我们都会有不同结构的线性和链式的实现。当然，更重要的是能体会它们之间的区别，在不同的业务场景中，两种不同的存储结构可能真的会带来完全不一样的体验。</p><h2>PHP 为我们提供的数组栈操作</h2><p>最后，我们简单的看一下在 PHP 中已经为我们准备好的两个数组操作函数。有了它们，对于顺序栈来说，我们的操作可以简化到非常傻瓜智能的效果。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$sqStackList = [];\n\narray_push($sqStackList, \'a\');\narray_push($sqStackList, \'b\');\narray_push($sqStackList, \'c\');\n\nprint_r($sqStackList);\n// Array\n// (\n//     [0] =&gt; a\n//     [1] =&gt; b\n//     [2] =&gt; c\n// )\n\narray_pop($sqStackList);\nprint_r($sqStackList);\n// Array\n// (\n//     [0] =&gt; a\n//     [1] =&gt; b\n// )\n\necho count($sqStackList) &gt; 0 ? $sqStackList[count($sqStackList) - 1] : false, PHP_EOL;\n// b\n\narray_pop($sqStackList);\n\necho count($sqStackList) &gt; 0 ? $sqStackList[count($sqStackList) - 1] : false, PHP_EOL;\n// c\n\narray_pop($sqStackList);\n\nprint_r($sqStackList);\n// Array\n// (\n// )</code></pre></div><p>估计不少同学早就用过这两个函数了。array_push() 就是向数组中压入一个数据，其实说白了，增加一个数据到数组中而已，没什么特别稀罕的功能。而 array_pop() 则是将数组最后一个位置的数据弹出。是不是和我们上面自己实现的那个顺序栈是完全相同的概念。没错，既然语言环境已经为我们准备好了，那么除了在某些场景下需要链式结构的话，大部分情况下我们直接使用这两个函数就可以方便地实现 PHP 中的栈操作了。</p><h2>总结</h2><p>栈这个逻辑结构是不是非常的简单清晰呀，在日常应用中其实栈的使用非常广泛。比如算式中的前缀算式、中缀算式、后缀算式的转化，比如我们后面学习树、图时要接触到了BFS（深度搜索），再根据BFS引出递归这个概念。另外，在解析字符时的一些对称匹配、回文算法的判断等等，这些都是栈的典型应用。可以说，栈这个东西撑起了计算机算法的半壁江山。而另外半壁呢？当然就是我们下回要讲的：队列。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/source/3.1%E6%A0%88%E7%9A%84%E7%9B%B8%E5%85%B3%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/3.栈和队列/source/3.1栈的相关逻辑操作.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2020-07-13 09:25:04', 1);
INSERT INTO `zy_articles_xs_test` VALUES (7, '【PHP数据结构与算法3.2】队列的相关逻辑操作', '<h1>队列的相关逻辑操作</h1><p>在逻辑结构中，我们已经学习了一个非常经典的结构类型：栈。今天，我们就来学习另外一个也是非常经典的逻辑结构类型：队列。相信不少同学已经使用过 redis 、 rabbitmq 之类的缓存队列工具。其实，数据库、程序代码，这些都可以实现队列的操作，就和栈一样，队列也是有其特定的规则，只要符合这个规则，它就叫做队列。</p><h2>什么是队列？</h2><p>相对于栈来说，队列是一种先进先出（FIFO）的顺序逻辑结构。什么叫先进先出呢？就和我们的排队一样，当我们去银行或者医院的时候，总是要在门口取一个号，这个号是按顺序叫的。先来的人就可以先办业务或者看病，这就是一个典型的队列。同理，日常的排队就是一个标准的队列模式。如果有插队的，在有正当理由的情况下，我们可以认为它的优先级更高，这是队列中元素的一种特殊形式。就像我们会在等地铁或者公交的时候让孕妇优先，在排队买火车票的时候也有军人的优先窗口。不过，这个并不在我们这次的讨论范围之内。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/63925b311ef5b8d471683471a01efc05.jpeg\" alt=\"//img1.zyblog.com.cn/old/63925b311ef5b8d471683471a01efc05.jpeg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在公交站排队时，排第一个的当然可以第一个上车，然后依次。这时，你来到了公交站，那么你只能排到最后一位。这个就是队列的具体表现形式。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>同样，和栈一样，也有一些名词我们需要了解。当你来到公交站并排到最后一位时，这个操作叫作“入队”。当公交车进站后，第一位乘客上车，这个操作叫做“出队”。第一位乘客所处的位置叫做“队头”，你做为当前队列的最后一位乘客，你的位置就叫做“队尾”。回到代码逻辑上面来看，也就是说队列是从“队尾”“入队”，从“队头”“出队”。</p><h2>顺序队列</h2><p>OK，我们还是直接从来代码来看，首先看到的依然是顺序队的实现。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class SqQueue{\n    public $data;\n    public $front;\n    public $rear;\n}</code></pre></div><p>既然是顺序队，我们依然还是用一个数组 data 来表示队内的元素。然后定义两个指针 front 和 rear 来表示队头和队尾。因为是顺序队，所以这里的指针其实也就是保存的是数组的下标。接下来的操作其实就非常的简单了，“入队”时 rear++ ，“出队”时 front++ 。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function InitSqQueue(){\n    $queue = new SqQueue();\n    $queue-&gt;data = [];\n    $queue-&gt;front = 0;\n    $queue-&gt;rear = 0;\n    return $queue;\n}\n\nfunction EnSqQueue(SqQueue &amp;$queue, $e){\n    $queue-&gt;data[$queue-&gt;rear] = $e;\n    $queue-&gt;rear ++;\n}\n\nfunction DeSqQueue(SqQueue &amp;$queue){\n    // 队列为空\n    if($queue-&gt;front == $queue-&gt;rear){\n        return false;\n    }\n    $e = $queue-&gt;data[$queue-&gt;front];\n    $queue-&gt;front++;\n    return $e;\n}\n\n$q = InitSqQueue();\nEnSqQueue($q, \'A\');\nEnSqQueue($q, \'B\');\nprint_r($q);\n// SqQueue Object\n// (\n//     [data] =&gt; Array\n//         (\n//             [0] =&gt; A\n//             [1] =&gt; B\n//         )\n\n//     [front] =&gt; 0\n//     [rear] =&gt; 2\n// )</code></pre></div><p>是不是感觉学过了栈之后，队列也很好理解了。初始化队列时，就是让队头和队尾指针都是 0 下标的记录就可以了。入队的时候让队尾增加，在这段代码中，我们入队了两个元素，打印出来的顺序队列内容就如注释所示。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">EnSqQueue($q, \'C\');\nEnSqQueue($q, \'D\');\nEnSqQueue($q, \'E\');\nprint_r($q);\n// SqQueue Object\n// (\n//     [data] =&gt; Array\n//         (\n//             [0] =&gt; A\n//             [1] =&gt; B\n//             [2] =&gt; C\n//             [3] =&gt; D\n//             [4] =&gt; E\n//         )\n\n//     [front] =&gt; 0\n//     [rear] =&gt; 5\n// )\n\necho DeSqQueue($q), PHP_EOL; // A\necho DeSqQueue($q), PHP_EOL; // B\necho DeSqQueue($q), PHP_EOL; // C\necho DeSqQueue($q), PHP_EOL; // D\necho DeSqQueue($q), PHP_EOL; // E\n\necho DeSqQueue($q), PHP_EOL; // \n\nprint_r($q);\n// SqQueue Object\n// (\n//     [data] =&gt; Array\n//         (\n//             [0] =&gt; A\n//             [1] =&gt; B\n//             [2] =&gt; C\n//             [3] =&gt; D\n//             [4] =&gt; E \n//         )\n\n//     [front] =&gt; 5\n//     [rear] =&gt; 5\n// )</code></pre></div><p>出队的时候，就让 front 进行加 1 操作。不过，在出队的时候还需要判断数组中的元素是否全部出队了，在这里，我们只用了一个非常简单的判断条件，那就是 front 和 rear 是否相等来判断队列是否空了。大家可以通过一个图示来辅助对代码的理解。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/6bcd43e96d68e36b01f53fc29ff8fd43.jpg\" alt=\"//img1.zyblog.com.cn/old/6bcd43e96d68e36b01f53fc29ff8fd43.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><h3>循环队列</h3><p>相信已经有不少同学看出来了。队列操作只是修改队头和队尾的指针记录，但是数组会一直增加，这样如果一直增加的话，就会导致这一个数组占满内存，这肯定不是一个好的队列实现。其实，在 C 语言中，数组就是要给一个固定的长度的。而 PHP 中的数组更像是一个 Hash 结构，所以它是可以无限增长的，并不需要我们在一开始定义一个具体的数组长度。这也是 PHP 的方便之处，不过如果我们不想浪费内存空间的话，应该怎么办呢？就像在 C 语言中一样，我们在 PHP 中也为数组指定一个长度，并且使用非常经典的“循环队列”来解决队列数组的存储问题。就像下图所示：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/a6023e8c310a17e290e36119ddee6937.jpg\" alt=\"//img1.zyblog.com.cn/old/a6023e8c310a17e290e36119ddee6937.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>其实意思就是，在有限的数组空间范围内，当我们达到数组的最大值时，将新的数据保存回之前的下标位置。比如图中我们有 6 个元素，当前队头在 2 下标，队尾在 5 下标。如果我们入队一个元素，队尾移动到 6 下标。再添加一个元素的话，队尾移动回 0 下标，如果继续添加的话，当队尾下标等于队头下标减 1 的时候，我们就认为这个队列已经满了，不能再增加元素了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>同理，出队操作的时候我们也是循环地操作队头元素，当队头元素到 6 的下标后，继续出队的话，也会回到 0 下标的位置继续出队。当队头和队尾相等时，当前的队列也可以判定为空队列了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>由此，我们可以看出，循环队列相比普通的线性队列来说，多了一个队满的状态。我们还是直接从代码中来看看这个队满的条件是如何判断的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">define(\'MAX_QUEUE_LENGTH\', 6);\n\nfunction EnSqQueueLoop(SqQueue &amp;$queue, $e){\n    // 判断队列是否满了\n    if(($queue-&gt;rear + 1) % MAX_QUEUE_LENGTH == $queue-&gt;front){\n        return false;\n    }\n    $queue-&gt;data[$queue-&gt;rear] = $e;\n    $queue-&gt;rear = ($queue-&gt;rear + 1) % MAX_QUEUE_LENGTH; // 改成循环下标\n}\n\nfunction DeSqQueueLoop(SqQueue &amp;$queue){\n    // 队列为空\n    if($queue-&gt;front == $queue-&gt;rear){\n        return false;\n    }\n    $e = $queue-&gt;data[$queue-&gt;front];\n    $queue-&gt;front = ($queue-&gt;front + 1) % MAX_QUEUE_LENGTH; // 改成循环下标\n    return $e;\n}\n\n$q = InitSqQueue();\nEnSqQueueLoop($q, \'A\');\nEnSqQueueLoop($q, \'B\');\nEnSqQueueLoop($q, \'C\');\nEnSqQueueLoop($q, \'D\');\nEnSqQueueLoop($q, \'E\');\n\nEnSqQueueLoop($q, \'F\');\n\nprint_r($q);\n// SqQueue Object\n// (\n//     [data] =&gt; Array\n//         (\n//             [0] =&gt; A\n//             [1] =&gt; B\n//             [2] =&gt; C\n//             [3] =&gt; D\n//             [4] =&gt; E\n//             [5] =&gt;   // 尾\n//         )\n\n//     [front] =&gt; 0\n//     [rear] =&gt; 5\n// )\n\necho DeSqQueueLoop($q), PHP_EOL;\necho DeSqQueueLoop($q), PHP_EOL;\nprint_r($q);\n// SqQueue Object\n// (\n//     [data] =&gt; Array\n//         (\n//             [0] =&gt; A\n//             [1] =&gt; B\n//             [2] =&gt; C // 头\n//             [3] =&gt; D\n//             [4] =&gt; E\n//             [5] =&gt;   // 尾\n//         )\n\n//     [front] =&gt; 2\n//     [rear] =&gt; 5\n// )\n\nEnSqQueueLoop($q, \'F\');\nEnSqQueueLoop($q, \'G\');\n\nEnSqQueueLoop($q, \'H\');\nprint_r($q);\n// SqQueue Object\n// (\n//     [data] =&gt; Array\n//         (\n//             [0] =&gt; G\n//             [1] =&gt; B // 尾\n//             [2] =&gt; C // 头\n//             [3] =&gt; D\n//             [4] =&gt; E\n//             [5] =&gt; F\n//         )\n\n//     [front] =&gt; 2\n//     [rear] =&gt; 1\n// )\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>出、入队的下标移动以及队满的判断，都是以 (queue-&gt;rear + 1) % MAX_QUEUE_LENGTH 这个形式进行的。根据队列长度的取模来获取当前的循环下标，是不是非常地巧妙。不得不感慨先人的智慧呀！当然，这也是基本的数学原理哦，所以，学习数据结构还是要复习一下数学相关的知识哦！</p><h2>链式队列</h2><p>顺序队列有没有看懵？没关系，队列的链式结构其实相比顺序结构还要简单一些，因为它真的只需要操作队头和队尾的指针而已，别的真的就不太需要考虑了。而且这个指针就是真的指向具体对象的指针了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class LinkQueueNode{\n    public $data;\n    public $next;\n}\n\nclass LinkQueue{\n    public $first; // 队头指针\n    public $rear; // 队尾指针\n}</code></pre></div><p>这里我们需要两个基本的物理结构。一个是节点 Node ，一个是队列对象，节点对象就是一个正常的链表结构，没啥特别的。而队列对象里面就更简单了，一个属性是队头指针，一个属性是队尾指针。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function InitLinkQueue(){\n    $node = new LinkQueueNode();\n    $node-&gt;next = NULL;\n    $queue = new LinkQueue();\n    $queue-&gt;first = $node;\n    $queue-&gt;rear = $node;\n    return $queue;\n}\n\nfunction EnLinkQueue(LinkQueue &amp;$queue, $e){\n    $node = new LinkQueueNode();\n    $node-&gt;data = $e;\n    $node-&gt;next = NULL;\n\n    $queue-&gt;rear-&gt;next = $node;\n    $queue-&gt;rear = $node;\n}\n\nfunction DeLinkQueue(LinkQueue &amp;$queue){\n    if($queue-&gt;front == $queue-&gt;rear){\n        return false;\n    }\n\n    $node = $queue-&gt;first-&gt;next;\n    $v = $node-&gt;data;\n\n    $queue-&gt;first-&gt;next = $node-&gt;next;\n    if($queue-&gt;rear == $node){\n        $queue-&gt;rear = $queue-&gt;first;\n    }\n\n    return $v;\n}\n\n$q = InitLinkQueue();\nEnLinkQueue($q, \'A\');\nEnLinkQueue($q, \'B\');\nEnLinkQueue($q, \'C\');\nEnLinkQueue($q, \'D\');\nEnLinkQueue($q, \'E\');\n\nprint_r($q);\n// LinkQueue Object\n// (\n//     [first] =&gt; LinkQueueNode Object\n//         (\n//             [data] =&gt; \n//             [next] =&gt; LinkQueueNode Object\n//                 (\n//                     [data] =&gt; A\n//                     [next] =&gt; LinkQueueNode Object\n//                         (\n//                             [data] =&gt; B\n//                             [next] =&gt; LinkQueueNode Object\n//                                 (\n//                                     [data] =&gt; C\n//                                     [next] =&gt; LinkQueueNode Object\n//                                         (\n//                                             [data] =&gt; D\n//                                             [next] =&gt; LinkQueueNode Object\n//                                                 (\n//                                                     [data] =&gt; E\n//                                                     [next] =&gt; \n//                                                 )\n\n//                                         )\n\n//                                 )\n\n//                         )\n\n//                 )\n\n//         )\n\n//     [rear] =&gt; LinkQueueNode Object\n//         (\n//             [data] =&gt; E\n//             [next] =&gt; \n//         )\n\n// )\n\necho DeLinkQueue($q), PHP_EOL; // A\necho DeLinkQueue($q), PHP_EOL; // B\n\nEnLinkQueue($q, \'F\');\nprint_r($q);\n// LinkQueue Object\n// (\n//     [first] =&gt; LinkQueueNode Object\n//         (\n//             [data] =&gt; \n//             [next] =&gt; LinkQueueNode Object\n//                 (\n//                     [data] =&gt; C\n//                     [next] =&gt; LinkQueueNode Object\n//                         (\n//                             [data] =&gt; D\n//                             [next] =&gt; LinkQueueNode Object\n//                                 (\n//                                     [data] =&gt; E\n//                                     [next] =&gt; LinkQueueNode Object\n//                                         (\n//                                             [data] =&gt; F\n//                                             [next] =&gt; \n//                                         )\n\n//                                 )\n\n//                         )\n\n//                 )\n\n//         )\n\n//     [rear] =&gt; LinkQueueNode Object\n//         (\n//             [data] =&gt; F\n//             [next] =&gt; \n//         )\n\n// )</code></pre></div><p>出、入队的代码函数和测试代码就一并给出了，是不是非常的简单。初始的队头元素依然是一个空节点做为起始节点。然后入队的时候，让 rear 等于新创建的这个节点，并在链表中建立链式关系。出队的时候也是同样的让 first 变成当前这个 first 的下一跳节点，也就是 first-&gt;next 就可以了。判断队空的条件也是简单的变成了队头和队尾指针是否相等就可以了。链队相比顺序队其实是简单了一些，不过同样的，next 这个东西容易让人头晕，硬记下来就可以了。大家还是可以结合图示来学习：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/528092b7cad227c74f0e6b2cf405a529.jpg\" alt=\"//img1.zyblog.com.cn/old/528092b7cad227c74f0e6b2cf405a529.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><h2>PHP 为我们提供的数组队列操作</h2><p>最后，就和栈一样，PHP 代码中也为我们提供了一个可以用于队列操作的函数。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$sqQueueList = [];\n\narray_push($sqQueueList, \'a\');\narray_push($sqQueueList, \'b\');\narray_push($sqQueueList, \'c\');\n\nprint_r($sqQueueList);\n// Array\n// (\n//     [0] =&gt; a\n//     [1] =&gt; b\n//     [2] =&gt; c\n// )\n\narray_shift($sqQueueList);\nprint_r($sqQueueList);\n// Array\n// (\n//     [0] =&gt; b\n//     [1] =&gt; c\n// )</code></pre></div><p>array_shift() 函数就是弹出数组中最前面的那个元素。请注意，这里元素的下标也跟着变动了，如果我们是 unset() 掉数组的 0 下标元素的话，b 和 c 的下标依然还会是 1 和 2 。而 array_shift() 则会重新整理数组，让其下标依然有序。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">unset($sqQueueList[0]);\nprint_r($sqQueueList);\n// Array\n// (\n//     [1] =&gt; c\n// )</code></pre></div><h2>总结</h2><p>关于栈的队列的内容我们就通过两篇文章介绍完了。不过光说不练假把式，接下来，我们来一点真实的干货，使用栈和队列来做做题呗，学算法就得刷题，一日不刷如隔三秋呀！！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/source/3.2%E9%98%9F%E5%88%97%E7%9A%84%E7%9B%B8%E5%85%B3%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/3.栈和队列/source/3.2队列的相关逻辑操作.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2021-06-30 08:54:21', 1);
INSERT INTO `zy_articles_xs_test` VALUES (8, '【PHP数据结构与算法3.3】栈和队列的应用', '<h1>栈和队列的应用</h1><p>通过栈和队列的学习，我们似乎会感觉到其实数据结构还是非常简单的嘛。当然，这只是一个开始，我们从顺序表、链表开始，到现在的栈和队列，其实都是为了将来在铺路。在树和图的遍历算法中，都可以见到栈和队列的身影。在这里，我们先简单的看看栈和队列的一些实际应用。</p><h2>回文题</h2><p>假设有一段文字，我们要判断它是不是“回文”（不是回族兄弟的文字）。就可以应用栈来解决这个问题。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>回文指的就是将这段文字一分为二之后，前面一段内容和后面一段内容是完全相同的，但是顺序是相反的。比如非常出名的：上海自来水来自海上。上海自来，来自海上，这样的两段结构在一句话里就构成了一段回文。又比如双数长度的一段字符：abcddcba，这也是一段回文。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>类似的这种题目其实很容易出现在一些简单的算法面试题中，相信也有不少小伙伴已经看出端倪了，我们可以将前半段入栈，然后再一个一个的出栈与后半段进行比对就可以判断当前的字符串是否是回文了。别光说不练，我们就上代码来实现。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$string1 = \'abcdedcba\';\n$string2 = \'abcdeedcba\';\n$string3 = \'abcdefcba\';\n\nfunction getIsPlalindrome($string)\n{\n    if (gettype($string) != \'string\') {\n        return false;\n    }\n    $strlen = strlen($string);\n    $mid = floor($strlen / 2);\n    $arr = [];\n\n    if ($strlen &lt; 2) {\n        return false;\n    }\n\n    // 入栈\n    for ($i = 0; $i &lt; $mid; $i++) {\n        array_push($arr, $string[$i]);\n    }\n\n    $j = $mid;\n    $i = $strlen % 2 == 0 ? $mid : $mid + 1; // $i 从中位数开始\n    for (; $i &lt; $strlen; $i++) {\n        $v = $arr[$j - 1]; // 获得栈顶元素\n        if ($v != $string[$i]) {\n            return false;\n        }\n        array_pop($arr); // 弹出栈顶元素\n        $j--;\n    }\n    if ($arr) {\n        return false;\n    }\n    return true;\n}\n\nvar_dump(getIsPlalindrome($string1)); // bool(true)\nvar_dump(getIsPlalindrome($string2)); // bool(true)\nvar_dump(getIsPlalindrome($string3)); // bool(false)</code></pre></div><p>很简单吧，就是使用 array_push() 和 array_pop() 来进行的顺序栈的操作而已。唯一需要注意的就是对于字符长度奇偶数的不同，我们要取的中位数也相应的要发生改变。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>回文算法还是比较简单的，另外还经常会出现的像是简单的括号匹配、算式运算、中缀转后缀表达式这类的题目都是栈的典型算法面试题。大家可以自行查找相关的内容来尝试尝试。</p><h2>递归</h2><p>在讲递归前，我们要弄清楚一件事情，那就是：编程语言中的函数调用本质上就是栈的调用。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>怎么理解这句话呢？当我们执行代码时，如果遇到一个函数，总是会先进入到这个函数中，运行完这个函数中的代码之后才会再回到原来的代码执行线中继续执行调用当前这个函数的代码。比如下面这段代码。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function testA()\n{\n    echo \'A start.\', PHP_EOL;\n    testB();\n    echo \'A end.\', PHP_EOL;\n}\nfunction testB()\n{\n    echo \'B start.\', PHP_EOL;\n    echo \'B end.\', PHP_EOL;\n}\necho \'P start.\', PHP_EOL;\ntestA();\necho \'P end.\', PHP_EOL;\n\n// P start.\n// A start.\n// B start.\n// B end.\n// A end.\n// P end.</code></pre></div><p>当前页面 P ，在运行到 testA() 函数时，就进入了 testA() 函数内部执行其内部的代码，也就是 P -&gt; A 。然后 testA() 函数又调用了 testB() 函数，那么现在就进入了 testB() 中并执行该函数体内的代码，也就是 P -&gt; A -&gt; B 。当 testB() 的代码运行完成后，返回到 testA() 继续执行 testA() 函数体里面的内容，最后回到页面 P 继续向下执行，也就是 B -&gt; A -&gt; P 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上面这段描述如果一次没看明白的话，请再多看几次，细细品。这不就是一个栈的调用过程嘛！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/a9e9e0dd11043d93a6be1ce2420e8d80.jpg\" alt=\"//img1.zyblog.com.cn/old/a9e9e0dd11043d93a6be1ce2420e8d80.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这么一看，在编程语言中，栈还真是深入骨髓般的存在。因为你只要是在开发代码，那么你一定就是在运用栈这个东西了。而“递归”，则是栈的更典型的实现。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function recursion($n)\n{\n    if ($n == 0 || $n == 1) {\n        return 1;\n    }\n    $result = recursion($n - 1) * $n;\n    return $result;\n}\n\necho recursion(10), PHP_EOL;</code></pre></div><p>这是一段简单的阶乘算法的递归实现，由于递归会建立一个栈，所以我们这段代码最先计算出来的是的栈底的 n 是 1，出栈返回 1 之后，再出栈时就是用 1 乘以 2 ，再继续出栈就是 2 乘以 3 ，依次类推，直到计算出从 1 到 10 的阶乘结果。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/c7dddcee81308052302a667de9ebae29.jpg\" alt=\"//img1.zyblog.com.cn/old/c7dddcee81308052302a667de9ebae29.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>递归相关的面试题也是我们在面试中非常常见的内容，所以我们一定要把握好递归其实就是栈的一种表现形式，然后运用栈的思想来解构整个递归的调用过程。</p><h2>队列应用</h2><p>最后，我们再讲讲队列的一些实际应用。队列在代码层面其实并没有太多很好的示例，比较常见的可能有两个队列合并出队（舞伴问题）或者两组队列一起出队，一边出两个另一个才能出一个之类的这种问题。大家可以自行查找一下相关的题目。相对来说，队列的算法题在面试题中还是比较少的，包括在考研的时候也多是以选择判断之类的题目出现的。不过，在实际应用中，队列现在却是解决高并发问题的超级法宝，也是面试官判断你经验的一个重要内容。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在实际的项目开发中，队列最典型的一个功能就是秒杀问题。就像抢火车票或者抢小米手机一样，在整点的时候，大量的请求涌入，如果仅仅依靠服务器来处理，超高的并发量不仅会带给服务器巨大压力，而且还有可能出现各种高并发场景下才会出现的问题，比如超卖、事务异常等。（多个线程同时更新数据）</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>而队列，正是解决这个问题的一把好手。通常我们会使用的队列系统（redis、rabbitmq）都是以内存为主的队列系统，它们的特点就是存储非常快。由前端（生产者）生成的大量请求都存入队列中（入队），然后在后台脚本（消费者）中进行处理（出队）。前端只需要返回一个正在处理中，或者正在排队的提示即可，然后后台处理完成后，通知前台显示结果。这样，在一个秒杀场景中基本上就算是解决了高并发的问题了。当然，现实环境可能还需要考虑更多因素，但核心都是以队列的方式来解决这种瞬间高并发的业务功能。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/abe99de35b8545474ee8a4a04fc4056a.jpg\" alt=\"//img1.zyblog.com.cn/old/abe99de35b8545474ee8a4a04fc4056a.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另外，队列还有一个重要的业务场景，那就是通知、消息、邮件、短信之类的这种信息发送。因为队列的所能解决的一些问题的最大特点就是需要生产者/消费者的业务解耦。通常我们在群发消息时都会批量进行大规模的发送，这时就只需要准备好消息内容和对应的手机号、设备id，就可以让系统在后台队列中慢慢进行消息发送了，而不需要我们的前端一直等待消息全部发送完成。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这时，不少小伙伴又看出了一点点门道了。队列这货在实际应用中，就是多线程的感觉呀，JS 中的事件回调，CPU 的碎片时间轮询可不就是一种队列的真实应用嘛。还有设计模式中的“观察者模式”，本身就是事件回调这种机制的一种编程范式，所以，用它来实现的很多功能中，我们都能看到队列的影子。</p><h2>总结</h2><p>看看，一个栈，一个队列，竟然都是我们在开发过程中天天要接触的东西。是不是感觉自己的脑容量不够用了？仔细再想想，还有哪些东西和我们的栈、队列有关呢？其实只要把握住它们的两个本质就可以了：栈是后进先出（LIFO）或者说是先进后出（FILO），而队列是先进先出（FIFO）。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/3.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/source/3.3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/3.栈和队列/source/3.3栈和队列的应用.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', '', '', '2022-07-23 18:06:28', '2020-10-23 14:31:44', 1);
INSERT INTO `zy_articles_xs_test` VALUES (9, '【PHP数据结构与算法4.1】树和二叉树', '<h1>树和二叉树</h1><p>树的概念其实非常地广泛，也非常地常见，大家见到这个词千万不要惊慌，因为真的每天你都能见到树结构在我们生活中的应用。比如说公司的组织结构：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/a24d8ced4ffe3332ad8dc6981da44f13.png\" alt=\"//img1.zyblog.com.cn/old/a24d8ced4ffe3332ad8dc6981da44f13.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另外像我们家里的族谱，或者说是我们的家庭结构，也是一个典型的树结构。此外，在计算机领域，我们天天要打交道的【文件夹】、数据库中我们存储的数据，都是树的典型的应用。今天我们来学习的就是比较偏理论的关于树和二叉树的定义以及它们的一些属性特点。</p><h1>树</h1><p>从上面实际生活中的例子里，我们可以看出，树这种结构是可以归纳出它的一些特点的。</p><blockquote><p>树 （Tree）是 N (N&gt;0)个结点的有限集，它或为空树（N=0）;或为非空树 T 。</p></blockquote><p>在这个定义中，我们需要明确两个问题：一是树一定是有结点的，二是根据结点数量可以分为空树和非空树两种。不过这只是最基本的定义，它还有一些特性。</p><blockquote><p>有且仅有一个称之为根的结点。</p></blockquote><p>也就是说，这个树一定是从某一个结点开始扩展出来的，这个结点就向树根一样。从它开始向外开枝散叶。</p><blockquote><p>除根结点以外的其余结点可分为 m ( m &gt; 0 ) 个互不相交的有限集 T1，T2 ……，Tm 其中每一个集合本身又是一颗树，并且称为根的子树（SubTree）</p></blockquote><p>这一段可能会不太好理解，其实说白了就是每个结点只有一个上级结点，不能有多个上级结点。同理，平级结点之间也不能有联系，但是它可以有多个下级结点。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>关于树的定义我们可以看下下面这个图。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/61eec0a56200274ade9c8c066266a9bd.png\" alt=\"//img1.zyblog.com.cn/old/61eec0a56200274ade9c8c066266a9bd.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上图中简单的列举了标准的树和不标准的树是什么样子的。其中：</p><ul><li><p>(a) ，是只有一个根结点的树，只要有一个结点，它就可以称为一个树结构</p></li><li><p>(b) ，是一个标准的树结构</p></li><li><p>(c) ，注意它的 C 和 H 结点之间有一条连接线，这个就不是树了，结点只能有一个上级结点的才称为树，这个其实就是我们将来要学的【图】了</p></li></ul><h2>树的相关术语</h2><p>相对于栈的压（入）栈、出栈，队列的入队、出队来说，树的相关术语可就复杂的多了。不论如何，首先你得先记住这些术语，要不后面讲的东西用得那些术语只会让你更晕。不过我们一时记不住也没关系，先有个大概的印象，在后面的学习进程中遇到了再回来复习，这样印象反而会更加深刻。</p><ul><li><p>结点：一个结点可能包含一组数据，或者指向其它结点的分支，可以看作是树枝分叉的那个地方，(b)图中 A、 B、 C、 D、 E 等等这些都是结点</p></li><li><p>结点的度：结点拥有的子树数量就叫做结点的度，其实就是它的下级子结点有几个就是几度，(b)图中，C 结点的度为 1 ， D 结点的度为 3</p></li><li><p>树的度：树内各结点度的最大值，就是拥有最多子结点的度是多少，这个树的度就是多少，(b) 图这个树的度为 3</p></li><li><p>叶子：度为0的结点，也就是没有子结点的结点，(b) 图中的 K 、 L 、 F 、 G 、 M 、 I 、 J 就是这颗树的叶子结点</p></li><li><p>双亲和孩子：一个结点的子结点，就是它的孩子；对于这些子结点来说，当前这个结点就是它的双亲，(b) 图中，D 的孩子是  H 、 I 、 J ，而  H 、 I 、 J 的双亲就是 D</p></li><li><p>层次：从根结点算起，根结点就是第一层，根的孩子就是第二层，依次类推，(b) 图中 G 结点所在的层次为 3 ，(a) 图的全部层次都只有 1</p></li><li><p>树的深度（高度）：当前这颗树的最大层次，很明显，(b) 图的深度就是 4</p></li><li><p>兄弟、祖先和子孙：兄弟结点就是这些结点的双亲是同一个结点；祖先结点就是从根结点到某个指定结点路上的经过的所有结点；子孙就是从某一个节点出发，到达目标结点这一路上的所有结点。(b) 图中， E、 F 是兄弟，E 的祖先是 A 、 B ， E 的子孙为 K 或者 L</p></li><li><p>堂（表）兄弟：所有在同一层的结点但双亲不同的结点都是堂兄弟，同样还是在 (b) 图中，G 的堂（表）兄弟有  E、 F ，另外还有   H 、 I 、 J 也是它的表兄弟</p></li></ul><h2>二叉树</h2><p>对于树的概念有了一定的了解之后，我们再来进一步的学习另一个概念，同时也是在数据结构和算法中最重要的一种树的形式：二叉树。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>通常来说，树的形态是可以千变万化的，比如一个结点可以有 3 个子结点，而另一个结点可能有 300 个子结点。这样没有什么规则的树其实操作起来会非常麻烦，而二叉树的定义就要简单的多，除了有树的性质外，它还多了一项内容：二叉树的每个结点最多只有两个子结点，也就是说，整个二叉树的度肯定是 2 ，所有结点的度也不会超过 2 。关于二叉树为什么好操作这点，我们在下一小节的二叉树的性质中再详细地说明。所有的树结构都是可以通过一定的规则变形来转换成二叉树的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们同样还是通过一张图示来展示什么是二叉树。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/96738de7df2db7ba6df60ddb125a108f.png\" alt=\"//img1.zyblog.com.cn/old/96738de7df2db7ba6df60ddb125a108f.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>二叉树中，左边的子结点及其子孙结点可以看成是关于当前结点的左子树。右边结点及其子孙结点也一样可以看成是当前结点的右子树。根据结点的子结点情况，就有了上面图中的这几种二叉树形态。</p><ul><li><p>(a) 树是仅有一个结点的树，也可以说是仅有一个结点的二叉树</p></li><li><p>(b) 树是仅有一个左结点的二叉树</p></li><li><p>(c) 树是仅有一个右结点的二叉树</p></li><li><p>(d) 树是拥有左右两个结点的二叉树</p></li></ul><h2>二叉树的性质</h2><blockquote><p>性质1：在二叉树的第 i 层上至多有 2i-1 个结点（ i &gt;= 1 ）</p></blockquote><blockquote><p>性质2：深度为 k 的二叉树至多有 2k - 1 个结点（ k &gt;= 1）</p></blockquote><blockquote><p>性质3：对任何一颗二叉树 T ，如果其终端结点数为 n0 ，度为2的结点数为 n2 ，则 n0 = n2 + 1</p></blockquote><blockquote><p>性质4：具有 n 个结点 的完全二叉树的深度为 log2n + 1</p></blockquote><blockquote><p>性质5：如果对一颗有 n 个结点 的完全二叉树（其深度为 log2n + 1 ）的结点按层序编号（从第1层到第 log2n + 1 层，每层从左到右），则对任一结点 i （ 1 &lt;= i &lt;= n），有：</p></blockquote><ol><li><p>如果 i = 1 ，则结点 i 是二叉树的根，无双亲；如果 i &gt; 1 ，则其双亲是结点 i / 2</p></li><li><p>如果 2i &gt; n ，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i</p></li><li><p>如果 2i + 1 &gt; n ，则结点 i 无右孩子；否则其右孩子是结点 2i + 1</p></li></ol><p>关于二叉树的上述五个性质的数学证明我们就不详细说了，毕竟我们这一系列的文章的宗旨也是希望通过简单的示例让大家学习到数据结构和算法的精髓，而不是简单粗暴的直接用数学公式来推导证明，那么我们就直接来图上数一数就好了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/7b8e51bc1191ea8e45c6fff94c4e3580.png\" alt=\"//img1.zyblog.com.cn/old/7b8e51bc1191ea8e45c6fff94c4e3580.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><ul><li><p>对于 性质1 来说，我们当前这个二叉树根据公式的话，在第 3 层上最多只能有 23-1 个结点，也就是 4 个结点。第 4 层上最多只能有 24-1 ，也就是 23 = 8 个结点</p></li><li><p>对于 性质2 来说，当前这图中的树的深度为 4 ，也就是最多有 24 - 1 = 15 个结点</p></li><li><p>性质3 的话，我们先数数度为 2 的结点有多少，在这个图中，度为 2 的结点有 7 个，也就是 A 、 B 、 C 、 D 、 E 、 F 、 G ，第 4 层的结点都是没有子结点的，也就是说它们都是 0 度的，也称为终端结点（叶子结点），这些结点的数量一共是 8 个。现在 n2 = 7 ，根据性质公式就可以得出 n0 = n2 + 1 = 7 + 1 = 8</p></li><li><p>图中的结点数量为 15 个，套用 性质4 的公式可以得出 log2n + 1 = log215 + 1 = 3.91（向下取整） + 1 = 3 + 1 = 4 ，当前树的深度即为 4 ，性质4 和 性质2 可以看作是互补的</p></li><li><p>对于 性质5 来说，请注意每个结点边上的编号，我们就选取 E 结点来作为例子说明。E 结点当前为 5 ，所以它的双亲为 5 / 2 = 2 （向下取整）；E 的左孩子为 2i ，也就是 2*5=10 ，E 的右孩子为 2i + 1 ，也就是 2*5+1 = 11；性质5 的定义中说得更抽象一些，而且是拿叶子结点来做说明的，针对的是整个二叉树的情况，但其实意思和我们这里解释的是一样的，大家可以再拿其它结点验证一下。性质5 对于后面我们要讲的使用顺序结构来存储二叉树非常重要！</p></li></ul><p>请务必掌握并记牢二叉树的这五个性质及其含义，因为在后面的学习中，不管是二叉树的顺序、链式存储结构，还是二叉树的遍历，都有可能会接触到上面的五个性质中的内容。可以说，它们就是二叉树学习中最最基础的灵魂。</p><h2>森林</h2><p>最后，我们来简单的了解下什么是“森林”。多个树放在一起，就形成了一片“森林”。就像上文中二叉树的解释图一样，(a)(b)(c)(d)放在一起将它们整体一起来看，就是一片“森林”，在这片“森林”中分别有着(a)(b)(c)(d)这四颗树。森林中的树和树之间是没有联系的，如果我们要操作或者遍历一个森林的话，往往是将这片森林转化为一颗树。具体的算法和步骤不是我们学习的重点，所以大家了解一下即可，有想深入研究的同学可以搜索相关的内容或者查阅相关的教材。</p><h2>总结</h2><p>从栈和队列前进到树后，是不是突然感觉到一下子就迈了一大步？有点搞不懂了？没关系，今天的内容其实都是一些基础的理论内容，能理解的就理解，不能理解的就接着继续学习之后再返过来看今天的这些概念。学习就不不断地重复进步地过程，当然一切都还是要以地基为基础的。当你了解了树的数据结构及一些简单的遍历算法之后，再回来深入的理解这些概念并把他们背下来，相信一般的面试中关于树相关的题目就不在话下了，一起努力吧！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2020-04-27 23:19:18', 1);
INSERT INTO `zy_articles_xs_test` VALUES (10, '【PHP数据结构与算法4.2】二叉树的遍历及逻辑操作', '<h1>二叉树的遍历及逻辑操作</h1><p>上篇文章我们讲了许多理论方面的知识，虽说很枯燥，但那些都是我们今天学习的前提，一会看代码的时候你就会发现这些理论知识是多么地重要了。首先，我们还是要说明一下，我们学习的主要内容是二叉树，因为二叉树是最典型的一种树的应用，不管是考试还是面试，它都是必知必学的内容。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>首先，在学习树的操作之前，我们先要明白在树的操作中，最核心的就是“遍历”。为什么这么说呢？不同于栈和队列，树结构其实已经不是一维的了，它有分支，有不同的角度，更重要的是它有了层级的概念。一维空间的东西就是我们常见的“线”，它只有长度，没有高度，而这个长度就是它唯一的维度，栈和队列很明显都是一维的。而树就不同了，因为层级的概念，所以它有了“高度”，也就是说，它升级到了二维的概念。就像上一篇文章中介绍的那一堆名词中，就有“树的高度（深度）”的概念。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>能够遍历一颗树之后，我们就可以在遍历的基础上对这颗树的结点进行增、删、改等操作，这些基本的逻辑操作全都是建立在遍历的基础之上的，仔细回想一下栈和队列，其实它们的这些逻辑操作不也是从遍历入手吗？不管是出栈入栈还是出队入队，我们都是建立在一种固定的遍历规则之下的（FILO、FIFO）。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>对于二维的事物，如何遍历它就是一个重点的内容。一维的数据结构我们只要顺序地去遍历就可以了，而二维的数据结果则不能简单的按顺序一个一个地去遍历了，因为结点之间有层次关系的存在，所以我们要考虑当前的结点如果没有子结点了，我们的遍历操作应该怎么办呢？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/038d4f6326c96848e29f6268a01ca1f0.png\" alt=\"//img1.zyblog.com.cn/old/038d4f6326c96848e29f6268a01ca1f0.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>幸好，我们是站在巨人的肩膀上来学习这些知识。许多的前辈已经为我们总结出来了一些非常简单的对于树的遍历方法，有多简单呢？先卖个关子，我们先来看看如何建立一颗树，也就是我们在上篇文章中展示过的那颗二叉树。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/e76445f1e948eee079c4f5afb8a0f39d.png\" alt=\"//img1.zyblog.com.cn/old/e76445f1e948eee079c4f5afb8a0f39d.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><h2>二叉树的链式存储结构</h2><p>使用链式存储二叉树非常简单，而且也很形象，小伙伴们先收起对顺序存储二叉树的疑问，因为在下一篇文章中我们就会讲解在什么情况下使用顺序存储。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class BiTree\n{\n    public $data;\n    public $lChild;\n    public $rChild;\n}</code></pre></div><p>其实，在链式存储中，我们就是使用一个个地结点来保存这颗树。每个二叉树结点都有一个数据域，也就是 data 属性。另外两个属性就可以看做是两个分叉的指针，分别是这个结点的左孩子结点 lChild 和右孩子结点 rChild 。对比栈和队列来说，我们只是将 next 结点换成了左、右两个孩子结点而已，本质上其实与栈和队列并没有太大的差别。说白了，从数据结构上来看，我们还是用一维的存储来表示二维的概念，而这个概念的转变则是我们需要从对概念理解的角度出发的。</p><h2>二叉树建树</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 建立二叉树\nfunction CreateBiTree($arr, $i)\n{\n    if (!isset($arr[$i])) {\n        return null;\n    }\n    $t = new BiTree();\n    $t-&gt;data = $arr[$i];\n    $t-&gt;lChild = CreateBiTree($arr, $i * 2);\n    $t-&gt;rChild = CreateBiTree($arr, $i * 2 + 1);\n    return $t;\n}</code></pre></div><p>就这么一个简单的方法，我们就可以完成一个链式二叉树的建立。小伙伴们请仔细看好了，这一个简单的建树操作其实内含不少玄机：</p><ul><li><p>我们使用一个数组来依次表示树的各个结点，比如依次输入 A 、 B 、 C 、 D 、 E …… （树的顺序存储中我们会再次看到它们的身影）</p></li><li><p>赋值的内容是当前 $i 下标的数据，注意我们在给左、右孩子赋值时进行了递归操作</p></li><li><p>在学习栈的时候，我们学习过“递归”就是一种栈式的操作，所以，在这段代码中，我们是以栈的形式来建树的</p></li><li><p>注意到每次的 i * 2 和 i * 2 + 1 了吧？请复习二叉树的 <em>性质5</em></p></li></ul><p>最后我们测试一下这个方法是否能够成功的建立一颗链式树结构。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$treeList = [\'\', \'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\', \'H\', \'I\', \'J\', \'K\', \'L\', \'M\', \'N\', \'O\'];\n\n$tree = CreateBiTree($treeList, 1);\nprint_r($tree);\n\n// BiTree Object\n// (\n//     [data] =&gt; A\n//     [lChild] =&gt; BiTree Object\n//         (\n//             [data] =&gt; B\n//             [lChild] =&gt; BiTree Object\n//                 (\n//                     [data] =&gt; D\n//                     [lChild] =&gt; BiTree Object\n//                         (\n//                             [data] =&gt; H\n//                             [lChild] =&gt;\n//                             [rChild] =&gt;\n//                         )\n\n//                     [rChild] =&gt; BiTree Object\n//                         (\n//                             [data] =&gt; I\n//                             [lChild] =&gt;\n//                             [rChild] =&gt;\n//                         )\n\n//                 )\n\n//             [rChild] =&gt; BiTree Object\n//                 (\n//                     [data] =&gt; E\n//                     [lChild] =&gt; BiTree Object\n//                         (\n//                             [data] =&gt; J\n//                             [lChild] =&gt;\n//                             [rChild] =&gt;\n//                         )\n\n//                     [rChild] =&gt; BiTree Object\n//                         (\n//                             [data] =&gt; K\n//                             [lChild] =&gt;\n//                             [rChild] =&gt;\n//                         )\n\n//                 )\n\n//         )\n\n//     [rChild] =&gt; BiTree Object\n//         (\n//             [data] =&gt; C\n//             [lChild] =&gt; BiTree Object\n//                 (\n//                     [data] =&gt; F\n//                     [lChild] =&gt; BiTree Object\n//                         (\n//                             [data] =&gt; L\n//                             [lChild] =&gt;\n//                             [rChild] =&gt;\n//                         )\n\n//                     [rChild] =&gt; BiTree Object\n//                         (\n//                             [data] =&gt; M\n//                             [lChild] =&gt;\n//                             [rChild] =&gt;\n//                         )\n\n//                 )\n\n//             [rChild] =&gt; BiTree Object\n//                 (\n//                     [data] =&gt; G\n//                     [lChild] =&gt; BiTree Object\n//                         (\n//                             [data] =&gt; N\n//                             [lChild] =&gt;\n//                             [rChild] =&gt;\n//                         )\n\n//                     [rChild] =&gt; BiTree Object\n//                         (\n//                             [data] =&gt; O\n//                             [lChild] =&gt;\n//                             [rChild] =&gt;\n//                         )\n\n//                 )\n\n//         )\n\n// )</code></pre></div><p>打印出来的内容应该非常清晰了吧？A 结点有左右两个孩子结点分别是 B 和 C ，B 结点有左右两个孩子分别是 D 和 E ，依次类推。最终的结构和我们上面那个二叉树图的结构完全一致。在这里，我们还需要注意的一点是，对于传递进来的数组，我们给第一个元素，也就是 0 下标的数据为空，并且是从第二个元素也就是 1 下标的元素开始建树的。这样也是为了能够直观方便的利用二叉树的 <em>性质5</em> 来快速地建立这颗树。</p><h2>二叉树的遍历</h2><p>说完二叉树的建树了，其实我们就已经接触到了一种二叉树的遍历形式。注意看我们建树方法中的代码，我们是先给结点的 data 赋值，然后建立这个结点的左、右孩子结点，并为它们赋值后再继续使用同样的操作一路建立完成所有的结点。现在，我们将这个操作反过来，不是建立结点，而是读取这些结点的内容，先读取结点的内容，然后再读取这个结点左右孩子结点的内容，这就是“先序遍历”。</p><h3>先序遍历</h3><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 前序遍历\n */\nfunction PreOrderTraverse(?BiTree $t)\n{\n    if ($t) {\n        echo $t-&gt;data, \',\';\n        PreOrderTraverse($t-&gt;lChild);\n        PreOrderTraverse($t-&gt;rChild);\n    }\n}\n\nPreOrderTraverse($tree);\n\n// A,B,D,H,I,E,J,K,C,F,L,M,G,N,O,\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>是不是很神奇？就连建树我们竟然也使用的是同一种遍历的方法，可以看出对于二叉树这种复杂的数据结构来说，遍历的重要作用了吧。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>大家可以看一个遍历读取出来的结点顺序，貌似和我们输入的顺序不一样呀！没错，先序遍历是通过递归，先按一个方向走到底，当这个结点没有子结点之后，通过递归栈的特性再向上弹出。<em>并且在遍历孩子结点之前先输出当前这个结点的内容</em>。注意，这一句话很重要！所以我们的顺序就是 A,B,D,H ，当 H 没有子结点之后，我们就回到父结点 D 再进入它的右子结点 I ，具体顺序可以参考下图：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/5d85f6fa6cc28100f14a1b2b8f688800.png\" alt=\"//img1.zyblog.com.cn/old/5d85f6fa6cc28100f14a1b2b8f688800.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们代码中的先序遍历和先序建树的结点顺序是完全不一样的，这一点也是要搞清楚的。建树的过程我们根据二叉树的 <em>性质5</em> 直接为它指定了数据下标。而在遍历过程中则是一个结点一个结点的去扫描遍历整颗树的。</p><h3>中序遍历</h3><p>顾名思义，中序遍历其实就是在遍历完左孩子结点之后再输出当前这个结点的内容，所以我们只需要微调先序遍历的代码即可。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 中序遍历\n */\nfunction InOrderTraverse(?BiTree $t)\n{\n    if ($t) {\n        InOrderTraverse($t-&gt;lChild);\n        echo $t-&gt;data, \',\';\n        InOrderTraverse($t-&gt;rChild);\n    }\n}\n\nInOrderTraverse($tree);\n\n// H,D,I,B,J,E,K,A,L,F,M,C,N,G,O,</code></pre></div><p>中序遍历的步骤就是我们会直接先走到最左边的子结点，当遇到最后一个结点时，输出内容，也就是图中的 H 结点，接着回到它的父结点 D 结点，这时根据中序的原理输出 D ，再进入它的右孩子结点并输出 I 。D 结点的子树及它本身遍历完成后，返回 D 结点的上级结点 B 结点，输出 B ，然后进入 B 结点的右孩子结点 E 。再次进入到 E 的最左孩子结点 J ，然后参考 D 结点的遍历形式完成整颗树的遍历。具体顺序参考下图：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/ca09d84708983501911ff3db11ba2200.png\" alt=\"//img1.zyblog.com.cn/old/ca09d84708983501911ff3db11ba2200.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><h3>后序遍历</h3><p>在学习了先序和中序之后，从名字就可以看出来后序就是在遍历完一个结点的左右孩子之后最后输出这个结点的内容，代码当然也是简单地微调一下就可以了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 后序遍历\n */\nfunction PostOrderTraverse(?BiTree $t)\n{\n    if ($t) {\n        PostOrderTraverse($t-&gt;lChild);\n        PostOrderTraverse($t-&gt;rChild);\n        echo $t-&gt;data, \',\';\n    }\n}\n\nPostOrderTraverse($tree);\n\n// H,I,D,J,K,E,B,L,M,F,N,O,G,C,A,</code></pre></div><p>具体原理就不详细说明了，相信在学习了先序和中序之后，你一定能马上想明白后序遍历到底是什么意思了。直接上图：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/9007212eaa6c4bfd9e290f51a656d150.png\" alt=\"//img1.zyblog.com.cn/old/9007212eaa6c4bfd9e290f51a656d150.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><h3>层序遍历</h3><p>最后，我们要讲的就是层序遍历。既然有“层”这个关键字了，相信大家马上就能联想到，是不是一层一层地去遍历啊！没错，层序遍历就是这个意思，我们按照树的层次，一层一层地输出相应的结点信息。需要注意的，在这里我们会用到队列，而不是栈了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 层序遍历\n */\n$q = InitLinkQueue();\nfunction LevelOrderTraverse(?BiTree $t)\n{\n    global $q;\n    if (!$t) {\n        return;\n    }\n\n    EnLinkQueue($q, $t);\n    $node = $q;\n    while ($node) {\n        $node = DeLinkQueue($q);\n        if ($node-&gt;lChild) {\n            EnLinkQueue($q, $node-&gt;lChild);\n        }\n        if ($node-&gt;rChild) {\n            EnLinkQueue($q, $node-&gt;rChild);\n        }\n        echo $node-&gt;data, \',\';\n    }\n}\n\nLevelOrderTraverse($tree);\n\n// A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,</code></pre></div><p>InitLinkQueue() EnLinkQueue() 、 EnLinkQueue() 这些都是我们之前学习队列的时候所写的对于队列的逻辑操作方法。是不是很开心呀，之前的知识又用上了。层序遍历的核心思想就是运用队列的概念，遇到一个结点，就把这个结点入队，然后判断它是否有子结点，然后相继把子结点入队。每遍历一个结点，就把队首的结点出队，这样就完成了按树的层次遍历的能力。文字说明还是太抽象，我们还是通过图片来展示这一过程：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/ae9e186ffab84bdea19e05a2a63e72d7.png\" alt=\"//img1.zyblog.com.cn/old/ae9e186ffab84bdea19e05a2a63e72d7.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>大家有没有发现，层序遍历的输出结果就和我们建树时的数组顺序完全相同了。很好玩吧，所以说代码的世界总是有无穷的乐趣等着我们去发现哦！</p><h2>总结</h2><p>今天的内容有没有懵圈？如果懵圈了就多找资料好好研究一下，先序、中序、后序都是利用栈来进行树的结点遍历的，而层序遍历则是利用了队列。一环套一环呀，前面学习的内容都派上用场了吧！不过这只是个开始，在学习图的时候，我们会在深度遍历和广度遍历中再次看到栈和队列的身影，它们可都是亲戚哦。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这四种遍历方式在考试和面试中也是经常出现的，不管是它们的原理还是画图或者是根据图形来写出各种遍历的顺序，都是非常常见的考核内容，所以大家在这篇文章入门的基础上还是要更加深入的去根据一些教材来深入的理解这几种遍历，熟练的掌握它们。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/4.%E6%A0%91/source/4.2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%8F%8A%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/4.树/source/4.2二叉树的遍历及逻辑操作.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2020-12-31 08:15:28', 1);
INSERT INTO `zy_articles_xs_test` VALUES (11, '【PHP数据结构与算法4.3】完全二叉树、线索二叉树及树的顺序存储结构', '<h1>完全二叉树、线索二叉树及树的顺序存储结构</h1><p>在上篇文章中，我们学习了二叉树的基本链式结构以及建树和遍历相关的操作。今天我们学习的则是一些二叉树相关的概念以及二叉树的一种变形形式。</p><h2>完全二叉树</h2><p>什么叫完全二叉树呢？在说到完全二叉树之前，我们先说另外一个名词：“满二叉树”。像我们之前文章中演示过的那个二叉树，就是一颗“满二叉树”。在这颗树中，所有的结点都有两个孩子结点，没有哪个结点是只有一个孩子结点的，并且所有最底层的叶子结点都在同一层，这种树就称为“满二叉树”，也称为“完美二叉树”。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/ceba0945a6edbf583c95d727e2f30bcf.png\" alt=\"//img1.zyblog.com.cn/old/ceba0945a6edbf583c95d727e2f30bcf.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>是不是非常漂亮的一颗树？没错，这种二叉树非常地完美，它没有多余的结点，也没有缺少的结点，非常的漂亮。但是，在现实中，完美的东西是很稀少的，人生总会有一点缺憾嘛。我们尽量不要让自己有太多的缺憾，但也总不能过上没有一丝缺憾的人生。所以，我们允许叶结点出现在最下层和次下层，而且最下层的叶结点集中在树的左部，也就是叶结点只能有左子树，那么，这样的一颗略带缺憾的树就叫做“完全二叉树”。不要担心它不完美，因为这样略带缺憾的人生才是完整的嘛，所以“完全二叉树”是一种理想的树结构。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/b866abb51a21ddd265da4d6f30869dc9.png\" alt=\"//img1.zyblog.com.cn/old/b866abb51a21ddd265da4d6f30869dc9.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从定义中，我们可以看出，一颗“满二叉树”，必定是一颗“完全二叉树”，而一颗叶子结点都在一层的并且所有结点都有左右孩子结点的“完全二叉树”也就是一颗”满二叉树“。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>为什么要讲”满二叉树“和”完全二叉树“呢？当然是为了我们接下来的内容做铺垫。因为”满二叉树“是最符合二叉树性质的一颗树。还记得树系列的第一篇文章中介绍过的二叉树的那五个性质吗？当时我们就是以那颗”满二叉树“为例进行讲解的。而其中的 性质5 ，就是我们学习使用顺序结构存储二叉树的基础。</p><h2>二叉树的顺序存储</h2><p>通过”满二叉树“的概念，以及二叉树的 性质5 我们就可以实现使用一个数组来存储顺序结构的实现。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$treeList = [\'\', \'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\', \'H\', \'I\', \'J\', \'K\', \'L\', \'M\', \'N\', \'O\'];</code></pre></div><p>相信大家不陌生吧，在上篇文章中，我们就是通过这个数组来建立链树的，而这个数组其实就是一个线性存储的二叉树。我们通过对比二叉树的 性质5 来看一下。</p><ul><li><p>A 结点的下标是 1 ，它是我们的树根。它的子结点是 B 和 C ，对应的下标分别是 2 和 3 ，也就是 1 * 2 和 1 * 2 + 1 。</p></li><li><p>同理，我们再选取一个结点 F 。它的下标是 6 ，所以它的左孩子结点的下标是 6 * 2 = 12 ，对应的是 L ；它的右孩子结点是 6 * 2 + 1 = 13 ，对应的是 M 。</p></li><li><p>反过来看，一个结点的父结点就是 i / 2 。我们看下 K 结点的下标是 11 ，它的父结点就是 11 / 2 ，舍去小数点是下标 5 的位置，也就是结点 E ；结点 J 的下标是 10 ，它的父结点是 10 / 2 ，也是下标为 5 的 E 结点。</p></li></ul><p>这下想以大家就明白了用数组是如何表示一颗二叉树结构了吧。而且数组这种结构更加的一维，更能体现出对于树的操作就是二维化一维的一种表示，也就是非线性转线性，这样才能让我们方便地操作这些数据。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>针对顺序存储结构，也就是数组元素的遍历，也是可以使用先序、中序、后序以及层序的形式。不过这些遍历方法都需要根据二叉树的 性质5 来进行遍历。但更重要的是，只要给我一个下标，我们通过二叉树的性质，就可能很容易地知道它的下级结点和上级结点的位置，能够快速地获得这些结点的信息。这一大特点是链式结构的二叉树所没有的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>如果我们要存储的不是一颗”满二叉树“呢？甚至它都不是一颗完全二叉树的情况下，只需要将对应的结点设置为空值就行了。比如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$treeList = [\'\', \'A\', \'B\', \'C\', \'D\', \'E\', \'I\', \'\', \'\', \'\', \'\', \'H\', \'\', \'J\', \'\', \'\'];</code></pre></div><p>这颗树的结构所对应的二叉树图形就是这样的：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/23e5d5f37d76df496974ee4bb2cedc61.png\" alt=\"//img1.zyblog.com.cn/old/23e5d5f37d76df496974ee4bb2cedc61.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>然后在建链树的方法中，我们只需要再增加一个判断就可以了。我们就可以通过这样一个顺序存储的二叉树快速地生成一颗链式存储的二叉树，方便我们之后的操作。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 建立二叉树\nfunction CreateBiTree($arr, $i)\n{\n    if (!isset($arr[$i]) || !$arr[$i]) { // 这里增加了个判断，如果数组元素为空\n        return null;\n    }\n    $t = new TBTNode();\n    $t-&gt;data = $arr[$i];\n    $t-&gt;lChild = CreateBiTree($arr, $i * 2);\n    $t-&gt;rChild = CreateBiTree($arr, $i * 2 + 1);\n    return $t;\n}</code></pre></div><h2>线索二叉树</h2><p>一环套一环，接下来我们再来讲讲”线索二叉树“。这又是个什么东西呢？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从上面的学习中，我们知道了”满二叉树“和”完全二叉树“。但是这种结构都是非常理想的树结构，不过真实的情况可能大部分都是”理想很丰满，现实很骨感“。很多树并不能形成那样的完全二叉树的形式，更别提”满二叉树“了。而树的遍历又经常会使用栈或者队列来实现，这两种遍历方式基本都是线性的，也就是最好情况下也是 O(n) 的时间复杂度。那么，有没有什么更快一点的方式来提高遍历的效率呢？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们这样来尝试一下：</p><ul><li><p>如果树的叶子结点的左孩子结点为空，就让它指向前驱（上级）结点</p></li><li><p>如果树的叶子结点的右孩子结点为空，就让它指向后继结点</p></li></ul><p>这样有什么好处呢？我们可以避免掉大范围的递归操作，从而加快树的遍历速度。在整个算法中，它并没有什么优势，因为我们需要将一颗树进行线索化，也就是去改变它的叶子结点的左右孩子的指向，这也是一次遍历。但是，如果你的操作是经常需要遍历，而且是来回的多次遍历，那么它的整体性能是要强于普通二叉树的遍历的。因为在一次线索化之后，它的遍历就是在快速的查找叶子结点的基础上进行普通的线性遍历操作，而不是递归操作。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>对于线索二叉树来说，我们需要改变树的结点存储数据结构。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 线索二叉树结点\nclass TBTNode\n{\n    public $data;\n    public $lTag = 0;\n    public $rTag = 0;\n    public $lChild;\n    public $rChild;\n}</code></pre></div><p>我们增加了两个标志位，当 $lTag 或 $rTag 为 1 时，$lChild 或 $rChild 分别指向前驱或后继结点。这样在最后的遍历时，我们就可以快速地通过这个 tag 标志位分辨出结点的指向状态。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>然后我们先简单地建立一颗树。使用上一节中的那个示例。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 建立二叉树\nfunction CreateBiTree($arr, $i)\n{\n    if (!isset($arr[$i]) || !$arr[$i]) { // 这里增加了个判断，如果数组元素为空\n        return null;\n    }\n    $t = new TBTNode();\n    $t-&gt;data = $arr[$i];\n    $t-&gt;lChild = CreateBiTree($arr, $i * 2);\n    $t-&gt;rChild = CreateBiTree($arr, $i * 2 + 1);\n    return $t;\n}\n\n$treeList = [\'\', \'A\', \'B\', \'C\', \'D\', \'E\', \'I\', \'\', \'\', \'\', \'\', \'H\', \'\', \'J\', \'\', \'\'];\n\n$tree = CreateBiTree($treeList, 1);</code></pre></div><p>接下来就是最重要的线索化过程，我们可以建立前序、中序、后序的线索二叉树。对应的，在最后的线索二叉树遍历时获得的结果也将是这三种遍历方式所对应的结果。在这里，我们学习最普遍的也是最经典的”中序线索二叉树“。所以，我们以中序遍历的形式将这颗树线索化。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 线索化\nfunction InThread(?TBTNode $p, ?TBTNode &amp;$pre)\n{\n    if ($p) {\n        // 递归，左子树线索化\n        InThread($p-&gt;lChild, $pre);\n\n        if (!$p-&gt;lChild) {\n            // 建立当前结点的前驱线索\n            $p-&gt;lChild = $pre;\n            $p-&gt;lTag = 1;\n        }\n        if ($pre &amp;&amp; !$pre-&gt;rChild) {\n            // 建立当前结点的后继线索\n            $pre-&gt;rChild = $p;\n            $pre-&gt;rTag = 1;\n        }\n        $pre = $p; // $pre 指向当前的 $p ，作为 $p 将要指向的下一个结点的前驱结点指示指针\n        $p = $p-&gt;rChild; // $p 指向一个新结点，此时 $pre 和 $p 分别指向的结点形成了一个前驱后继对，为下一次线索化做准备\n        \n        // 递归，右子树线索化\n        InThread($p, $pre);\n    }\n}\n\n// 创建线索二叉树\nfunction createInThread(TBTNode $root)\n{\n    $pre = null; // 前驱结点指针\n    if($root){\n        InThread($root, $pre);\n        $pre-&gt;rChild = null; // 非空二叉树，线索化\n        $pre-&gt;rTag = 1; // 后处理中序最后一个结点\n    }\n}\n\ncreateInThread($tree);\n\nvar_dump($tree);\n// object(TBTNode)#1 (5) {\n//     [\"data\"]=&gt;\n//     string(1) \"A\"\n//     [\"lTag\"]=&gt;\n//     int(0)\n//     [\"rTag\"]=&gt;\n//     int(0)\n//     [\"lChild\"]=&gt;\n//     object(TBTNode)#2 (5) {\n//       [\"data\"]=&gt;\n//       string(1) \"B\"\n//       [\"lTag\"]=&gt;\n//       int(0)\n//       [\"rTag\"]=&gt;\n//       int(0)\n//       [\"lChild\"]=&gt;\n//       object(TBTNode)#3 (5) {\n//         [\"data\"]=&gt;\n//         string(1) \"D\"\n//         [\"lTag\"]=&gt;\n//         int(1)\n//         [\"rTag\"]=&gt;\n//         int(1)\n//         [\"lChild\"]=&gt;\n//         NULL\n//         [\"rChild\"]=&gt;\n//         *RECURSION*\n//       }\n//       ……</code></pre></div><p>关于算法的具体步骤在注释中已经写得很详细了。一句话总结就是在中序遍历的过程中，根据结点的信息来确定它的左右孩子的形式，如果有左右孩子就继续，如果没有任一一个孩子的话，就将左右结点指向前驱或者后继。建立之后的线索二叉树就如图所示：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/85993d1a3242e0cce1918a0ad4bfb1c7.png\" alt=\"//img1.zyblog.com.cn/old/85993d1a3242e0cce1918a0ad4bfb1c7.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>最后就是遍历了。我们需要的是能够快速地获得最左叶子结点的信息，然后就是下一跳的信息，这时，线索的威力就发挥出来了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 以 $p 为根的中序线索二叉树中，中序序列下的第一个结点，也就是最左边那个结点\nfunction First(?TBTNode $p){\n    while($p-&gt;lTag == 0){\n        $p = $p-&gt;lChild; // 最左下结点（不一定是叶子结点）\n    }\n    return $p;\n}\n\n// 在中序二叉树中，结点 $p 在中序下的后继结点\nfunction NextNode(?TBTNode $p){\n    if($p-&gt;rTag == 0){\n        return First($p-&gt;rChild);\n    }else{\n        return $p-&gt;rChild; // 如果 rTag == 1 ，直接返回后继线索\n    }\n}\n\n// 在中序线索二叉树上进行中序遍历\nfunction Inorder(TBTNode $root){\n    //     第一个结点      结点不为空    下一个结点\n    for($p = First($root);$p;$p=NextNode($p)){\n        echo $p-&gt;data, \',\';\n    }\n}\n\nInorder($tree); // D,B,E,H,A,I,J,C, </code></pre></div><p>当遇到 $lTag 不为 0 的结点时，这个结点就是最左的那个结点了，如果这个不为空的话，【输出】它。接着我们获得下一跳的结点，也就是判断这个结点的右孩子 $rTag 标志，如果是为 0 的，也就是它还有右孩子，【输出】后向下查找，直到找到一个 $rTag 也为 1 的结点，直接返回这个结点的后继，也就是中序遍历的中间那个结点，【输出】它。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>最后输出的顺序是不是和我们中序遍历的结果一样呢？注意看代码，在遍历中序线索二叉树的时候，我们没有用一个递归吧，全部是使用的 while() 和 for() 就完成了对这个线索二叉树的遍历。</p><h2>总结</h2><p>坚持到现在不容易，不能再小看数据结构了吧？现在还只是树，我们的图都还没开始呢！当然，也不要害怕，一步一步的学，慢慢掌握，不要幻想一口气吃成个胖子。写完这篇文章我也不可能马上就手写出一个中序的线索二叉树来的。大家还是以理解原理为主，如果说真能手写的话，那也是为了面试而去背的或者是为了考研而准备的。这样的小同学在面试中我反而要更多问一些其它的问题，毕竟临时抱佛脚的准备远不如深入理解带来的感悟更能打动人！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/4.%E6%A0%91/source/4.3%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/4.树/source/4.3完全二叉树、线索二叉树及树的顺序存储结构.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2021-04-11 09:39:29', 1);
INSERT INTO `zy_articles_xs_test` VALUES (12, '【PHP数据结构与算法5.2】图的存储结构', '<h1>图的存储结构</h1><p>图的概念介绍得差不多了，大家可以消化消化再继续学习后面的内容。如果没有什么问题的话，我们就继续学习接下来的内容。当然，这还不是最麻烦的地方，因为今天我们只是介绍图的存储结构而已。</p><h2>图的顺序存储结构：邻接矩阵</h2><h3>什么是邻接矩阵</h3><p>首先还是来看看如何用顺序结构来存储图。不管是栈、队列、树，我们都可以使用一个简单的数组就可以实现这些数据结构的顺序存储能力。但是图就不一样了，从上篇文章中，我们学到过，一个结点的表示是 &lt;x, y&gt; 这种形式。如果我们把这个结点相像是一个坐标轴上的点，那么我们是不是就可以用一个二维数组来表示它呢？没错，让二维数组的第一维表示为 x 轴，第二维表示为 y 轴，这样我们就可以构建出一张图来了。没错，二维数组这种形式还有一个别名就叫做：矩阵。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在图的术语中，使用二维数组来表示的图的顺序存储结构就叫做邻接矩阵。就像下面这个表格一样。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/7ba2234f20a940705704db16e6a05a66.jpg\" alt=\"//img1.zyblog.com.cn/old/7ba2234f20a940705704db16e6a05a66.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在这个表格中，我们有横竖两个坐标，X1-4 和 Y1-4 表示这个图中一共有 4 个结点，通过它们的对应关系就可以看做是一个结点与另一个结点之间是否有边。比如说 X1 和 Y2 这一对坐标 &lt;X1, Y2&gt; ，它们的值是 1 ，这就说明 结点1 到 结点2 之间有一条边。在这里，我们使用的是无权图，也就是用 0 表示没有边，用 1 表示两个结点之间有边。同时，它还是一张无向图，所以 &lt;Y2, X1&gt; 的值也是 1 ，它的意图是从 结点2 到 结点1 之间也有一条边。如果是有向图，那么就要根据有向箭头的指向来确定这条边是否设置为 1 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上面的这个邻接矩阵对应的图是什么样子的呢？大家可以自己尝试手动画一画。画不出来也不要紧，因为我们才刚开始学嘛。其实它就是我们最开始展示的那张图的邻接矩阵。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/822d53e4c1fa1d835e77f91750191e26.jpg\" alt=\"//img1.zyblog.com.cn/old/822d53e4c1fa1d835e77f91750191e26.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>左边的图就是对应的我们上面的那个表格中的邻接矩阵。那么右边那个有向图的邻接矩阵是什么样子的呢？我们也写写试试。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/5c7c3dcb6f4dc4ada993a617a026a31b.jpg\" alt=\"//img1.zyblog.com.cn/old/5c7c3dcb6f4dc4ada993a617a026a31b.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>有意思吧？那么如果是有权图呢？其实很简单的我们将图中的 1 直接换成对应边的权值就可以了，不过有可能有的边的权值就是 0 ，所以在有权图中，我们可以定义一个非常大的数，或者定义一个非常小的负数当做 无限数 来表示这两个结点没有边。</p><h3>构造邻接矩阵</h3><p>接下来，我们就通过代码来构造这样一个邻接矩阵的存储结构。我们还是用无向图的例子来实现。因为无向图是需要反向的结点也赋值的，所以它比有向图多了一个步骤，其它的基本上都是相似的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 邻接矩阵\n$graphArr = [];\nfunction CreateGraph($Nv, &amp;$graphArr)\n{\n    $graphArr = [];\n    for ($i = 1; $i &lt;= $Nv; $i++) {\n        for ($j = 1; $j &lt;= $Nv; $j++) {\n            $graphArr[$i][$j] = 0;\n        }\n    }\n}\n\n// 邻接矩阵\nfunction BuildGraph(&amp;$graphArr)\n{\n    echo \'请输入结点数：\';\n    fscanf(STDIN, \"%d\", $Nv);\n    CreateGraph($Nv, $graphArr);\n\n    if ($graphArr) {\n        echo \'请输入边数：\';\n        fscanf(STDIN, \"%d\", $Ne);\n        if ($Ne &gt; 0) {\n            for ($i = 1; $i &lt;= $Ne; $i++) {\n                echo \'请输入边，格式为 出 入 权：\';\n                fscanf(STDIN, \"%d %d %d\", $v1, $v2, $weight);\n                $graphArr[$v1][$v2] = $weight;\n                // 如果是无向图，还需要插入逆向的边\n                $graphArr[$v2][$v1] = $weight;\n            }\n        }\n    }\n}</code></pre></div><p>在这段代码中，首先我们通过 CreateGraph() 方法来初始化一个二维矩阵。也就是根据我们输入的结点数量，实现一个 X * Y 的二维数组结构，并且定义它的所有值都是 0 ，也就是说，这个图目前还没有边。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>然后，在 BuildGraph() 方法调用完 CreateGraph() 之后，我们继续输入边的信息。先输入边的数量，我们有几条边，如果边小于等于 0 的话就不要继续创建了。其实还可以严谨一点根据 无向完全图和有向完全图 的定义来让边不能超过最大的限度。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来，我们就循环继续输入边的信息，这里我需要的输入格式是边的 出结点 、入结点 、权值。由于我们的示例是无向图，所以我们除了要为 &lt;x, y&gt; 创建边之外，也要为 &lt;y, x&gt; 创建边。代码的注释中已经说明了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>解释代码可能还是比较抽象。直接运行一下试试吧。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">BuildGraph($graphArr);\n// 请输入结点数：4\n// 请输入边数：4\n// 请输入边，格式为 出 入 权：1 2 1\n// 请输入边，格式为 出 入 权：1 3 1\n// 请输入边，格式为 出 入 权：1 4 1\n// 请输入边，格式为 出 入 权：3 4 1\n\nprint_r($graphArr);\n// Array\n// (\n//     [1] =&gt; Array\n//         (\n//             [1] =&gt; 0\n//             [2] =&gt; 1\n//             [3] =&gt; 1\n//             [4] =&gt; 1\n//         )\n\n//     [2] =&gt; Array\n//         (\n//             [1] =&gt; 1\n//             [2] =&gt; 0\n//             [3] =&gt; 0\n//             [4] =&gt; 0\n//         )\n\n//     [3] =&gt; Array\n//         (\n//             [1] =&gt; 1\n//             [2] =&gt; 0\n//             [3] =&gt; 0\n//             [4] =&gt; 1\n//         )\n\n//     [4] =&gt; Array\n//         (\n//             [1] =&gt; 1\n//             [2] =&gt; 0\n//             [3] =&gt; 1\n//             [4] =&gt; 0\n//         )\n\n// )\n//  x\n//y 0 1 1 1\n//  1 0 0 0\n//  1 0 0 1\n//  1 0 1 0</code></pre></div><p>在命令行环境中调用我们的 PHP 文件，然后根据提示的内容依次输入相关的信息。最后打印出来的数组内容是不是就和我们上面的表格中一模一样了。简简单单的一段代码，我们就实现了图的顺序存储。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>可能有的同学会一时懵圈。因为我第一眼看到的时候也是完全懵了，不过仔细的对比画出来的图和上面的表格其实马上就能想明白了。这次我们真的是进入二维的世界了。是不是感觉图瞬间就把树甩到十万八千里之外了。完全二叉树的时候，我们的思想是二维的，但结构还是一维的，而到邻接矩阵的时候，不管是思想还是代码结构，全部都进化到了二维空间，高大上真不是吹的。</p><h2>图的链式存储结构：邻接表</h2><p>说完顺序存储结构，自然不能忽视另一种形式的存储结构，那就是图的链式存储结构。其实对于图来说，链式结构非常简单和清晰，因为我们只需要知道一个结点和那些结点有边就行了。那么我们就让这个结点形成一个单链表，一路往后链接就好了，就像下图这样。（同样以上图无向图为例）</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/87510cde3dbb268587304f4dce06ecd4.jpg\" alt=\"//img1.zyblog.com.cn/old/87510cde3dbb268587304f4dce06ecd4.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从 结点1 开始，它指向一个后继是 结点2 ，然后继续向后链接 结点3 和 结点4 。这样，与 结点1 相关的边就都描述完成了。由于我们展示的依然是无向图的邻接表表示，所以 结点2 的链表结点指向了 结点 1 。也就是完成了 &lt;y, x&gt; 的反向指向。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>对于代码实现来说，我们可以将头结点，也就是正式的 1-4 结点保存在一个顺序表中。然后让每个数组元素的值为第一个结点的内容。这样，我们就可以让链表结点只保存结点名称、权重和下一个结点对象的指向信息就可以了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 头结点\nclass AdjList\n{\n    public $adjList = []; // 顶点列表\n    public $Nv = 0; // 结点数\n    public $Ne = 0; // 边数\n}\n// 边结点\nclass ArcNode\n{\n    public $adjVex = 0; // 结点\n    public $nextArc = null; // 链接指向\n    public $weight = 0; // 权重\n}</code></pre></div><p><img src=\"//img1.zyblog.com.cn/old/fe5820e9f2cd252850cfca7d3ed57340.jpg\" alt=\"//img1.zyblog.com.cn/old/fe5820e9f2cd252850cfca7d3ed57340.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来，我们来看看如何使用邻接表这种结构来建立图。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function BuildLinkGraph()\n{\n    fscanf(STDIN, \"请输入 结点数 边数：%d %d\", $Nv, $Ne);\n    if ($Nv &gt; 1) {\n        // 初始化头结点\n        $adj = new AdjList();\n        $adj-&gt;Nv = $Nv; // 保存下来方便使用\n        $adj-&gt;Ne = $Ne; // 保存下来方便使用\n        // 头结点列表\n        for ($i = 1; $i &lt;= $Nv; $i++) {\n            $adj-&gt;adjList[$i] = null; // 全部置为 NULL ，一个无边空图\n        }\n        \n        if ($Ne &gt; 0) {\n//\n            for ($i = 1; $i &lt;= $Ne; $i++) {\n                echo \'请输入边，格式为 出 入 权：\';\n                fscanf(STDIN, \"%d %d %d\", $v1, $v2, $weight);\n                // 建立一个结点\n                $p1 = new ArcNode;\n                $p1-&gt;adjVex = $v2; // 结点名称为 入结点\n                $p1-&gt;nextArc = $adj-&gt;adjList[$v1]; // 下一跳指向 出结点 的头结点\n                $p1-&gt;weight = $weight; // 设置权重\n                $adj-&gt;adjList[$v1] = $p1; // 让头结点的值等于当前新创建的这个结点\n\n                // 无向图需要下面的操作，也就是反向的链表也要建立\n                $p2 = new ArcNode;\n\n                // 注意下面两行与上面代码的区别\n                $p2-&gt;adjVex = $v1; // 这里是入结点\n                $p2-&gt;nextArc = $adj-&gt;adjList[$v2]; // 这里是出结点\n                \n                $p2-&gt;weight = $weight;\n                $adj-&gt;adjList[$v2] = $p2;\n            }\n\n            return $adj;\n        }\n\n    }\n\n    return null;\n}</code></pre></div><p>代码中的注释已经写得很清楚了。可以看出，在邻接表的操作中，无向图也是一样的比有向图多一步操作的，如果只是建立有向图的话，可以不需要 p2 结点的操作。特别需要注意的就是，在这段代码中，我们使用的是链表操作中的 头插法 。也就是最后一条数据会插入到 头结点 上，而最早的那个边会在链表的最后。大家看一下最后建立完成的数据结构的输出就明白了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">print_r(BuildLinkGraph());\n// AdjList Object\n// (\n//     [adjList] =&gt; Array\n//         (\n//             [1] =&gt; ArcNode Object\n//                 (\n//                     [adjVex] =&gt; 4\n//                     [nextArc] =&gt; ArcNode Object\n//                         (\n//                             [adjVex] =&gt; 3\n//                             [nextArc] =&gt; ArcNode Object\n//                                 (\n//                                     [adjVex] =&gt; 2\n//                                     [nextArc] =&gt; \n//                                     [weight] =&gt; 1\n//                                 )\n\n//                             [weight] =&gt; 1\n//                         )\n\n//                     [weight] =&gt; 1\n//                 )\n\n//             [2] =&gt; ArcNode Object\n//                 (\n//                     [adjVex] =&gt; 1\n//                     [nextArc] =&gt; \n//                     [weight] =&gt; 1\n//                 )\n\n//             [3] =&gt; ArcNode Object\n//                 (\n//                     [adjVex] =&gt; 4\n//                     [nextArc] =&gt; ArcNode Object\n//                         (\n//                             [adjVex] =&gt; 1\n//                             [nextArc] =&gt; \n//                             [weight] =&gt; 1\n//                         )\n\n//                     [weight] =&gt; 1\n//                 )\n\n//             [4] =&gt; ArcNode Object\n//                 (\n//                     [adjVex] =&gt; 3\n//                     [nextArc] =&gt; ArcNode Object\n//                         (\n//                             [adjVex] =&gt; 1\n//                             [nextArc] =&gt; \n//                             [weight] =&gt; 1\n//                         )\n\n//                     [weight] =&gt; 1\n//                 )\n\n//         )\n\n//     [Nv] =&gt; 4\n//     [Ne] =&gt; 4\n// )</code></pre></div><p>使用邻接表来建立的图的链式存储结构是不是反而比邻接矩阵更加的清晰明了一些。就像树的链式和顺序结构一样，在图中它们的优缺点也是类似的。邻接矩阵占用的物理空间更多，因为它需要两层一样多元素的数组，就像上面的表格一样，需要占据 4 * 4 的物理格子。而邻接表我们可以直接数它的结点数，只需要 12 个格子就完成了。而且，更主要的是，链式的邻接表可以随时扩展边结点和边数，不需要重新地初始化，我们只需要简单地修改上面的测试代码就能够实现，而邻接矩阵如果要修改结点数的话，就得要重新初始化整个二维数组了。</p><h2>总结</h2><p>对于图来说，除了邻接矩阵和邻接表之外，还有其它的一些存储形式，不过都是链式的邻接表的一些优化和变形而已。大家有兴趣的可以自己去了解一下 十字链表 、邻接多重表 这两种存储结构。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>好了，基础的存储结构已经铺垫完了，关于图的概念也都熟悉掌握了，接下来，我们就要准备去做最重要的操作了，那就是如何来对图进行遍历。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/5.%E5%9B%BE/source/5.2%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/5.图/source/5.2图的存储结构.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2021-02-13 02:33:35', 1);
INSERT INTO `zy_articles_xs_test` VALUES (13, '【PHP数据结构与算法5.3】图的遍历：深度优先与广度优先', '<h1>图的遍历：深度优先与广度优先</h1><p>在上一篇文章中，我们学习完了图的相关的存储结构，也就是 邻接矩阵 和 邻接表 。它们分别就代表了最典型的 顺序存储 和 链式存储 两种类型。既然数据结构有了，那么我们接下来当然就是学习对这些数据结构的操作啦，也就是算法的部分。不管是图还是树，遍历都是很重要的部分，今天我们就先来学习最基础的两种图的遍历方式。</p><h2>树的遍历演化到图的遍历</h2><p>还记得在树的学习中，我们讲到过先序、中序、后序以及层序遍历这几种遍历形式吗？其实先序、中序和后序可以看作是一种遍历方式，它们都是使用栈结构来进行遍历，特点就是先一条路走到黑，然后再返回来走没有过的路。而层序遍历则是使用队列一层一层地进行遍历，特点就是先遍历完子结点，然后再挨个遍历每个子结点的下一层结点。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>复习完了树的遍历方式再学习图的遍历方式就会非常简单了，因为在图的遍历中，最基础的也是基于栈和队列的两种遍历形式。只不过它们的名字略有不同，基于栈的遍历方式叫作 <em>深度优先遍历</em> ，而基于队列的遍历方式叫作 <em>广度优先遍历</em> 。其实也就是对应着树中的先、中、后序遍历和层序遍历，本质上没有什么太大的区别。</p><h2>深度优先遍历</h2><p>我们依然还是从栈的遍历方式入手，也就是图中的 <em>深度优先遍历</em> 这种形式。对于栈来说，不断地将新的结点压栈，直到发现它没有其它的子结点后再原路返回，当发现某个结点有其它的结点时再进入子结点压栈，这就是深度遍历的思想。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在这里，需要注意的是我们要记录一下已经访问过的结点，当出现多个结点都有连接到某一个结点的路径时，保证这个结点只访问过一次。这是和树结构的最大不同，因为树是一路向下的，平级结点之间没有联系，一个结点只有一个上级结点。而图则是任意一个结点都可以和其它任意的结点有关系。</p><h3>邻接矩阵</h3><p>首先，我们看一下邻接矩阵的深度优先遍历算法的实现。现在看不懂没关系，往下拉去看下图解，然后结合着一起看。当然，更好的方案是自己运行起来。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$visited = []; // 已访问结点\n\nfunction DFS_AM($graphArr, $x)\n{\n    global $visited;\n    echo \"节点：{$x}\", PHP_EOL;\n    $visited[$x] = true; // 当前结点标记为已访问\n     \n    // y 就是邻接矩阵中的横行\n    for ($y = 1; $y &lt;= count($graphArr); $y++) {\n        // 循环判断第 [x][y] 个数据是否为 1，也就是是否有边\n        // 并且这个结点没有被访问过\n        if ($graphArr[$x][$y] != 0 &amp;&amp; !$visited[$y]) {\n            // 进行栈递归，传递的参数是当前这个结点\n            DFS_AM($graphArr, $y);\n        }\n    }\n}\n\nBuildGraph($graphArr); // 建立邻接矩阵图\n\necho \'请输入开始遍历的结点（1-结点数）：\'; \nfscanf(STDIN, \"%d\", $startNode); // 输入从第几个结点开始访问\nDFS_AM($graphArr, $startNode); // 开始深度优先遍历</code></pre></div><p>代码量不多吧，使用的就是上篇文章中建立邻接矩阵的代码，如果已经忘了就回去看看或者直接从文章最下面的链接去看源代码吧。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来我们进行测试：</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\"># php 5.3图的遍历：深度优先与广度优先.php\n输入结点数：4\n请输入边数：3\n请输入边，格式为 出 入 权：1 2 1\n请输入边，格式为 出 入 权：1 3 1\n请输入边，格式为 出 入 权：3 4 1\n请输入开始遍历的结点（1-结点数）：3\n节点：3\n节点：1\n节点：2\n节点：4</code></pre></div><h3>邻接表</h3><p>当然，邻接表的遍历思想也是相同的，只是中间的循环算法使用的是链式特点的方式。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$visited = [];  // 已访问结点\n\nfunction DFS_AL($graph, $x){\n    global $visited;\n\n    $p = $graph-&gt;adjList[$x]; // 指定结点的第一个边结点\n    echo \"节点：{$x}\", PHP_EOL; // 输出指定结点的信息\n    $visited[$x] = true; // 设置该结点已被访问\n\n    while($p != null){\n        $y = $p-&gt;adjVex; // 获得边结点信息\n        if(!$visited[$y]){ // 如果结点没有被访问过\n            DFS_AL($graph, $y); // 进入这个边结点的深度遍历过程\n        }\n        $p = $p-&gt;nextArc; // 移动到下一个边结点\n    }\n\n}\n\n$graph = BuildLinkGraph();\n$graphBFS = $graph;\necho \'请输入开始遍历的结点（1-结点数）：\';\nfscanf(STDIN, \"%d\", $startNode); // 输入从第几个结点开始访问\nDFS_AL($graph, $startNode);// 开始深度优先遍历</code></pre></div><p>是不是也很简单，接下来也是简单地测试一下：</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\"># php 5.3图的遍历：深度优先与广度优先.php\n请输入 结点数 边数：\n4 3\n请输入边，格式为 出 入 权：1 2 1\n请输入边，格式为 出 入 权：1 3 1\n请输入边，格式为 出 入 权：3 4 1\n请输入开始遍历的结点（1-结点数）：3\n节点：3\n节点：4\n节点：1\n节点：2</code></pre></div><p>输出的顺序怎么和邻接矩阵的不太一样？我们在上篇文章中实现的邻接表使用的是头插法，后输入的数据添加在结点链接的前面，如果我们将 3 4 1 放在第一个输入的话，那么结点就和邻接矩阵的遍历结果一样了。</p><h3>深度优先遍历图示</h3><p>直接就上来看了代码，又讲了半天算法，是不是还是一头雾水？没关系，我们直接上图看看：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/ca89ad98dc6113adf4f7dccff4aa1112.jpg\" alt=\"//img1.zyblog.com.cn/old/ca89ad98dc6113adf4f7dccff4aa1112.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>左边是邻接矩阵的，右边是邻接表的。我们测试的图比较简单，4 个结点 3 条边，下面是复杂一些有 6 个结点 5 条边的图。大家可以自己测试一下。每一步的遍历和执行顺序看小黑圆的数字。下面我们以邻接矩阵的第一张图来简单地讲解下访问的步骤：</p><ul><li><p>首先我们输入从 结点3 开始访问，然后开始深度遍历，这时<strong>输出 结点3</strong></p></li><li><p>第一步 结点3 的循环中获得它和 结点1 有边，于是递归传入 结点1 ，结点1 入栈</p></li><li><p><strong>输出 结点1</strong>，目前的递归中 结点1 在栈顶</p></li><li><p>在 结点1 的循环中发现 结点1 和 结点 2 有边，于是递归传入 结点2 ，结点2 入栈</p></li><li><p><strong>输出 结点2</strong>，目前的递归中 结点2 在栈顶</p></li><li><p>注意了，重点在这里，结点2 的循环中没有发现与其它未访问的结点有边存在了，于是递归开始返回，也就是开始出栈了，依次返回到 结点1 、结点3，没有任何输出，栈空了，递归回到最外层的函数了</p></li><li><p>继续 结点3 的循环，发现与 结点4 有边，递归传入 结点4</p></li><li><p><strong>输出 结点4</strong>，目前的递归中 结点4 在栈顶</p></li><li><p>结点4 的循环中没有发现其它未访问的结点及边了，递归返回，结点4 出栈</p></li><li><p>结点3 循环完成，遍历结束</p></li></ul><p>一步一步的很清晰吧，大家试着自己分析一下下面那个复杂一些图的深度遍历顺序，看看和我们程序输出的结果是不是一样的。在很多的考研或者数据结构考试中，经常会有选择题或应用题让你手动地来写出深度优先遍历的顺序哦！</p><h2>广度优先遍历</h2><p>接下来就是广度优先遍历了，其实说白了就是我们在学习树的遍历时候的层序遍历。前面我们说过，深度遍历是一条路走到黑，没路了退回来。而广度遍历则是一层一层的查看，直到找到出口。</p><h3>邻接矩阵</h3><p>使用邻接矩阵来进行广度优先遍历的操作，其实最核心的遍历方式和深度遍历没什么区别，都是对某一个结点进行边的查找，唯一不同的就是把递归栈换成了队列而已。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$visited = [];\nfunction BFS_AM($graphArr, $x){\n    global $visited;\n\n    $queue = InitSqQueue(); // 初始化队列\n    $graphCount = count($graphArr); // 获取矩阵结点数量\n    $visited[$x] = true; // 结点标记为已访问\n    EnSqQueue($queue, $x); // 结点入队\n    while($x){ // 循环判断结点是否 fasle\n        // 遍历所有结点是否与这个结点有边\n        for ($y = 1; $y &lt;= $graphCount; $y++) {\n            // 如果有边并且未访问过\n            if ($graphArr[$x][$y] != 0 &amp;&amp; !$visited[$y]) {\n                $visited[$y] = true; // 结点标记为已访问\n                EnSqQueue($queue, $y); // 结点入队\n            }\n        }\n        $x = DeSqQueue($queue); // 出队一个结点\n        echo $x, PHP_EOL; // 输出结点\n    }\n}\n\necho \'请输入开始广度遍历的结点（1-结点数）：\';\nfscanf(STDIN, \"%d\", $startNode);\nBFS_AM($graphArr, $startNode); // 开始广度遍历</code></pre></div><p>代码中的注释也很清晰明了了，我们直接进行测试：</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">……\n……\n请输入开始广度遍历的结点（1-结点数）：3\n3\n1\n4\n2</code></pre></div><h3>邻接表</h3><p>同样地，我们也提供邻接表的链式广度优先遍历的核心函数。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$visited = [];\nfunction BFS_AL($graph, $x){\n    global $visited;\n\n    $visited[$x] = true; // 结点标记为已访问\n    $queue = InitSqQueue();// 初始化队列\n    EnSqQueue($queue, $x); // 结点入队\n    \n    // 如果一直有能出队的结点，就一直循环\n    // 也就是说，如果队列空了，循环就结束\n    while(($i = DeSqQueue($queue))!==false){\n        echo $i, PHP_EOL; // 输出结点\n        $p = $graph-&gt;adjList[$i]; // 结点的第一个边结点\n        while($p != null){ // 如果不为空\n            $y = $p-&gt;adjVex; // 边结点信息\n            if(!$visited[$y]){ // 如果没有访问过\n                $visited[$y] = true; // 标记结点为已访问\n                EnSqQueue($queue, $y); // 入队结点\n            }\n            $p = $p-&gt;nextArc; // 结点指针指向下一个\n        }\n    }\n}\n\necho \'请输入开始遍历的结点（1-结点数）：\';\nfscanf(STDIN, \"%d\", $startNode);\nBFS_AL($graph, $startNode); // 开始广度遍历</code></pre></div><p>核心的循环中的操作其实也和深度遍历没什么太大的区别，同样是换成了队列这种存储形式而已。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">……\n……\n请输入开始广度遍历的结点（1-结点数）：3\n3\n4\n1\n2</code></pre></div><h3>广度优先遍历图示</h3><p>好吧，上面又罗列完了算法，接下来就是图示的时间了，相信还是一看图大家就马上能明白广度优先遍历的具体步骤了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/cc951d6af82ccce757c5a39d53278817.jpg\" alt=\"//img1.zyblog.com.cn/old/cc951d6af82ccce757c5a39d53278817.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>和上面的图一样，同样还是左边是邻接矩阵，右边是邻接表。在这里，我们依然还是直接分步骤来看一下左边最上面图的遍历操作顺序：</p><ul><li><p>输入 结点3 开始广度遍历，结点标记为已访问，这时 结点3 入队</p></li><li><p>使用 while 循环判断 结点x 是否为 null ，如果不为 null 进入循环体</p></li><li><p>遍历所有结点是否与这个结点有边，如果有边，并且这个结点没有被访问过，标记已访问，加入队列</p></li><li><p>出队一个元素，并赋值给 x</p></li><li><p>输出 x 结点的信息</p></li></ul><p>广度优先遍历没有栈的回溯，就是一条线性的队列走完就完了，所以图示会非常清晰。单独一个结点我们会将和它相关的所有结点入队，然后出队最顶上的结点，这样就能够像树的层序遍历一样按照一层一层的顺序来遍历整个图。同样地，拿起纸笔，找复杂一点的图，试试能不能手写出类似于广度优先遍历顺序的题目吧！</p><h2>总结</h2><p>大家学完了之后是不是发现今天介绍的深度优先和广度优先两种遍历方式真的和树的遍历方式没什么太大的区别。最大的不同就是我们要标记已访问过的结点而已。不管怎么说，使用栈和队列来对树或图进行遍历是所有树和图的操作算法中最最基础的部分，也是考试和面试中最常见的问题，大家一定要深入理解掌握哦！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/5.%E5%9B%BE/source/5.3%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/5.图/source/5.3图的遍历：深度优先与广度优先.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2021-04-10 21:47:55', 1);
INSERT INTO `zy_articles_xs_test` VALUES (14, '【PHP数据结构与算法5.4】图的应用：最小生成树', '<h1>图的应用：最小生成树</h1><p>在学习了图的基本结构和遍历方式后，我们再继续地深入学习一些图的基本应用。在之前的数据结构中，我们并没接触太多的应用场景，但是图的这两类应用确是面试或考试中经常出现的问题，而且出现的频率还非常高，不得不来好好说一说。</p><h2>什么是最小生成树？</h2><p>从前面的学习中，我们应该能够发现，图就是一种扩展的树结构。对于树来说，它只有一个上级结点，同级结点之间没有关联。而图则打破了树的这些规则。我们再反过来想想，能不能给定一个条件，那就是连接上所有的结点，但是每个结点之间只保留一条边。这样形成的一颗简单的树其实就是能够串联所有结点的一条路径，而最小生成树的概念，其实就是对于有权图来说，权数最少的那条能够串连起所有结点的边的路径，或者也可以说是最小连通树、最小连通子图、最小代价树。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/db2f125854e11f245c8326e2bf03661a.jpg\" alt=\"//img1.zyblog.com.cn/old/db2f125854e11f245c8326e2bf03661a.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从上图中就可以看出，对于一个有权图来，可以有许多生成树的方式，不过不同的路线方式的结果会不同，只有最后一个路径形成的生成树具有路径最小的那颗树，就是我们需要的最小生成树。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>为什么要强调是有权图呢？因为如果是无权图，所有结点连接起来的方案其实就没有什么太大的意义了，因为不管从哪个结点出发走哪条路径可能权值都是一样的。而带权路径则总会有一条最佳的路径是可以将所有结点遍历完成并且权数还是最小的。最典型的应用就是地图上哪条线路成本最少呀，办公楼布线怎么走线最经济之类相关的题目，基本都会牵涉到最小生成树的概念。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>关于最小生成树的最经典的算法，Prim 和 Kruskal 这两个大神级别的算法是绕不过去的槛，下面我们就来粗浅地学习一下。</p><h2>第一种算法 Prim</h2><p>Prim 算法，中文名 普里姆 算法。起源就不多说了，反正是个人名，这篇文章和下篇文章中图的应用的这些算法名称都是人名相关的。他们发现并最初使用了这些算法，然后就将这些算法以他们的名字命名了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>Prim 算法的核心思想就是：从一个结点出发，查看这个结点的所有的边中权值最小的那条边，然后加上这条边所连接的那个结点的所有边，再一起看哪个边的权值最小，然后一直重复这些步骤，反正就是所有结点到我们出发的这个结点中所有权值最小的边都看一遍，并且让它们能够连接所有结点就完成了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/4afecfc572dd9f874d2ff2ca9b730e08.jpg\" alt=\"//img1.zyblog.com.cn/old/4afecfc572dd9f874d2ff2ca9b730e08.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>看图是不是就清晰多了。我们一步一步地看。</p><ul><li><p><br class=\"ProseMirror-trailingBreak\"></p><ol><li><p>首先我们从第 1 个结点出发，然后看第 1 个结点相关的边哪个权值最小，很明显，我们要选选择 &lt;1, 2&gt; 这条边，然后将结点 2 加入到选择中</p></li></ol></li><li><p>2）在结点 1 和结点 2 中选择最权值最小的边并连接到新的结点，在这里我们选择的是 &lt;1, 3&gt; 这条边，于是结点 3 也加入到选择中</p></li><li><p>4）在结点 1、2、3 的所有边中，选择权值最小的边，可以看到 &lt;2, 3&gt; 这条边的权值最小，但是 2 和 3 都已经连通了，所以选择下一个最小的边 &lt;3, 4&gt; ，结点 4 还没有加入到已经连通的结点中，于是就走 &lt;3, 4&gt; 这条边，结点 4 加入已连通结点中</p></li><li><p>5）同样地，在结点 1、2、3、4 中选择权值最小的边，这时只有 &lt;4, 6&gt; 边是最小的，并且结点 6 也没有加入到已连通结点中，选择这条路线，结点 6 加入连通结点中</p></li><li><p>6）最后，在结点 1、2、3、4、6 中查找权值最小的边，得到 &lt;6, 5&gt; 这条边，结点 5 也没连通，于是选择这条路径，加入结点 5</p></li><li><p>7）所有结点都已经连通，权值累加结点为 19 ，当前的这条路径就是最小权值路径，所形成的这一条路径就是一颗最小生成树了</p></li></ul><p>从这个步骤和图释来说，大家可以自己尝试写写这个 Prim 算法的代码，其实并不复杂。我们需要一个集合来放置已经连通的结点信息，当查找路径的时候找到的最小权值路径连通的结点不在集合中，就加入到集合中。然后不断累加所有的路径权值，最后就得到了遍历整张图的最小生成树路径。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 普里姆算法\nfunction Prim($graphArr)\n{\n    $n = count($graphArr);\n    // 记录 1 号顶点到各个顶点的初始距离\n    $dis = [];\n    for ($i = 1; $i &lt;= $n; $i++) {\n        $dis[$i] = $graphArr[1][$i];\n    }\n\n    // 将 1 号顶点加入生成树\n    $book[1] = 1; // 标记一个顶点是否已经加入到生成树\n    $count = 1; // 记录生成树中的顶点的个数\n    $sum = 0; // 存储路径之和\n    // 循环条件 生成树中的顶点的个数 小于 总结点数\n    while ($count &lt; $n) {\n        $min = INFINITY;\n        for ($i = 1; $i &lt;= $n; $i++) {\n            // 如果当前顶点没有加入到生成树，并且记录中的权重比当前权重小\n            if (!$book[$i] &amp;&amp; $dis[$i] &lt; $min) {\n                // 将 $min 定义为当前权重的值\n                $min = $dis[$i];\n                $j = $i; // 用于准备将顶点加入到生成树记录中\n            }\n        }\n        $book[$j] = 1; // 确认将最小权重加入到生成树记录中\n        $count++; // 顶点个数增加\n        $sum += $dis[$j]; // 累加路径和\n        // 调整当前顶点 $j 的所有边，再以 $j 为中间点，更新生成树到每一个非树顶点的距离\n        for ($k = 1; $k &lt;= $n; $k++) {\n            // 如果当前顶点没有加入到生成树，并且记录中的 $k 权重顶点大于 $j 顶点到 $k 顶点的权重\n            if (!$book[$k] &amp;&amp; $dis[$k] &gt; $graphArr[$j][$k]) {\n                // 将记录中的 $k 顶点的权重值改为 $j 顶点到 $k 顶点的值\n                $dis[$k] = $graphArr[$j][$k];\n            }\n        }\n    }\n    return $sum;\n}\n\n$graphArr = [];\nBuildGraph($graphArr); // 之前文章中的生成邻接矩阵的函数\n\necho Prim($graphArr); // 19</code></pre></div><p>我们运行代码并输入测试数据。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">php 5.4图的应用：最小生成树.php\n请输入结点数：6\n请输入边数：9\n请输入边，格式为 出 入 权：2 4 11\n请输入边，格式为 出 入 权：3 5 13\n请输入边，格式为 出 入 权：4 6 3\n请输入边，格式为 出 入 权：5 6 4\n请输入边，格式为 出 入 权：2 3 6\n请输入边，格式为 出 入 权：4 5 7\n请输入边，格式为 出 入 权：1 2 1\n请输入边，格式为 出 入 权：3 4 9\n请输入边，格式为 出 入 权：1 3 2\n19</code></pre></div><p>可以看到输出的结果和我们预期的一样。代码中已经有很详细的注释说明了，如果直接看代码比较晕的话，大家可以拿调试工具进行断点的单步调试来看一下具体的运行情况。在这里我们先看一下那个 dis[] 中最后都保存了什么东西。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">Array\n(\n    [1] =&gt; 9999999\n    [2] =&gt; 1\n    [3] =&gt; 2\n    [4] =&gt; 9\n    [5] =&gt; 4\n    [6] =&gt; 3\n)</code></pre></div><p>INFINITY 是我们定义的一个常量，在初始化 graphArr 这个邻接矩阵时，将所有的边都设置为 INFINITY 了，主要就是方便我们后面进行最小值的比对。这个 INFINITY 我们设置的是 9999999 这样一个非常大的数。dis[] 中其实包含的就是结点 1 所经过的每条边所选择的权值，把他们加起来就是我们的最终路径长度。</p><h2>第二种算法 Kruskal</h2><p>Prim 算法好玩吗？相信通过具体的算法你对最小生成树的概念就更清晰了，不知道你会不会有个这样的想法：直接遍历所有的边，给他们按权值排序，这样我们再依次遍历这个排序后的边结构数组，然后将边的结点加入到最终要生成的树中，这样不也能形成一个最小生成树嘛！哇塞，你要是真的想到这个方案了那要给一个大大地赞了。这种方式就是我们最小生成树的另一种明星算法：Kruskal 算法。它的中文名字可以叫做 克鲁斯卡尔 算法。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/ee54d66998225334ef2ef1daf379298d.jpg\" alt=\"//img1.zyblog.com.cn/old/ee54d66998225334ef2ef1daf379298d.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>看这个步骤是不是和 Prim 就完全不一样了？不急，我们还是一步一步地来看。</p><ul><li><p>1）在所有的边中，选择最小的那条边，也就是 &lt;1, 2&gt; 这条边，结点 1 和结点 2 连通</p></li><li><p>2）接着选择第二小的边，&lt;1, 3&gt; 边符合条件，并且结点 3 没有连通，加入结点 3</p></li><li><p>3）继续选择最小的边，此时最小的边是 &lt;4, 6&gt; ，这两个结点都没有连通，直接加入</p></li><li><p>5）接下来是 &lt;6, 5&gt; 这条边最小，继续连通并将结点 5 加入</p></li><li><p>6）好了，左右两边成型了，现在最小的边是 &lt;2, 3&gt; 边，不过结点 2 和结点 3 已经连通了，放弃！选择 &lt;4, 5&gt; 边，同样，结点4 和结点 5 也已经连通了，放弃！选择 &lt;3, 4&gt; 边，OK，这两条边还没有连通，直接连通，所有结点连通完毕，最小生成树完成！</p></li></ul><p>不错吧，又学会一个新的套路，大家也可以试试按照上面的步骤和图释来自己先写写代码。需要注意的我们要先给所有的边排序，才能进行这个算法的操作。另外，每次判断结点连通也是一件费事的工作，使用深度优先或者广度优先遍历是没问题的，但效率太低，让我们看看大神（算法书中）们是怎么做的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 克鲁斯卡尔算法\nfunction Kruskal($graphArr)\n{\n    global $map, $f;\n    $hasMap = [];\n    $i = 1;\n    // 转换为序列形式方便排序\n    // O(mn)或O(n^2)，可以直接建图的时候使用单向图进行建立就不需要这一步了\n    foreach ($graphArr as $x =&gt; $v) {\n        foreach ($v as $y =&gt; $vv) {\n            if ($vv == INFINITY) {\n                continue;\n            }\n            if (!isset($hasMap[$x][$y]) &amp;&amp; !isset($hasMap[$y][$x])) {\n                $map[$i] = [\n                    \'x\' =&gt; $x,\n                    \'y\' =&gt; $y,\n                    \'w\' =&gt; $vv,\n                ];\n                $hasMap[$x][$y] = 1;\n                $hasMap[$y][$x] = 1;\n                $i++;\n            }\n        }\n    }\n    // 使用快排按照权重排序\n    quicksort(1, count($map));\n\n    // 初始化并查集\n    for ($i = 1; $i &lt;= count($graphArr); $i++) {\n        $f[$i] = $i;\n    }\n\n    $count = 0; // 已记录结点数量\n    $sum = 0; // 存储路径之和\n    for ($i = 1; $i &lt;= count($map); $i++) {\n        // 判断一条边的两个顶点是否已经连通，即判断是否已在同一个集合中\n        if (merge($map[$i][\'x\'], $map[$i][\'y\'])) { // 如果目前已连通，则选用这条边\n            $count++;\n            $sum += $map[$i][\'w\'];\n        }\n        if ($count == count($map) - 1) { // 直到选了n-1条边后退出\n            break;\n        }\n    }\n    return $sum;\n}</code></pre></div><p>Oh my God！代码多了好多，还有好多莫名其妙的东西出现了。在上文中说过，我们要使用 Kruskal 算法就得先给边排序。所以我们先将邻接矩阵转换成 map[x,y,w] 的形式，x 和 y 依然是代码两个结点，而 w 代表权重。这样的一个可以看成是边对象的数组就比较方便我们进行排序了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接着我们使用快速排序按照权值进行排序，具体的快排算法我们在后面学习排序的时候再详细说明，大家可以直接在文章底部复制测试代码链接查看完整的代码。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来就是使用并查集进行 Kruskal 算法的操作了。并查集就是代替深度和广度优先遍历来快速确定结点连通情况的一套算法。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$f = [];\n\n// 并查集寻找祖先的函数\nfunction getf($v)\n{\n    global $f;\n    if ($f[$v] == $v) {\n        return $v;\n    } else {\n        // 路径压缩\n        $f[$v] = getf($f[$v]);\n        return $f[$v];\n    }\n}\n\n// 并查集合并两子集合的函数\nfunction merge($v, $u)\n{\n    global $f;\n    $t1 = getf($v);\n    $t2 = getf($u);\n    // 判断两个点是否在同一个集合中\n    if ($t1 != $t2) {\n        $f[$t2] = $t1;\n        return true;\n    }\n    return false;\n}</code></pre></div><p>它本身还是通过递归的方式来将结点保存在一个数组中，通过判断两个点是否在同一个集合中，即两个结点是否有共同的祖先来确定结点是否已经加入并且连通。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>关于并查集的知识本人掌握的也并不是很深入，所以这里就不班门弄斧了，大家可以自己查阅相关的资料或者深入研究各类算法书籍中的解释。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>最后运行代码输出的结果和 Prim 算法的结果是一致的，都是 19 。</p><h2>总结</h2><p>怎么样？最小生成树是不是很好玩的东西，图的结构其实是很复杂的，不过越是复杂的东西能够玩出的花活也越多。但是反过来说，很多公司的面试过程中关于图的算法能考到这里的也都是大厂了，一般的小公司其实能简单地说一说深度和广度就已经不错了。我们的学习还要继续，下一篇我们将学习的是另一个图的广泛应用：最短距离。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>今天的测试代码均根据 《啊哈！算法》 改写为 PHP 形式，参考资料依然是其它各类教材。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/5.%E5%9B%BE/source/5.4%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/5.图/source/5.4图的应用：最小生成树.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《啊哈！算法》</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2021-07-28 11:10:38', 1);
INSERT INTO `zy_articles_xs_test` VALUES (15, '【PHP数据结构与算法5.5】图的应用：最短路径', '<h1>图的应用：最短路径</h1><p>上篇文章的最小生成树有没有意犹未尽的感觉呀？不知道大家掌握得怎么样，是不是搞清楚了普里姆和克鲁斯卡尔这两种算法的原理了呢？面试的时候如果你写不出，至少得说出个大概来吧，当然，如果你是要考研的学生，那就要深入的理解并且记住整个算法的代码了。</p><h2>什么是最短路径</h2><p>今天我们学习的是图的应用中另外一个经典的问题，也就是 最短路径 的问题。这个问题和最小生成树是不同的，最小生成树的要求是要连通所有的结点，并且走得是权值最小的那条路线。而最短路径则是指的从某个顶点到另一个顶点中权值最小的那条路径。这条路径不一定是包含在最小生成树中的，所以它们并没有太大的联系。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/ca93c8c5b5b7a5018f9abb8e5c4d1bff.jpg\" alt=\"//img1.zyblog.com.cn/old/ca93c8c5b5b7a5018f9abb8e5c4d1bff.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从这张图来看，我们从结点 1 到结点 2 的最短路径是 2 ，这个很明显。那么从结点 1 到结点 3 呢？可不是直接的中间那个权值为 6 的路径，而是走 1-&gt;2-&gt;3 这条路径，也就是权值加起来为 5 的这条路径。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>然后我们再来看结点 3 ，它到结点 1 最短路径应该是走 3-&gt;4-&gt;1 这条路径，也就是权值为 6 的这条路径，而不是中间的那条直线的权值为 7 的路径。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>没错，这就是最短路径的概念了。在最短路径中，我们一般会解决单向图的问题，但实际生活中呢？最典型的地图相关的应用其实是都是双向图的。不过这并不影响我们的学习，我们可以把这个示例图中的结点看成是城市火车站点，就算是连接结点 1 和结点 3 的火车线路，也不一定来去的时间都是相同的。比如说从长沙到北京的 Z2 次火车全部运行时间为14小时42分，而回来的 Z1 次则是14小时10分。那么我们是否可以选择其它的火车，比如有趟火车从长沙到石家庄可能只需要8小时，然后从石家庄到北京只需要2小时，这样我们选择这条线路的总时间就只需要10小时了（当然，这只是例子，大家在非高铁的情况下肯定还是更多地会选择起始站的火车来坐）。</p><h2>多源最短路径 Floyd 算法</h2><p>首先，我们先说一个多源最短路径的算法。那么什么叫做多源呢？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>其实就是这一个算法就能够得出所有结点到所有结点之间的最短路径。没错，就这一个算法，不管哪个结点到哪个结点，它们之间的最短路径都一次性算出来了。神奇吗？不不不，更神奇的，而且你一会就会叫出 Oh!My God! 的是它的核心代码，只有五行！！</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function Floyd($graphArr){\n    $n = count($graphArr);\n    \n    for($k = 1;$k&lt;=$n;$k++){ // 设 k 为经过的结点\n        for($i = 1;$i&lt;=$n;$i++){\n            for($j = 1;$j&lt;=$n;$j++){\n                // 如果经过 k 结点 能使 i 到 j 的路径变短，那么将 i 到 j 之间的更新为通过 k 中转之后的结果 \n                if($graphArr[$i][$j] &gt; $graphArr[$i][$k] + $graphArr[$k][$j]){\n                    $graphArr[$i][$j] = $graphArr[$i][$k] + $graphArr[$k][$j];\n                }\n            }\n        }\n    }\n\n    for($i = 1;$i&lt;=$n;$i++){\n        for($j = 1;$j&lt;=$n;$j++){\n            echo $graphArr[$i][$j], \' \';\n        }\n        echo PHP_EOL;\n    }\n}\n// 请输入结点数：4 \n// 请输入边数：8\n// 请输入边，格式为 出 入 权：1 2 2\n// 请输入边，格式为 出 入 权：1 3 6\n// 请输入边，格式为 出 入 权：1 4 4 \n// 请输入边，格式为 出 入 权：2 3 3\n// 请输入边，格式为 出 入 权：3 1 7\n// 请输入边，格式为 出 入 权：3 4 1\n// 请输入边，格式为 出 入 权：4 1 5\n// 请输入边，格式为 出 入 权：4 3 12\n// 0 2 5 4 \n// 9 0 3 4 \n// 6 8 0 1 \n// 5 7 10 0 </code></pre></div><p>我们可以先验证下结果，就是注释中最后输出的矩阵。结点 1 到结点 2、3、4的最短距离为 2 、5 、4 。结点 3 到结点 1 、2 、4 的最短距离为 6 、8 、1 。也就是说，原来的那个图的邻接矩阵成了这个最短路径的矩阵。每一行代表每个结点到其它结点的最短距离。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>好吧，结果没问题，那么代码到底是写得啥玩意？这个 k 是什么？别急，我们一步一步来看。</p><ul><li><p>假设两点之间的距离不是最短的，那么肯定是有另外一个点做为媒介进行跳转，由 i 点先跳到这个点然后再跳向 j 点，这样的一条路径是比直接的 i 到 j 要近的，我们就定义这个点为 k 点</p></li><li><p>但是我们不知道要走哪个结点呀，而且还有可能不只是一个 k ，或许我们从 i 到 j 要经历好多个 k ，这时候，我们就从 k 开始遍历，也就是第一层循环</p></li><li><p>在第一层循环下，进行我们正常的 i 和 j 的遍历循环，获得 i 直接到 j 的长度，也就是 [i][j] 。这时，由于有最外层的 k 存在，所以我们也知道了如果 i 从 k 走再从 k 到 j 的长度，也就是 [i][k] + [k][i] 这段距离</p></li><li><p>很明显，如果 [i][k] + [k][i] 的距离要比 [i][j] 短的话，更新 [i][j] 的值为 [i][k] + [k][i]</p></li><li><p>内部的 i 和 j 循环完成后，第 1 个结点做为媒介跳转的遍历也完成了，当前的矩阵中各个结点之间的权重已经是经过第 1 个结点做为媒介之后的最短路径了</p></li><li><p>但是呢，这并不准确，说不定我们可能经过 i 、k1 、 k2 、 j 的路径才是最短的，所以外层的 k 循环继续遍历并将第 2 个结点作为媒介结点</p></li><li><p>循环往复直到所有结点都做过一次中间的媒介结点之后，我们就得到了一个最短路径的矩阵图，也就是我们上面测试代码中输出的结果</p></li></ul><p>我们就拿结点 4 和结点 3 来说明。我们定义 4 为 i ，结点 3 为 j 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>初始化时，[i][j] 为 12 ，这个没什么问题，单向图的那条带箭头的边的权值就是 12 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>然后当 k 为 1 时，也就是我们经过结点 1 来看路径有没有变短，这时 [i][k] 是 5 ，[k][j] 是 6 ，OK，路径变成 11 了，把 [i][j] 的值改成 11 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>同时，在 i 为 4 ，j 为 2 的情况下，他们两个的最短路径也在这次 k=1 的循环中被赋值为 7 。最开始 4 到 2 是没有直接的边的，现在在结点 1 的连接下，他们有了路径，也就是 [4][2] = [4][1] + [1][2] = 7  。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>当 k 为 2 时，[i][j] 为 11 ，这时 [i][k] 就是上面说过的 [4][2] 。也就是 7 ，而 [k][j] 则是 3 ，路径又缩小了，[i][k] + [k][j] = 10 ，[i][j] 现在又变成了 10 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>循环继续，但已经没有比这条路径更小的值了，所以最后 [4][2] 的最短路径就是 10 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>看着晕吗？拿出笔来在纸上或者本子上自己画画，每一步的 k 都去画一下当前的最短路径矩阵变成什么样了。这样画一次之后，马上就知道这个 Floyd 算法的核心奥秘所在了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>不得不说，前人的智慧真的很伟大吧，不过说是前人，其实 Floyd 大佬在 1962 年才发表了这个算法，但这个算法的核心思想却是数学中的动态规划的思想。所以说，算法和数学是没法分家的，各位大佬哪个不是数学界的一把手呢。</p><h2>单源最短路径 Dijkstra 算法</h2><p>说完了多源最短路径，我们再讲一个鼎鼎大名的单源最短路径的算法。虽说上面的多源很牛X，但是它的时间复杂度也就是时间效率也确实是太差了，没看错的话三个 N 次的循环嵌套就是 O(N3)。如果数据稍微多一点的话基本就可以从 Oh!My God! 变成 Oh!FxxK! 了。而且大多数情况下，我们的需求都会是固定的求从某一点到另一点的最短路径问题，也就是单源最短路径问题。这时，就可以使用这种效率稍微好一点的算法来快速地解决了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// origin 表示源点，也就是我们要看哪个结点到其它结点的最短路径\nfunction Dijkstra($graphArr, $origin)\n{\n    $n = count($graphArr);\n    $dis = []; // 记录最小值\n    $book = []; // 记录结点是否访问过\n    // 初始化源点到每个点的权值\n    for ($i = 1; $i &lt;= $n; $i++) {\n        $dis[$i] = $graphArr[$origin][$i]; // 源点到其它点的默认权值\n        $book[$i] = 0; // 所有结点都没访问过\n    }\n\n    $book[$origin] = 1; // 源点自身标记为已访问\n\n    // 核心算法\n    for ($i = 1; $i &lt;= $n - 1; $i++) {\n        $min = INFINITY;\n        // 找到离目标结点最近的结点\n        for ($j = 1; $j &lt;= $n; $j++) {\n            // 如果结点没有被访问过，并且当前结点的权值小于 min 值\n            if ($book[$j] == 0 &amp;&amp; $dis[$j] &lt; $min) {\n                $min = $dis[$j]; // min 修改为当前这个节点的路径值\n                $u = $j; // 变量 u 变为当前这个结点\n            }\n            // 遍历完所有结点，u 就是最近的那个顶点\n        }\n        $book[$u] = 1; // 标记 u 为已访问\n        for ($v = 1; $v &lt;= $n; $v++) {\n            // 如果 [u][v] 顶点小于无穷\n            if ($graphArr[$u][$v] &lt; INFINITY) {\n                // 如果当前 dis[v] 中的权值大于 dis[u]+g[u][v]\n                if ($dis[$v] &gt; $dis[$u] + $graphArr[$u][$v]) {\n                    // 将当前的 dis[v] 赋值为 dis[u]+g[u][v]\n                    $dis[$v] = $dis[$u] + $graphArr[$u][$v];\n                }\n            }\n        }\n        // 最近的结点完成，继续下一个最近的结点\n    }\n\n    for ($i = 1; $i &lt;= $n; $i++) {\n        echo $dis[$i], PHP_EOL;\n    }\n}\n\n// 请输入结点数：4 \n// 请输入边数：8\n// 请输入边，格式为 出 入 权：1 2 2\n// 请输入边，格式为 出 入 权：1 3 6\n// 请输入边，格式为 出 入 权：1 4 4 \n// 请输入边，格式为 出 入 权：2 3 3\n// 请输入边，格式为 出 入 权：3 1 7\n// 请输入边，格式为 出 入 权：3 4 1\n// 请输入边，格式为 出 入 权：4 1 5\n// 请输入边，格式为 出 入 权：4 3 12\n\n// 测试第四个结点到其它结点的最短路径\nDijkstra($graphArr, 4);\n// 5\n// 7\n// 10\n// 0</code></pre></div><p>代码一下增加了不少吧，不过仔细看一下核心的算法部分，这次只是两层循环的嵌套了，时间复杂度一下子就降到了 O(N2) ，这一下就比 Floyd 算法提升了很多。当然，它的场景也是有限的，那就是只能一个结点一个结点的计算。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>好了，我们还是来看一下 Dijkstra 到底在干嘛吧。我们依然是使用上面那个简单的图，并且还是研究结点 4 到其它结点的算法执行情况。</p><ul><li><p>首先，我们初始化结点 4 到其他所有结点的默认值，这时结点 4 到结点 2 是没有直接路径的，所以是无穷大，而到结点 1 是 5，到结点 3 是 12 。</p></li><li><p>然后将结点 4 标记为已访问，也就是 book[4] = 1</p></li><li><p>进入核心算法，从头开始遍历结点，这里是标记为 i 下标，因为这里是单源的最短路径，所以我们不需要再看自己到自己的最短路径了，只需要 n-1 次循环就可以了</p></li><li><p>开始 j 层的循环，先判断当前的结点是否已经被标记过，没有被标记过的话再看它的值是否是最小的，最后循环完成后获得一个从结点 4 出发的权值最小的路径，并将这条路径到达的结点下标记为 u ，标记 u 下标的这个结点为已访问结点</p></li><li><p>进入 v 循环，判断图中 u 到 v 的结点是否是无穷，如果不是的话再判断 u 到 v 的结点加上原来的 dis[u] 的权值是否小于 dis[v] 中记录的权值，如果比这个小的话，更新 dis[v] 为 u 到 v 的结点加上原来的 dis[u] 的权值</p></li><li><p>循环重复地进行比较完成算法</p></li></ul><p>对于结点 4 来说，dis 经历了如下的变化：</p><ul><li><p>首先，默认情况下 dis = [5, 9999999, 12, 0]</p></li><li><p>第一次循环后，结点1 完成查找，并在 v 的循环中发现了可以从结点1 到结点2  和结点3 而且比原来的值都要小 ，于是 dis = [5, 7, 11, 0]</p></li><li><p>第二次循环后，结点2 完成查找，这次循环发现从结点2 到结点3 的距离更短，于是 dis = [5, 7, 10, 0]</p></li><li><p>第三次循环后，结点3 完成查找，没有发现更短的路径，dis = [5, 7, 10, 0]</p></li></ul><p>看明白了吗？不明白的话自己试试吧，不管是断点还是在中间输出一下 dis 和 book ，都能够帮助我们更好地理解这个算法的每一步是如何执行的。从代码中就可以看出来，这个 Dijkstra 算法的时间复杂度是 O(N2) ，这可比 Floyd 快了不少了吧。</p><h2>总结</h2><p>关于图的两种最典型的应用及算法就到这里结束了。当然，图的内容可远不止这些，比较典型的还是进度网络图等的算法，特别是做一些项目管理类的系统时会非常有用。当然，更高深的内容就要去研究《图论》了。这个可就远超我的水平了，希望有更多数学相关基础的同学能够继续深入研究。而我嘛，先去恶补下数学吧！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/5.%E5%9B%BE/source/5.5%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/5.图/source/5.5图的应用：最短路径.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《啊哈！算法》</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2021-11-16 10:38:41', 1);
INSERT INTO `zy_articles_xs_test` VALUES (16, '【PHP数据结构与算法6.1】线性查找与二分查找', '<h1>线性查找与二分查找</h1><p>欢迎来到查找的世界，在学习完各种数据结构之后，总算走到了这一步，不知道大家有什么感想呢？反正我是边学边忘，现在让我去说说图的那几个算法还是在蒙圈的状态中。不过学习嘛，就是一步一步的来，暂时搞不懂的东西其实也是可以放一放的。打破砂锅和坚持不懈当然是好的品德，但有些东西可能真的是需要时间去消化的，甚至可能是需要真实的项目经历才能彻底搞明白。在我们编程行业来说就是典型的这种实践的学习形式效果会更好，很多人在上大学的时候对于数据结构以及其它专业课都是以死记硬背为主，包括上了多少年班的同学可能都没有在业务代码中真正的使用过什么算法，所以理解它们确实是非常困难的。这时，我们可以暂时休息一下，转换一下思路，学习最主要的就是预习和复习，在这次学习完之后，将来再进行多次的复习，研究各种不同的资料，迟早有一天大家都能搞明白的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>今天的内容其实就非常简单了，可以说是除了线性表之外最简单的内容。我们只研究两个非常初级的查找，那就是顺序查找和折半查找。相信不少同学可能早就会了，一般培训机构讲数据结构和算法时，查找必讲二分，排序必讲冒泡，更不用说正规大学对口专业出身的同学了。当然，这两个也是非常简单的，不管你有没有基础，咱们一起来看看吧。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>不管你是什么算法题，还是在实际的业务开发中，查找都是非常重要的，甚至可能比排序还要重要。想想你整天面向数据库编程是在干嘛？不就是 CRUD 嘛，其中大部的业务还都是以搜索查找居多，我们在优化数据库时，也主要是优化各种查询语句。当然，要说到数据库的查找那就太高深了，以后我们学习 MySQL 相关的知识时再详细讲解，特别是索引中的 B+ 树，就是数据结构和算法的核心思想的体现。好吧，不吹牛了，也不敢在这里多说了，因为自己也没研究透呢。</p><h2>线性查找（顺序查找）</h2><p>顾名思义，不管是叫线性还是叫顺序，很明显，就是一条数据一条数据的对比下去就好啦。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function SearchSeq($sk, $arr)\n{\n    for ($i = 0; $i &lt; count($arr); $i++) {\n        if ($sk == $arr[$i]) {\n            echo $i, PHP_EOL;\n            break;\n        }\n    }\n    echo \"线性查找次数：\" . $i, PHP_EOL;\n}</code></pre></div><p>嗯，真的是连解释都不想解释了，这段代码要是看不懂的话就先去复习下基本的循环和条件判断语句吧！很明显，一次线性查找的时间复杂度就是 O(N) 。</p><h2>二分查找（折半查找）</h2><p>既然都这么简单，那么我们再直接给出折半查找的代码。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function SearchBin($sk, $arr){\n    $left = 0;\n    $right = count($arr) - 1;\n    $i = 0;\n    while ($left &lt;= $right) {\n        $i++;\n        $mid = (int) (($left + $right) / 2);\n        if ($arr[$mid] &gt; $sk) {\n            $right = $mid - 1;\n        } else if ($arr[$mid] &lt; $sk) {\n            $left = $mid + 1;\n        } else {\n            echo $mid, PHP_EOL;\n            break;\n        }\n    }\n    echo \"折半查找次数：\" . $i, PHP_EOL;\n}</code></pre></div><p>折半查找的前提是数据必须是有序的，这样我们就可以根据数据问题的长度来获取中间的数，然后跟要对比的数进行比较，如果小于这个数，就在前一半数据中查找，如果大于这个数，就在后一半部分中进行查找。一会看例子再详细说明。</p><h2>对比</h2><p>两个算法其实都很简单，我们直接看看他们的运行情况和效率区别。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$arr = [5, 6, 19, 25, 4, 33, 56, 77, 82, 81, 64, 37, 91, 23];\n\n// 输入 56\nfscanf(STDIN, \"%d\", $searchKey);\n\nSearchSeq($searchKey, $arr);\n// 6\n// 线性查找次数：6\n\nsort($arr);\nprint_r($arr);\n\nSearchBin($searchKey, $arr);\n// 8\n// 折半查找次数：3</code></pre></div><p>首先我们定义了一个数组，其实就是随便给了一些数据。然后输入一个数据，查找它在数组中的位置。比如我们在测试代码中输入了 56 ，线性查找是循环进行了 6 次，找到 56 所在的位置为下标 6 的位置。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>对于折半查找来说，我们需要先给数组排序，这时 56 会排在下标为 8 的位置，而在折半查找的循环中，我们只循环了 3 次就找到了这个位置。是不是感觉快了很多，一下就快了一倍。这可不是它的真正实力哦，折半查找的真实实力是 对数 级别的效率，也就是它的时间复杂度为 O(logN) 。我们先来结合上面的代码看下它这三次循环都干了什么。</p><ul><li><p>第一次进入，mid 为 6 (0+13=13，除2)，下标为 arr[6] 的值为 3 ，比 56 小，所以 left = 6+1 = 7</p></li><li><p>第二轮循环，mid 为 10（7+13=20，除2），下标为 arr[10] 的值为 77 ，比 56 大，所以 right = 10-1 = 9</p></li><li><p>第三轮循环，mid 为 9（7+9=16，除2），下标为 arr[8] 的值为 56，结束</p></li></ul><p>其实很多猜数字的游戏也都是这么玩的，比如给你一个范围，0-100的数，猜他写下的是哪个数，最快最简单的方法也就是这种折半查找的方式，我们只需要最多 7 次就可以猜出 100 以内的数。很明显，这就是对数的威力。下面我们再来看一个更直观的，十万个有序的数，我们就找最后那一个数，看看顺序查找和折半查找能有多大差距。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$arr = range(1, 100000);\n$searchKey = 100000;\n\nSearchSeq($searchKey, $arr);\n// 99999\n// 线性查找次数：99999\n\nSearchBin($searchKey, $arr);\n// 99999\n// 折半查找次数：17</code></pre></div><p>嗨不嗨，这就是对数的威力！！我们需要 2 的 7 次方才能覆盖 100 以内的数，但我们只需要 2 的 17 次方，就能覆盖十万以内的数，这个效率差距还是随着 N 的越来越大而越来越明显的。</p><h2>总结</h2><p>今天的内容是不是很简单，虽说内容简单，但是我们却见识到了不同算法效率之间的巨大差异。当然，折半查找也有其本身的局限，那就是数据必须是的序的，当然，在合适的情况下我们也可以选用一个 O(logN) 的排序算法，这样总体的时间复杂度就还能保持在对数级别了。总之，先掌握好这些简单的内容，千万别在面试的时候连这一关都过不了哦！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/6.%E6%9F%A5%E6%89%BE/source/6.1%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E4%B8%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/6.查找/source/6.1线性查找与二分查找.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2020-07-31 17:00:12', 1);
INSERT INTO `zy_articles_xs_test` VALUES (17, '【PHP数据结构与算法6.2】散列表查找', '<h1>散列表查找</h1><p>上篇文章的查找是不是有意犹未尽的感觉呢？因为我们是真真正正地接触到了时间复杂度的优化。从线性查找的 O(n) 直接优化到了折半查找的 O(logN) ，绝对是一个质的飞跃。但是，我们的折半查找最核心的一个要求是什么呢？那就是必须是原始数据是要有序的。这可是个麻烦事啊，毕竟如果数据量很庞大的话，排序又会变得很麻烦。不过别着急，今天我们要学习的散列表查找又是另一种形式的查找，它能做到什么程度呢？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>O(1) ，是的，你没看错，散列表查找在最佳情况下是可以达到这种常数级别的查找效率的，是不是很神奇。</p><h2>哈希散列（除留余数法）</h2><p>先通过实际的例子看一种非常简单的散列算法。在数据量比较大的情况下，我们往往要对数据表进行表操作，最简单的一种方案就是根据某一个字段，比如说 ID 来对它进行取模。也就是说，假如我们要分20张表，那么就用数据的 ID 来除以 20 ，然后获得它的余数。然后将这条数据添加到余数所对应的这张表中。我们通过代码来模拟这个操作。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">or($i=0;$i&lt;100;$i++){\n    $arr[] = $i+1;\n}\n\n$hashKey = 7;\n$hashTable = [];\nfor($i=0;$i&lt;100;$i++){\n    $hashTable[$arr[$i]%$hashKey][] = $arr[$i];\n}\n\nprint_r($hashTable);</code></pre></div><p>在这里，我们假设是将 100 条数据放到 7 张表中，就是直接使用取模运算符 % 来获取余数就行了，接着就将数据放入到对应的数组下标中。这 100 个数据就被分别放置在了数组中 0-6 的下标中。这样，我们就实现了最简单的一种数据分表的思想。当然，在实际的业务开发中要远比这个复杂。因为我们考虑各种不同的场景来确定到底是以什么形式进行分表，分多少张表，以及后续的扩展情况，也就是说，真实情况下要比我们这里写的这个复杂很多。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>做为演示代码来说，这种分表的散列形式其实就是散列表查找中最经典也是使用最多的除留余数法。其实还有其它的一些方法，比如平方取中法、折叠法、数字分析法之类的方法。它们的核心思想都是作为一个散列的哈希算法，让原始数据对应到一个新的值（位置）上。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>类似的思想其实最典型的就是 md5() 的散列运算，不同的内容都会产生不同的值。另外就是 Redis 、 Memcached 这类的键值对缓存数据库，它们其实也会将我们设置的 Key 值进行哈希后保存在内存中以实现快速的查找能力。</p><h2>散列冲突问题（线性探测法）</h2><p>上面的例子其实我们会发现一个问题，那就是哈希算法的这个值如果很小的话，就会有很多的重复冲突的数据。如果是真实的一个存储数据的散列表，这样的存储其实并不能帮我们快速准确的找到所需要的数据。查找查找，它核心的能力其实还是在查找上。那么如果我们随机给定一些数据，然后在同样长度的范围内如何保存它们并且避免冲突呢？这就是我们接下来要学习的散列冲突要解决的问题。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$arr = [];\n$hashTable = [];\nfor($i=0;$i&lt;$hashKey;$i++){\n    $r = rand(1,20);\n    if(!in_array($r, $arr)){\n        $arr[] = $r;\n    }else{\n        $i--;\n    }\n}\n\nprint_r($arr);\nfor($i=0;$i&lt;$hashKey;$i++){\n    if(!$hashTable[$arr[$i]%$hashKey]){\n        $hashTable[$arr[$i]%$hashKey] = $arr[$i];\n    }else{\n        $c = 0;\n        echo \'冲突位置：\', $arr[$i]%$hashKey, \'，值：\',$arr[$i], PHP_EOL;\n        $j=$arr[$i]%$hashKey+1;\n        while(1){\n            if($j&gt;=$hashKey){\n                $j = 0;\n            }\n            if(!$hashTable[$j]){\n                $hashTable[$j] = $arr[$i];\n                break;\n            }\n            $c++;\n            $j++;\n            if($c &gt;= $hashKey){\n                break;\n            }\n        }\n    }\n}\nprint_r($hashTable);</code></pre></div><p>这回我们只生成 7 个随机数据，让他们依然以 7 为模进行除留取余。同时，我们还需要将它们以哈希后的结果保存到另一个数组中，可以将这个新的数组看做是内存中的空间。如果有哈希相同的数据，那当然就不能放在同一个空间了，要不同一个空间中有两条数据我们就不知道真正要取的是哪个数据了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在这段代码中，我们使用的是开放地址法中的线性探测法。这是最简单的一种处理哈希冲突的方式。我们先看一下输出的结果，然后再分析冲突的时候都做了什么。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// Array\n// (\n//     [0] =&gt; 17     // 3\n//     [1] =&gt; 13     // 6\n//     [2] =&gt; 9      // 2\n//     [3] =&gt; 19     // 5\n//     [4] =&gt; 2      // 2 -&gt; 3 -&gt; 4\n//     [5] =&gt; 20     // 6 -&gt; 0\n//     [6] =&gt; 12     // 5 -&gt; 6 -&gt; 0 -&gt; 1\n// )\n// 冲突位置：2，值：2\n// 冲突位置：6，值：20\n// 冲突位置：5，值：12\n// Array\n// (\n//     [3] =&gt; 17\n//     [6] =&gt; 13\n//     [2] =&gt; 9\n//     [5] =&gt; 19\n//     [4] =&gt; 2\n//     [0] =&gt; 20\n//     [1] =&gt; 12\n// )</code></pre></div><ul><li><p>首先，我们生成的数字是 17、13、9、19、2、20、12 这七个数字。</p></li><li><p>17%7=3，17 保存到下标 3 中。</p></li><li><p>13%7=6，13 保存到下标 6 中。</p></li><li><p>9%7=2，9 保存到下标 2 中。</p></li><li><p>19%7=5，19 保存到下标 5 中。</p></li><li><p>2%7=2，好了，冲突出现了，2%7 的结果也是 2 ，但是 2 的下标已经有人了，这时我们就从 2 开始往后再看 3 的下标有没有人，同样 3 也被占了，于是到 4 ，这时 4 是空的，就把 2 保存到了下标 4 中。</p></li><li><p>20%7=6，和上面一样，6 已经被占了，于是我们回到开始的 0 下标，发现 0 还没有被占，于是 20 保存到下标 0 中。</p></li><li><p>最后的 12%7=5，它将依次经过下标 5 、6 、0、1 最后放在下标 1 处。</p></li></ul><p>最后生成的结果就是我们最后数组输出的结果。可以看出，线性探测其实就是如果发现位置被人占了，就一个一个的向下查找。所以它的时间复杂度其实并不是太好，当然，最佳情况是数据的总长度和哈希键值的长度相吻合，这样就能达到 O(1) 级别了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>当然，除了线性探测之外，还有二次探测（平方）、伪随机探测等算法。另外也可以使用链表来实现链地址法来解决哈希冲突的问题。这些内容大家可以自己查阅一下相关的文档或书籍。</p><h2>总结</h2><p>哈希散列最后的查找功能其实就和我们上面生成那个哈希表的过程一样，发现有冲突的解决方式也是一样的，这里就不多说了。对于哈希这块来说，不管是教材还是各类学习资料，其实介绍的内容都并不是特别的多，所以，我们也是以入门的心态来简单地了解一下哈希散列这块的知识，更多的内容大家可以自己研究多多分享哈！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/6.%E6%9F%A5%E6%89%BE/source/6.2%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/6.查找/source/6.2散列表查找.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2021-12-19 23:37:25', 1);
INSERT INTO `zy_articles_xs_test` VALUES (18, '【PHP数据结构与算法7.1】插入类排序：简单插入、希尔排序', '<h1>插入类排序：简单插入、希尔排序</h1><p>总算进入我们的排序相关算法的学习了。相信不管是系统学习过的还是没有系统学习过算法的朋友都会听说过许多非常出名的排序算法，当然，我们今天入门的内容并不是直接先从最常见的那个算法说起，而是按照一定的规则一个一个的介绍。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>首先，我们要介绍的排序算法是插入类型的排序算法。顾名思义，插入排序就是将无序的一个或几个记录“插入”到有序的序列中，比较典型的例子就是简单插入排序和希尔排序。</p><h2>简单插入排序</h2><p>简单插入排序，也可以叫做直接插入排序。还是先看代码，再来进行下一步的解释。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function InsertSort($arr)\n{\n    $n = count($arr);\n    for ($i = 1; $i &lt; $n; $i++) { // 开始循环，从第二个元素开始，下标为 1 的\n        $tmp = $arr[$i]; // 取出未排序序列第一个元素\n        for ($j = $i; $j &gt; 0 &amp;&amp; $arr[$j - 1] &gt; $tmp; $j--) { // 判断从当前下标开始向前判断，如果前一个比当前元素大\n            $arr[$j] = $arr[$j - 1]; // 依次移动元素\n        }\n        // 将元素放到合适的位置\n        $arr[$j] = $tmp;\n    }\n    echo implode(\', \', $arr), PHP_EOL;\n}\n\nInsertSort($numbers);\n\n// 49, 38, 65, 97, 76, 13, 27, 49\n// 13, 27, 38, 49, 49, 65, 76, 97</code></pre></div><p>代码量不多吧，其实也非常好理解。我们就拿测试数据的前两个数来简单地说明一下。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>首先，第一个循环是从 1 开始的，也就是说，第一个取出的未排序序列元素是 tmp = arr[1] ，也就是当前的 tmp = 38 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>然后开始循环，当前的循环是判断 j-1 的元素是否比当前这个 tmp 元素大，如果是的话，进入循环体，arr[1] = arr[0] 。到目前为止，arr[0] 和 arr[1] 现在都是 49 。整个序列是 49,49,65,……</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>最后让 arr[0] = $tmp ，也就是等于 38 。（循环的时候 j-- 了）。整个序列是 38,49,65,……</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>通过下面这张图片，我们可以更清楚地看明白整个序列完成排序的过程。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/928e2365f388f3b536d80e79d48956e9.jpg\" alt=\"//img1.zyblog.com.cn/old/928e2365f388f3b536d80e79d48956e9.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从上面的步骤可以看出，简单插入排序就是从一边开始，先让前面的数据逐步有序的过程。从代码中就可以看出，它是不断地内部地循环中进行 j 的递减，与前面有序的数列进行比对，当发现了自己合适的位置之后，就将数据放到这个位置上。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从代码和我们的分析来看，简单插入排序的时间复杂度是 O(n2) 。同时，它是属于稳定的排序，什么叫稳定排序呢？细心的同学应该发现了，在我们的测试代码中，有两个相同的数据，也就是 49 。稳定的意思就是相同的数据在排序前后的位置不会发生改变，前面的 49 依然是在后面的 49 前面。这就是排序的稳定性。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另外，简单插入排序比较适合初始记录基本有序的情况，当初始记录无序，n 较大时，这个算法的时间复杂度会比较高，不太适合采用。</p><h2>希尔排序</h2><p>简单插入排序很好理解吧，希尔排序又是什么鬼呢？别着急，从这个名字我们是看不出什么端倪的，因为这个排序的名字是以它的发现者命名的。实际上，希尔排序还是一个插入排序的算法。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上文中说过，简单插入排序适合基本有序的情况，而希尔排序就是为了提升简单插入排序的效率而出现的，它主要目的是减少排序的 n 的大小以及通过几次排序就让数据形成基本有序的格式。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>对于这个算法，我们不能先上代码了，先来看图吧。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/0daf9f54628af48062aab2c04ec254a8.jpg\" alt=\"//img1.zyblog.com.cn/old/0daf9f54628af48062aab2c04ec254a8.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>看明白了吗？我们其实是将数据进行分组了，每次分组是以一定的增量为基础的，比如我们这个示意图中就是第一次以 5 为增量进行排序，第二次是以 3 为增量。这样第三次排序的时候，增量为 1 ，也就成为一个普通的简单插入排序了。一会我们代码中就会体现出来。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>还是按增量为迭代次序进行这三趟排序的具体分析吧：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>1）第一次迭代的时候，我们将分组增量设置为 5 ，这时分别有三组数据，也就是 49 和 13，38 和 27，65 和 49 ，然后对这三组数据进行简单插入排序，之后的数组结果是 13、27、49、97、76、49、38、65 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>2）第二次迭代，分组增量为 3，这时就分成了两组，每组三个数据，分别是 13、97、38 为一组，另一组是 27 、76 、65 。对这两组数据进行简单插入排序之后更新数组结果为 13、27、49、38、65、49、97、76 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>3）其实从两次分组排序之后就可以看出，这个数组已经基本有序了。这时最后就是以分组增量 1 再次进行简单插入排序。说白了，最后这一步就是一个普通的简单插入排序的过程了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>分步骤讲解之后是不是清楚很多了，再重复一篇，希尔排序其实就是按分组来一次大范围的插入排序，最后一步步缩小到只有 1 次增量的简单插入排序了。我们再来看看代码吧：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function ShellSort($arr)\n{\n    $n = count($arr);\n    $sedgewick = [5, 3, 1];\n\n    // 初始的增量值不能超过待排序列的长度\n    for ($si = 0; $sedgewick[$si] &gt;= $n; $si++); \n\n    // 开始分组循环，依次按照 5 、3 、 1 进行分组\n    for ($d = $sedgewick[$si]; $d &gt; 0; $d = $sedgewick[++$si]) {\n        // 获取当前的分组数量\n        for ($p = $d; $p &lt; $n; $p++) {\n            $tmp = $arr[$p];\n            // 插入排序开始，在当前组内\n            for ($i = $p; $i &gt;= $d &amp;&amp; $arr[$i - $d] &gt; $tmp; $i -= $d) {\n                $arr[$i] = $arr[$i - $d];\n            }\n            $arr[$i] = $tmp;\n        }\n    }\n    echo implode(\', \', $arr), PHP_EOL;\n}\nShellSort($numbers);</code></pre></div><p>看着代码貌似有三层 for 循环呀，它哪里提升了效率了呢？其实希尔排序的效率提升确实是有限的，它其实是通过前几次的分组让数据先基本有序。而在分组的状态中，数据比较的数量并不会达到 n 的级别。当最后一次进行简单排序的时候，整个数据已经是基本有序了，在这种情况下交换的次数明显也会减少很多，所以它的时间复杂度在理想状态下可以减少到 O(log2n)2 的水平。</p><h2>总结</h2><p>排序的入门餐怎么样？我们可不是直接就拿烂大街的冒泡和快排上手的吧。不出名不意味着不会用到，比如我面试的时候曾经有个公司就是在面试题上写明了不能使用冒泡和快排。这时候，我相信简单插入排序直观好理解的特性一定就能帮助我们度过这种面试难关了哦！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/7.%E6%8E%92%E5%BA%8F/source/7.1%E6%8F%92%E5%85%A5%E7%B1%BB%E6%8E%92%E5%BA%8F%EF%BC%9A%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/7.排序/source/7.1插入类排序：简单插入、希尔排序.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>本文示例选自 《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2020-06-25 13:50:19', 1);
INSERT INTO `zy_articles_xs_test` VALUES (19, '【PHP数据结构与算法7.2】交换排序：冒泡、快排（有彩蛋）', '<h1>交换排序：冒泡、快排</h1><p>上篇文章中我们好好地学习了一下插入类相关的两个排序，不过，和交换类的排序对比的话，它们真的只是弟弟。甚至可以说，在所有的排序算法中，最出名的两个排序都在今天要介绍的交换排序中了。不管是冒泡、还是快排，都是面试中的常见排序算法，常见到什么地步呢？但凡学习数据结构和算法，甚至是你完全没有学习过，也多少都会听说过这两个排序算法。而一些大中型公司更是直接在面试题中指明不要使用这两种算法来实现一些排序的题目，这又是为什么呢？那当然也是因为这两个算法实在是太出名了，很多人都随便就能手写出来。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>当然，不管你面试的公司有什么要求，只要是有志在编程开发这个行业里发展的同学，冒泡和快排肯定会是面试中绕不开的一个坎。我们今天就来好好地学习一下这两个排序算法。不过首先还是要搞明白这个“交换”指的是什么意思。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上篇文章中的插入排序，指的是直接将数据插入到指定的位置。而交换的意思，则是让两个位置的数据在进行比对后直接交换。比如我们有 [3, 1, 2] 这样一个数组，需要排列成 [1, 2, 3] 这种形式。那么我们就可以先让 3 和 1比较，发现 1 小，于是将 3 和 1 的位置进行交换，结果是 [1, 3, 2] 。然后再让 3 和 2 比较，发现 2 小，再交换它们的位置，于是得到结果为 [1, 2, 3] 的数组。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>当然，这个示例只是简单地说明了一下交换排序的原理。但万变不离其宗，不管是冒泡还是快排，它们的基本原理和核心思想都是这样的，让两个数据对比后根据规则交换位置。这里其实从代码中我们能够从一个地方很快地分辨出一段排序代码是否是交换排序，那就是他们会有一个对于两个元素进行数据交换的过程，而且往往在普通情况下会使用一个中间变量。这个我们一会看代码就可以看到。</p><h2>冒泡排序</h2><p>冒泡排序，先从名字来理解一下，它的意思其实是让数据像汽水中的泡泡一样一个一个的浮上来。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>直接上代码了来看看，代码其实非常简单。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function BubbleSort($numbers)\n{\n    $n = count($numbers);\n\n    for ($i = 0; $i &lt; $n - 1; $i++) { // 外层循环 n - 1\n        for ($j = 0; $j &lt; $n - $i - 1; $j++) { // 内层循环 n - 1 - i\n            if ($numbers[$j] &gt; $numbers[$j + 1]) { // 两两相比来交换\n                $temp = $numbers[$j + 1];\n                $numbers[$j + 1] = $numbers[$j];\n                $numbers[$j] = $temp;\n            }\n        }\n    }\n\n    print_r($numbers);\n}\n\nBubbleSort($numbers);\n// Array\n// (\n//     [0] =&gt; 13\n//     [1] =&gt; 27\n//     [2] =&gt; 38\n//     [3] =&gt; 49\n//     [4] =&gt; 49\n//     [5] =&gt; 65\n//     [6] =&gt; 76\n//     [7] =&gt; 97\n// )</code></pre></div><p>光看代码自己推演的话其实还是不太好理解，那么我们就还是使出终极杀器，也就是图解步骤来看一下吧！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/fdad28f7aa18e66cf3b55ad824655148.jpg\" alt=\"//img1.zyblog.com.cn/old/fdad28f7aa18e66cf3b55ad824655148.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在代码中可以看到，我们有两层循环。所以这个图片中我们也是展示了 i 和 j 的两层循环情况。当然，限于篇幅，我们只展示了第一次 i 循环内部的 j 循环情况，也就是 i = 0 时，里面的 j 循环执行的情况。</p><ul><li><p>i = 0 是，内部的 j &lt; n - 1 - i ，也就是内部的 j 要循环七次。我们直接就看右边的 j 循环的步骤。</p></li><li><p>冒泡排序其实就是利用 j 和 j + 1 来对比两个相邻的元素。从图中我们就可以看出，每一次 j++ 都是在对当前 j 和下一个 j + 1 的元素进行比较。如果当前的这个 j 大于 j + 1 的话，就把它们交换位置。</p></li><li><p>当 j = 0 时，第 0 个位置的 49 是大于第 1 个位置的 38 的，于是 49 和 38 交换了位置。</p></li><li><p>当 j = 1 时，位置 1 的 49 和位置 2 的 65 相比，没有达成条件，于是不会变动。同理，j = 2 时也是对比的 65 和 97 ，同样不会发生交换。</p></li><li><p>当 j = 3 时，97 比 76 要大，于是发生了交换，97 交换到 j + 1 也就是下标 4 的位置。同时，97 也是整个序列中最大的数，于是后面会一直交换到这次的 j 循环结束。</p></li><li><p>最终的结果是 97 这个最大的数移动到了数据的最后一位。也就是说，最大的数已经放到了整个序列中的正确的位置上了。</p></li><li><p>接着内层循环结束，i++ ，开始第二次 i = 1 的内部 j 循环。这里需要注意的是，为什么我们要用 j &lt; n - 1 - i 呢？因为我们前面已经完成了一个最大数的排序，就是将 97 这个最大数放到了最后的位置上。所以在 i++ 的第二次循环时，我们就要将第二大的数放在倒数第二的位置上。这时的 j 也不需要循环到最后一位了，只需要循环到倒数第二位就可以了。</p></li></ul><p>从上面的分步讲解中，我们可以看到，外层的 i 每一次的循环其实就是通过内层的 j 循环来将一个最大的数按顺序放到后面的位置上。就像汽水不断地向上冒泡一样，它就是传说中的冒泡排序算法概念的由来。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>其实关于冒泡排序的算法，还有一个口决是很多同学都知道的，也可以帮助我们记忆。</p><ul><li><p>外层循环 N 减一</p></li><li><p>内层循环 N 减一减 I</p></li><li><p>两两相比小靠前（正序）</p></li></ul><p>为什么小的靠前是正序呢？在代码中，我们 if 条件判断是的 j &gt; j+1 ，如果成立就交换它们，也就是让大的数据放到了后面，小的数据放到了前面，这样一轮过后，最大的数据放在了最后一位，也就是完成了一个最大数据的位置的确定。如果我们将条件反过来，也就是 j &lt; j+1 的话，就会让最大的数据放到最前面，也就是实现了倒序。是不是很神奇？小伙伴们可以试试哦，就改变一下 if 条件的大于号就可以了哦。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>冒泡的时间复杂度其实很明显地就能看出来，O(N2)。属于效率一般但非常好理解的一种算法，而且它是一个稳定的排序算法。</p><h2>快速排序</h2><p>冒泡的感觉咋样？不过冒泡有个问题，那就是它只能对相邻的两个数据进行比较，所以 O(N2) 这个时间复杂度基本也就不包含什么最好最坏的情况了，不管怎么它都得要达到这个 O(N2) 的水平。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>那么有没有什么别的方法能够对冒泡进行优化呢？有大佬就发明出了优化冒泡的一种排序算法啦。那就是快速排序算法。还记得在学习查找的时候我们学习过的二分查找吗？相对于线性查找来说，二分查找的效率是不是提升了很多。但快速排序的效率提升可达不到那么高，毕竟排序还是比查找要复杂些。而且它是在冒泡的基础上进行的改良，同样也使用了二分的思想，也就是分而治之的一种理念。让每次的比较不再只是两个相邻的元素一个一个地比较。所以它的平均时间复杂度可以提升到 O(NlogN) 的级别。相对于 O(N2) 来说，这个时间复杂度其实也有了不小的飞跃哦。特别是数据量越大的情况下越明显。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>同样我们先来看看代码，然后再来看图分析这个算法。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function QSort(&amp;$arr, $start, $end)\n{\n    if ($start &gt; $end) {\n        return;\n    }\n    $key = $arr[$start];\n    $left = $start;\n    $right = $end;\n    \n    while ($left &lt; $right) {\n        // 右边下标确定\n        while ($left &lt; $right &amp;&amp; $arr[$right] &gt;= $key) {\n            $right--;\n        }\n        // 左边下标确定\n        while ($left &lt; $right &amp;&amp; $arr[$left] &lt;= $key) {\n            $left++;\n        }\n        if ($left &lt; $right) { // 交换步骤\n            $tmp = $arr[$left];\n            $arr[$left] = $arr[$right];\n            $arr[$right] = $tmp;\n        }\n    }\n\n    $arr[$start] = $arr[$left];\n    $arr[$left] = $key;\n    // 递归左右两边继续\n    QSort($arr, $start, $right - 1);\n    QSort($arr, $right + 1, $end);\n}\n\nfunction QuickSort($numbers)\n{\n    QSort($numbers, 0, count($numbers) - 1);\n    print_r($numbers);\n}\n\nQuickSort($numbers);\n// Array\n// (\n//     [0] =&gt; 13\n//     [1] =&gt; 27\n//     [2] =&gt; 38\n//     [3] =&gt; 49\n//     [4] =&gt; 49\n//     [5] =&gt; 65\n//     [6] =&gt; 76\n//     [7] =&gt; 97\n// )</code></pre></div><p>有没有发现熟悉的身影？没错，快速排序使用到了递归。这个递归其实也包含着分治的思想，就像秦国统一六国一样，分而治之。我们将某一个数据放到指定的位置之后再按左右分治的方式来继续其它的数据的排序，而不用让其它的数据再对整个序列进行完整的判断，从而提高排序的效率。因此，快排的时间复杂度相对冒泡来说就好了很多。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/e6afa93a1138769cdfc6099ca57114a7.jpg\" alt=\"//img1.zyblog.com.cn/old/e6afa93a1138769cdfc6099ca57114a7.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>同样地，它表面上是不停地递归，其实递归也是一种循环，我们就可以看出来，它和冒泡一样其实是有着两层循环的概念的。这里我们也是以第一次的外层循环为例子来剖析它的内层循环都做了什么。</p><ul><li><p>首先，我们确定了一个关键字 key ，这里我们就直接指定第一个数据 49 。然后指定左右两个指针，左指针 left 从 0 开始，右指针 right 从最右边的下标开始。</p></li><li><p>进入内层循环，条件是 left &lt; right ，也就是左右两个指针不能相遇！</p></li><li><p>开始指针移动，先从右边开始，如果 right 指向的数据大于等于 key ，right 就进行减减操作，否则，指针就停住。可以看到，我们的指针停在了 27 这个数据的位置，也就是倒数第二个数据这里，第一个数据 49 和我们的 key 值 49 是一样的，于是 right 就移动到倒数第二个数据了，27 是小于 key 值的。</p></li><li><p>然后移动 left 指针，移动到符合条件的位置也就是值为 65 的这个下标，然后交换 left 和 right 的值。</p></li><li><p>继续后续的操作，直到 left 和 right 相遇了，这时退出循环，并在循环外面再次交换 key 和 left 位置的值。这时，第一个下标的 49 这个值就已经放到了它所确定的位置。也就是说，这个值完成了排序。</p></li><li><p>接着，以这个完成排序的值为中心，切分左右两个序列，继续进入递归排序的过程，直到所有数据完成排序。</p></li></ul><p>看出快速排序和冒泡排序的区别了吧？快排的每趟排序都会确定一个关键字的具体位置，它的比较除了第一次是每个数都和 key 两两比较之外，其它都是采用分治的思想来缩小 n 的大小进行小范围的排序的。而且每次的循环都会将数据按针对 key 值的大小进行左右排列，这也是二叉搜索树的核心思想。这个内容我们的系列文章中没有讲解，大家可以自行查阅相关的资料学习。</p><h2>小彩蛋：交换两个变量的值</h2><p>今天学习的内容中都有一处核心的代码，就是最开始我们说过的交换两个变量值的代码。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 冒泡中\n$temp = $numbers[$j + 1];\n$numbers[$j + 1] = $numbers[$j];\n$numbers[$j] = $temp;\n\n// 快排中\n$tmp = $arr[$left];\n$arr[$left] = $arr[$right];\n$arr[$right] = $tmp;</code></pre></div><p>我们都使用到了一个临时变量来进行交换。不过不少的面试题中经常会看到一种题目就是不使用第三个变量，也就是这个临时变量来交换两个变量的值。大家有没有踫到过呢？其实有几种方案都可以，我们就来简单说两个。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$a = 1;\n$b = 2;\n$a += $b; // a = 3\n$b = $a - $b; // b = 3 - 2 = 1 \n$a = $a - $b; // a = 3 - 1 = 2\necho $a, PHP_EOL; // 2\necho $b, PHP_EOL; // 1\n\n$a = \"a\";\n$b = \"b\";\n$a .= $b; // a = \"ab\"\n$b = str_replace($b, \"\", $a); // b = str_replace(\"b\", \"\", \"ab\") = a\n$a = str_replace($b, \"\", $a);// a = str_replace(\"a\", \"\", \"ab\") = b\necho $a, PHP_EOL; // b\necho $b, PHP_EOL; // a</code></pre></div><p>对于数字来说，直接使用第一段的加减操作就可以完成两个变量的交换。而对于字符串来说，就可以使用 str_replace() 来实现。其实它们的思想都是一样的，先合并到一个变量上，然后利用减法或者替换来让某一个变量先变成另一个变量的值。然后再使用相同的方法将另一个变量的值也转换成功。当然，这只是最简单最基础的一种算法，利用 PHP 的一些函数和特性，我们还可以更方便地实现这种功能。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$a = 1;\n$b = 2;\nlist($a, $b) = [$b, $a];\necho $a, PHP_EOL; // 2\necho $b, PHP_EOL; // 1</code></pre></div><p>list() 函数是将一个数组中的数据分别存入到指定的变量中，而在 PHP 中我们也可以直接 [x, x] 这样来定义数组。所以不使用第三个临时变量来交换两个变量的功能我们只用这一行代码就搞定了。 list($a, $b) = [$b, $a] 。这里不点赞可真对不起这道题咯！！</p><h2>总结</h2><p>交换排序的这两种算法相当于数据结构与算法这门课程的门面担当，但凡要讲算法中的排序的，必然会有它们两个的身影。毕竟太经典了，不过我们可是先学了两个插入类的排序进行过了热身才来学习这两个经典算法的，相信大家进行对比之后就能更深入地理解这些算法的神奇和不同。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/7.%E6%8E%92%E5%BA%8F/source/7.2%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%EF%BC%9A%E5%86%92%E6%B3%A1%E3%80%81%E5%BF%AB%E6%8E%92.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/7.排序/source/7.2交换排序：冒泡、快排.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>本文示例选自 《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2020-06-11 01:58:51', 1);
INSERT INTO `zy_articles_xs_test` VALUES (20, '【PHP数据结构与算法7.3】其它排序：简单选择、桶排序', '<h1>其它排序：简单选择、桶排序</h1><p>这是我们算法正式文章系列的最后一篇文章了，关于排序的知识我们学习了很多，包括常见的冒泡和快排，也学习过了不太常见的简单插入和希尔排序。既然今天这是最后一篇文章，也是排序相关的最后一篇，那我们就来轻松一些，再来学习两个非常简单的排序算法。</p><h2>简单选择排序</h2><p>首先是简单选择排序，它划分在了选择类排序下面，不过其实也可以看成是交换类的排序。因为它的核心代码中也是有交换操作的实现的。关于这个排序没有什么太多好说的，每次在遍历中找出最大或者最小的数据，然后将它放到相应的位置就可以了。我们先来看代码，然后再看图示的解析。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function SelectSort($numbers){\n    $n = count($numbers);\n    for( $i = 0 ; $i &lt; $n ; $i++){\n        $k = $i;\n        for( $j = $i+1 ; $j &lt; $n ; $j++){\n            if($numbers[$j] &lt; $numbers[$k]){\n                $k = $j;\n            }\n        }\n        if($k != $i){\n            list($numbers[$i], $numbers[$k]) = [$numbers[$k], $numbers[$i]];\n        }\n    }\n    echo implode(\', \', $numbers), PHP_EOL;\n}\nSelectSort($numbers);\n// 13, 27, 38, 49, 49, 65, 76, 97</code></pre></div><p>代码不复杂吧，可以注意到它也有交换代码的出现。我们使用的是上篇文章中的小彩蛋中的交换方式进行的数据位置的交换。它和冒泡以及快排那种专门的交换型排序算法还是有些许不同的，每次交换的 i 这个位置是不变的，什么意思呢？比如我们现在的 i 是 0 ，也就是说整个序列中最小的数据应该是要放在这个地方的。所以 j 循环是从 i + 1 的位置开始循环的，然后不停地和 i 这个位置的数据进行比较，并不断地更新 k （ k 在一开始是指定为 i 的）。找到最小的数据之后直接将这个数据和 i 的数据交换，这样最小的数据就放到了 i 的位置上了。这就是简单选择排序的核心思想。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这一大段说起来可能会看得比较懵圈。还是看看图吧！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/d3e196c4fc66745916595b2cdcd2a133.jpg\" alt=\"//img1.zyblog.com.cn/old/d3e196c4fc66745916595b2cdcd2a133.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们依然还是以第一趟的详细过程为例。</p><ul><li><p>k = i ，然后 j 从第二个数据开始遍历</p></li><li><p>如果发现 numbers[j] 小于 numbers[k] 的数据，也就是更小的数据，就让 k = j</p></li><li><p>j 循环遍历完成后，k 指向的下标就是最小那个数据，于是交换 k 和 i 的值</p></li><li><p>一趟排序下来，最小的数据就放到了最前面的位置了</p></li></ul><p>是不是感觉和冒泡有点像呀？确实是很像，冒泡也是一趟外层循环就可以把某个最大或者最小的值放到正确的位置上。不过需要注意的是，冒泡是前后两个数据相比，很有可能每次比较都会发生交换。而选择排序则是以一个下标指针的位置移动来确定数据，最后也只进行一次交换。所以说，它是有选择性的交换，而不是纯粹的一路交换到底。</p><h2>简单桶排序</h2><p>真正的桶排序还是比较复杂的，但今天我们学习的这个简单的桶排序则是真的简单的不行。它体现的是一种以空间换时间的方式，具体是怎么换的呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function BucketSort($numbers){\n    $bucketList = [];\n    $maxValue = max($numbers);\n    for($i=0;$i &lt;= $maxValue;$i++){\n        $bucketList[$i] = 0;\n    }\n    foreach($numbers as $n){\n        $bucketList[$n]++;\n    }\n    $sortList = [];\n    foreach($bucketList as $k =&gt; $v){\n        if($v &gt; 0){\n            for( ; $v &gt; 0 ; $v--){\n                $sortList[] = $k;\n            }\n        }\n    }\n    echo implode(\', \', $sortList), PHP_EOL;\n}</code></pre></div><p>如果是针对的数字类型的排序操作，特别是这个数字基数不大，比如说是类型枚举之类的数据，我们都可以使用这种桶排序的方式。首先我们要看当前最大的数字是几，然后初始化一个数组到这个最大数字的下标，并将所有内容设置为 0 。接着遍历原始的排序数组，给这个要排序数据对应的值加 1 。于是，待排序序列所代表的那些键的值都会变成 1 ，同时，如果有相同的数据，我们使用的是 ++ 操作，这个数据对应的键值就会继续加 1 。具体的过程就如下图所示：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/ac86ee5cfcfb5567610f74bc84d50059.jpg\" alt=\"//img1.zyblog.com.cn/old/ac86ee5cfcfb5567610f74bc84d50059.jpg\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>相信这个图已经说明得非常清晰了吧，也不需要我们再深入地解释了吧。这就是这种最简单的桶排序方式，我们也可以将这个桶数组的内容换成二维数据，这样我们就可以实现更复杂数据的排序操作了。不过还是要注意，一定是针对数字类型的哦。我们介绍的这种桶排序其实是真正的桶排序的一种变体，也有人叫它为“计数排序”。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>真正更加完备一些的桶排序其实是先将数据分成不同的组，每个组可以看成是一个桶。然后在这个桶内将组内的数据排序，排序完成之后再将这些组（桶）连接起来。它的时间复杂度是接近于 O(n) 的。不过就像我们介绍的这个最简单的桶排序一样，复杂的桶排序也是有许多严苛的要求的，所以虽然它的效果很高，但却并不常见。</p><h2>总结</h2><p>今天的内容非常简单吧，简单选择其实也是一种交换排序，但它在大类中还是划归到了选择排序这个类型中。而桶排序是属于基数排序的一种。各种排序其实还有很多，但除了我们学习的这些之外，其它的都会更加的复杂也并不常见，大家有兴趣的可以在下期我们的总结文章中了解到有哪些可以继续深入学习的内容。精彩还在继续，不要错过哦！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/7.%E6%8E%92%E5%BA%8F/source/7.3%E5%85%B6%E5%AE%83%E6%8E%92%E5%BA%8F%EF%BC%9A%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F.php\">https://github.com/zhangyue0503/Data-structure-and-algorithm/blob/master/7.排序/source/7.3其它排序：简单选择、桶排序.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《啊哈！算法》</p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2021-04-17 16:08:32', 1);
INSERT INTO `zy_articles_xs_test` VALUES (21, '【PHP数据结构与算法8】PHP数据结构及算法总结', '<h1>PHP数据结构及算法总结</h1><p>断断续续地把这个系列写完了，就像上一个设计模式一样，算法这个系列也是前前后后写了将近有一年的时间。当然，都是在业余或者晚上的时间写完的，所以进度如此地慢。更主要的是，既然要写，总得要自己先弄懂吧，对于一个没上过高中的人来说，这还真的是有点困难。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>所以说，在这一系列的文章中，可能有许多纰漏甚至是错误，这个也欢迎大家随时指正。</p><h2>继续扩展提高</h2><p>关于数据结构与算法这门课程，在我的系列文章中，只是简单的入了个门。仅仅从教材来说，就还有许多内容并没有涉及，实在是本人水平有限，大家可以自己再继续深入地学习。</p><ul><li><p>串：字符串、串的匹配（BF、KMP）</p></li><li><p>树：二叉排序树、平衡二叉树、哈夫曼树、B+树、B-树、红黑树</p></li><li><p>图：拓扑排序、关键路径</p></li><li><p>查找：分块查找、黄金查找</p></li><li><p>排序：希尔排序、树形选择排序、堆排序、归并排序、基数排序、外部排序（多路平衡归并排序、置换-选择排序、最挂归并树）</p></li></ul><h2>参考资料</h2><p>本系列的学习参考书目为：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，严蔚敏</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构》第二版，陈越</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《数据结构高分笔记》2020版，天勤考研</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《啊哈！算法》</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《算法图解》</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《枕边算法书》</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考音视频资料为：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.icourse163.org/course/ZJU-93001\">《数据结构》Mooc，浙大，陈越</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.bilibili.com/video/BV1jW411K7yg\">《小甲鱼数据结构与算法视频》</a></p>', 'PHP', '数据结构,算法', '2022-07-23 18:06:28', '2021-12-10 23:06:22', 1);
INSERT INTO `zy_articles_xs_test` VALUES (23, 'PHP中比较数组的时候发生了什么？', '<h1>PHP中比较数组的时候发生了什么？</h1><p>首先还是从代码来看，我们通过比较运算符号来对两个数组进行比较：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nvar_dump([1, 2] == [2, 1]); // false\n\nvar_dump([1, 2, 3] &gt; [3, 2, 1]); // false\n\nvar_dump([5, 6, 7] &gt; [1, 2, 3, 4]); // false\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>第一组：仔细看，从一眼看过去的正常角度来说，代码中对比的数组其实是一样的数组，[1, 2]和[2, 1]都是两个包含两个元素的数组，元素内容也是一样的，但是，他们的位置不一样。</p><p>第二组：同样是位置不一样，[1, 2, 3]是小于[3, 2, 1]的</p><p>第三组：[5, 6, 7]每个元素都大于[1, 2, 3, 4]，但结果是没有后一个数组大。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>相信不少同学已经看出一些端倪了。数组之间的操作符比较是先进行元素数量对比，然后再对比每个键值。官方文档上的解释为：</p><blockquote><p>具有较少成员的数组较小，如果运算数 1 中的键不存在于运算数 2 中则数组无法比较，否则挨个值比较</p></blockquote><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n&lt;?php\n// 数组用标准比较运算符这样比较的\nfunction standard_array_compare($op1, $op2)\n{\n    if (count($op1) &lt; count($op2)) {\n        return -1; // $op1 &lt; $op2\n    } elseif (count($op1) &gt; count($op2)) {\n        return 1; // $op1 &gt; $op2\n    }\n    foreach ($op1 as $key =&gt; $val) {\n        if (!array_key_exists($key, $op2)) {\n            return null; // uncomparable\n        } elseif ($val &lt; $op2[$key]) {\n            return -1;\n        } elseif ($val &gt; $op2[$key]) {\n            return 1;\n        }\n    }\n    return 0; // $op1 == $op2\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>上述代码就是php中使用比较操作符进行数组比较时的代码，首先是count数组的元素数量，如果数组1大于数组2就返回1，否则返回-1。如果相等的话，遍历每一个元素进行对比，如果数组1的某个键值不存在在数组2中，返回null，如果数组1的某个键的值大于数组2的这个键的值，返回1，否则返回-1。遍历的元素也都相同的情况下，最后返回0表示相等。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>使用普通的比较操作符对比键值对形式的数组效果会好一些，因为是以固定的键来进行比对，不是以数组下标：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nvar_dump([\'a\'=&gt;1, \'b\'=&gt;2] == [\'b\'=&gt;2, \'a\'=&gt;1]); // ture\nvar_dump([\'a\'=&gt;1, \'b\'=&gt;2] == [\'a\'=&gt;2, \'b\'=&gt;1]); // false\n\n\nvar_dump([\'a\' =&gt; 1, \'b\' =&gt; 5] &lt; [\'a\' =&gt; 2, \'b\' =&gt; 1]); // true\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>注意第三条比较，我们的第一个数组的b元素是大于第二个数组的，但通过上面的数组比较代码可以看出，当第一个元素比较结果已经出现了大于小于的情况时，直接就return返回了结果，后面的元素不会再进行比较了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>那么多维数组呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nvar_dump([[\'aa\' =&gt; 1], [\'bb\' =&gt; 1, \'dd\'=&gt;2]] == [[\'aa\' =&gt; 2], [\'bb\' =&gt; 1]]); // false\nvar_dump([[\'aa\' =&gt; 1], [\'bb\' =&gt; 1, \'dd\'=&gt;2]] &lt; [[\'aa\' =&gt; 2], [\'bb\' =&gt; 1]]); // true\nvar_dump([[\'aa\' =&gt; 1], [\'bb\' =&gt; 1, \'dd\'=&gt;2]] &lt; [[\'aa\' =&gt; 1, \'cc\' =&gt; 1], [\'bb\' =&gt; 1]]); // true\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>子数组会递归进行比较，比较规则依然是按照默认的数组操作符比较方式进行。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>弄清楚了数组的比较是如何进行的，那么问题来了，假设前端传给我们的数据是这样的：</p><div data-language=\"json\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"json\">\n[\n    \'John\',\n    \'178cm\',\n    \'62kg\',\n]\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>而我们数据库里存的是：</p><div data-language=\"josn\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"josn\">\n[\n    \'62kg\',\n    \'John\',\n    \'178cm\',\n]\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>这时如果直接比对两个数组内容，或者直接用json字符串比对，他们都是不相同的，这可怎么办呢？试试自定义一个对比方法吧！</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction array_equal($a, $b)\n{\n    return (is_array($a) &amp;&amp; is_array($b) &amp;&amp; array_diff($a, $b) === array_diff($b, $a));\n}\n\n$arr1 = [\n    \'John\',\n    \'178cm\',\n    \'62kg\',\n];\n$arr2 = [\n    \'62kg\',\n    \'John\',\n    \'178cm\',\n];\n\nvar_dump(array_equal($arr1, $arr2)); // true\n\n// 元素不一样的话\n$arr2 = [\n    \'62kg\',\n    \'John Jobs\',\n    \'178cm\',\n];\nvar_dump(array_equal($arr1, $arr2)); // false\n\n// 再弄乱一点\n$arr1 = [\n    [\n        \'55kg\',\n        \'Bob\',\n        \'172cm\',\n        [\n            \'employee\',\n        ],\n    ],\n    [\n        \'John\',\n        \'178cm\',\n        \'62kg\',\n        [\n            \'manager\',\n        ],\n    ],\n];\n$arr2 = [\n    [\n        \'62kg\',\n        \'John\',\n        \'178cm\',\n        [\n            \'manager\',\n        ],\n    ],\n    [\n        [\n            \'employee\',\n        ],\n        \'55kg\',\n        \'172cm\',\n        \'Bob\',\n\n    ],\n];\nvar_dump(array_equal($arr1, $arr2)); // true</code></pre></div><p>其实就是利用了array_diff()这个函数，它的作用是取两个数组的差集，然后再对比两个数组差集的结果来判断两个数组是否相等。这个方法适用于下标数组的比对，但不适用于键值对数组的比对，array_diff()只是取值的差集结果集，不会比对键，所以对于键值对的数组直接使用比较操作符就好啦！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><strong>对于数组的比较我们只要弄清楚它的原理就可以了，如果原理不清楚很可能就会埋下隐藏的BUG。数组的比较一定要记住这三点：</strong></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>1.<strong>先比较元素数量</strong></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>2.<strong>再比较每一个元素（多维数组递归比较）</strong></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>3.<strong>先后顺序，第一个有比较结果了后面就不会继续比较了，全部都相等才会返回相等</strong></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：<a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201910/source/PHP%E4%B8%AD%E6%AF%94%E8%BE%83%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201910/source/PHP%E4%B8%AD%E6%AF%94%E8%BE%83%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考链接：<a href=\"https://www.php.net/manual/zh/language.operators.comparison.php\">https://www.php.net/manual/zh/language.operators.comparison.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:28', '2020-11-14 23:41:10', 1);
INSERT INTO `zy_articles_xs_test` VALUES (24, 'PHP中的强制类型转换', '<h1>PHP中的强制类型转换</h1><p>学过静态语言开发的朋友对类型转换不会陌生，比如Java、C#、C++等。静态语言的好处就是变量强制必须指定类型，这也是编译的要求，所以大部分编译型的语言都会有强制变量类型的要求。而PHP据说也会在PHP8中加入JIT实现编译功能，并且在7.4中就会引入变量声明时的类型指定。下面我们先看看目前PHP中的参数类型及返回值类型的使用。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction add(int $a, float $b) : int{\n    return (int) $a + $b;\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>上述代码中，方法参数中定义了参数的类型，包括一个int类型的$a和一个float类型的$b。然后在方法后面定义了方法的返回值必须是int类型。我们知道，如果计算表达式中出现了float类型，那么计算结果会变成float类型。这个方法需要返回的是一个int类型。因此我们使用了一个强制类型转换(int)。在定义了参数类型和返回值类型后，如果传递或者返回的类型不一致，就会报错。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参数类型和返回值类型最好在7以上的版本使用。基本类型如int、float等的参数类型声明都是7以后才支持的，详情参见文档：<a href=\"https://www.php.net/manual/zh/functions.arguments.php\">https://www.php.net/manual/zh/functions.arguments.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们通过(int)、(float)、(bool)等就可以实现PHP的类型强制转换，和C基本上一样。文档中关于可以强制转换的包括如下类型：</p><ul><li><p>(int), (integer) - 转换为整形 integer</p></li><li><p>(bool), (boolean) - 转换为布尔类型 boolean</p></li><li><p>(float), (double), (real) - 转换为浮点型 float</p></li><li><p>(string) - 转换为字符串 string</p></li><li><p>(array) - 转换为数组 array</p></li><li><p>(object) - 转换为对象 object</p></li><li><p>(unset) - 转换为 NULL (PHP 5)</p></li><li><p>(binary) 转换和 b 前缀转换支持为 PHP 5.2.1 新增</p></li></ul><blockquote><p>(int), (integer)</p></blockquote><ul><li><p>如果是布尔值，转换结果为false变成0，true变成1</p></li><li><p>如果是float，向下取整，如7.99会转换为7</p></li><li><p>如果是字符串，字符串从头开始查找，开头第一个是数字会直接变成该转换结果，如果开头没有数字返回0</p></li><li><p>其他类型转换在文档中并没有定义，文档提示为“没有定义从其它类型转换为整型的行为。不要依赖任何现有的行为，因为它会未加通知地改变。”，但我们通过测试，可以发现对于其他类型的转换是通过多次的类型转换达成的，比如数组类型转换为int类型，是根据数组是否包含内容转换为bool类型后再转换为int类型</p></li></ul><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n// (int)(integer)\n\nvar_dump((int) true); // 1\nvar_dump((int) false); // 0\n\nvar_dump((int) 7.99); // 7\n\nvar_dump((int) \"35 ok\"); // 35\nvar_dump((int) \"ok 77\"); // 0\nvar_dump((int) \"ok yes\"); // 0\n\nvar_dump((int) []); // 0\nvar_dump((int) [3,4,5]); // 1\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><blockquote><p>(bool)(boolean)</p></blockquote><p>当转换为 boolean 时，以下值被认为是 FALSE：</p><ul><li><p>布尔值 FALSE 本身</p></li><li><p>整型值 0（零）</p></li><li><p>浮点型值 0.0（零）</p></li><li><p>空字符串，以及字符串 \"0\"</p></li><li><p>不包括任何元素的数组</p></li><li><p>特殊类型 NULL（包括尚未赋值的变量）</p></li><li><p>从空标记生成的 SimpleXML 对象</p></li></ul><p>所有其它值都被认为是 TRUE（包括任何资源 和 NAN）</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这里需要注意的是，负数也会是TRUE，只有0是FASLE</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n// (bool)(boolean)\n\nvar_dump((bool) 0); // false\nvar_dump((bool) 1); // true\nvar_dump((bool) -1); // true\n\nvar_dump((bool) 0.0); // false\nvar_dump((bool) 1.1); // true\nvar_dump((bool) -1.1); // true\n\nvar_dump((bool) \"\"); // false\nvar_dump((bool) \"0\"); // false\nvar_dump((bool) \"a\"); // true\n\nvar_dump((bool) []); // false\nvar_dump((bool) [\'a\']); // true\n\n$a;\nvar_dump((bool) $a); // false\nvar_dump((bool) NULL); // false\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><blockquote><p>(string)</p></blockquote><ul><li><p>布尔值，false转换为空字符串\"\"，true转换为\"1\"</p></li><li><p>int或float类型，转换为字符串形式的字面量，如1转换为\"1\"</p></li><li><p>数组和对象分别转换为\"Array\"和\"Object\"字面量</p></li><li><p>资源类型会被转换为\"Resource id #1\"形式的字面量</p></li><li><p>NULL转换为空字符串\"\"</p></li></ul><p>直接把 array，object 或 resource 转换成 string 不会得到除了其类型之外的任何有用信息。可以使用函数 print_r() 和 var_dump() 列出这些类型的内容</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>注：测试结果，对象类型需要实现__tostring()魔术函数，否则报错无法转换为string类型</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n// (string)\n\nvar_dump((string) true); // \"1\"\nvar_dump((string) false); // \"\"\n\nvar_dump((string) 55); // \"55\"\nvar_dump((string) 12.22); // \"12.22\"\n\nvar_dump((string) [\'a\']); // \"Array\"\nclass S{\n    function __tostring(){\n        return \"S\";\n    }\n}\nvar_dump((string) new S()); // \"S\"\n\nvar_dump((string) NULL); // \"\"\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><blockquote><p>(array)</p></blockquote><p>对于任意 integer，float，string，boolean 和 resource 类型，如果将一个值转换为数组，将得到一个仅有一个元素的数组，其下标为 0，该元素即为此标量的值。换句话说，(array)$scalarValue 与 array($scalarValue) 完全一样</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>如果一个 object 类型转换为 array，则结果为一个数组，其单元为该对象的属性。键名将为成员变量名，不过有几点例外：整数属性不可访问；私有变量前会加上类名作前缀；保护变量前会加上一个 \'*\' 做前缀。这些前缀的前后都各有一个 NULL 字符</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>将 NULL 转换为 array 会得到一个空的数组</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n// (array)\n\nvar_dump((array) 1);\nvar_dump((array) 2.2);\n\nvar_dump((array) \"a\");\n\nvar_dump((array) true);\n\nclass Arr\n{\n    public $a = 1;\n    private $b = 2.2;\n    protected $c = \"f\";\n}\nclass ChildArr extends Arr\n{\n    public $a = 2;\n    private $d = \"g\";\n    private $e = 1;\n}\nvar_dump((array) new Arr());\nvar_dump((array) new ChildArr());\n\nvar_dump((array) null);\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><blockquote><p>(object)</p></blockquote><p>如果将一个对象转换成对象，它将不会有任何变化。如果其它任何类型的值被转换成对象，将会创建一个内置类 stdClass 的实例。如果该值为 NULL，则新的实例为空。 array 转换成 object 将使键名成为属性名并具有相对应的值</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>注意：使用 PHP 7.2.0 之前的版本，数字键只能通过迭代访问</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n// (object)\n\nvar_dump((object) 1);\nvar_dump((object) 1.1);\nvar_dump((object) \"string\");\nvar_dump((object) true);\nvar_dump((object) NULL);\n\nvar_dump((object) [1, 2, 3]);\nvar_dump((object) [\"a\" =&gt; 1, \"b\" =&gt; 2, \"c\" =&gt; 3]);\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><blockquote><p>(unset)</p></blockquote><p>使用 (unset) $var 将一个变量转换为 null 将不会删除该变量或 unset 其值。仅是返回 NULL 值而已</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n// (unset)\n\nvar_dump((unset) 1);\nvar_dump((unset) 1.1);\nvar_dump((unset) \"string\");\nvar_dump((unset) true);\nvar_dump((unset) null);\n\nvar_dump((unset) [1, 2, 3]);\nvar_dump((unset) new \\stdClass());\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><blockquote><p>(binary)</p></blockquote><p>将所有类型转换为二进制字符串。二进制字符串是区别于传统常用的普通php的Unicode字符串。二进制字符串是字节字符串，没有字符集。具体的区别就类似于数据库中的binary和char类型及blob和text类型</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在日常的开发中基本用不到，了解即可</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n// (binary)\n\nvar_dump((binary) 1);\nvar_dump((binary) 1.1);\nvar_dump((binary) \"string\");\nvar_dump((binary) true);\nvar_dump((binary) null);\n\nvar_dump((binary) [1, 2, 3]);\nvar_dump((binary) new S());\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>以上就是我们的强制类型转换的所有类型，其中有一些类型的转换中提到了资源类型（Resource），但是并没有资源类型的强制转换。因为资源类型大多是一些句柄操作，如数据库链接、文件读写等，将其它类型强制转换为资源类型没有意义。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>本文内容会经常出现在面试题中，而且在实际开发中的很多逻辑判断出现的BUG也常常是由于PHP的自动类型转换所导致的，所以这篇文章好好收藏多拿出来看看绝对会让你有意想不到的收获哦！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201910/source/php%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201910/source/php%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.types.type-juggling.php#language.types.typecasting\">https://www.php.net/manual/zh/language.types.type-juggling.php#language.types.typecasting</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:28', '2020-01-18 03:34:15', 1);
INSERT INTO `zy_articles_xs_test` VALUES (25, 'PHP的变量赋值', '<h1>PHP的变量赋值</h1><p>这个标题估计很多人会不屑一顾，变量赋值？excuse me？我们学开发的第一课就会了好不好。但是，就是这样基础的东西，反而会让很多人蒙圈，比如，值和引用的关系。今天，我们就来具体讲讲。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>首先，定义变量和赋值这个不用多说了吧</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$a = 1;\n$b = \'2\';\n$c = [4, 5, 6];\n$d = new stdClass();\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>四个变量，分别定义了整型、字符串、数组的对象。这也是我们天天要打交道的四种类型。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>然后，变量给变量赋值。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$a1 = $a;\n$b1 = $b;\n$c1 = $c;\n$d1 = $d;\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>请注意，前三个的赋值都是正常的赋值，也就是对具体内容的拷贝。当我们修改$a1的时候$a不会有变化。$a1是新开的内存空间保存了我们的值。也就是说，他们的值是一样的，但内存地址不一样。是两个没啥关系的长得很像的人而已。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>但是$d1和$d就不是了，这两货不仅值是一样的，内存地址也是一样的。这种情况就是我们所说的引用赋值。当$d1发生变化时，$d2也会产生变化。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>可以这么说：<strong>引用赋值就是为原变量建立了一个Windows下的快捷方式或者Linux中的软链接。</strong></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>用具体的例子来说明，首先是普通值的赋值：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n// 普通赋值\n$v = \'1\';\n$c = $v;\n$c = \'2\';\necho $v, PHP_EOL; // \'1\'\n\n// 数组也是普通赋值\n$arr1 = [1,2,3];\n$arr2 = $arr1;\n$arr2[1] = 5;\nprint_r($arr1); // [1, 2, 3]\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>$c不会对$v的值产生影响。$arr2修改了下标1，也就是第二个数字为5，当然也不会对$arr1产生影响。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>那么对象形式的引用赋值呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n// 对象都是引用赋值\nclass A {\n    public $name = \'我是A\';\n}\n\n$a = new A();\n$b = $a;\n\necho $a-&gt;name, PHP_EOL; // \'我是A\'\necho $b-&gt;name, PHP_EOL; // \'我是A\'\n\n$b-&gt;name = \'我是B\';\necho $a-&gt;name, PHP_EOL; // \'我是B\'\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>果然不出所料，$b修改了name属性的内容后，$a里面的name也变成了$b所修改的内容。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在这种情况下，如果对象想要不是引用传递的，一是使用__clone()，也就是原型模式来进行自己的拷贝。二是从外面重新new一个呗。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n// 使用克隆解决引用传递问题\nclass Child{\n    public $name = \'我是A1的下级\';\n}\nclass A1 {\n    public $name = \'我是A\';\n    public $child;\n\n    function __construct(){\n        $this-&gt;child = new Child();\n    }\n\n    function __clone(){\n        $this-&gt;name = $this-&gt;name;\n        // new 或者用Child的克隆都可以\n        // $this-&gt;child = new Child();\n        $this-&gt;child = clone $this-&gt;child;\n    }\n}\n\n$a1 = new A1();\n\necho $a1-&gt;name, PHP_EOL; // 输出a1原始的内容\necho $a1-&gt;child-&gt;name, PHP_EOL;\n\n$b1 = $a1;\necho $b1-&gt;name, PHP_EOL; // b1现在也是a1的内容\necho $b1-&gt;child-&gt;name, PHP_EOL;\n\n$b1-&gt;name = \'我是B1\'; // b1修改内容\n$b1-&gt;child-&gt;name = \'我是B1的下级\';\necho $a1-&gt;name, PHP_EOL; // a1变成b1的内容了\necho $a1-&gt;child-&gt;name, PHP_EOL;\n\n// 使用__clone\n$b2 = clone $b1; // b2克隆b1\n$b2-&gt;name = \'我是B2\'; // b2修改内容\n$b2-&gt;child-&gt;name = \'我是B2的下级\';\necho $b1-&gt;name, PHP_EOL; // b1不会变成b2修改的内容\necho $b1-&gt;child-&gt;name, PHP_EOL;\necho $b2-&gt;name, PHP_EOL; // b2修改的内容没问题，b1、b2不是一个货了\necho $b2-&gt;child-&gt;name, PHP_EOL;\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>对象的引用这一块确实会容易让人蒙圈。特别是更加复杂的对象，内部的属性还有各种引用其他对象的时候。这种情况下一定要仔细确认引用赋值会不会带来问题，如果有问题，就使用新对象或者克隆技术进行引用问题的处理。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>最后，轻松一下，引用变量的赋值就和我们给方法传引用参数一样的，使用一个&amp;符号就可以啦！</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n// 引用赋值\n$b = &amp;$v;\n$b = \'3\';\necho $v, PHP_EOL;\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>今天我们更深入的学习和了解了一下PHP中的赋值问题，特别是普通赋值和引用赋值的问题。下回看代码和框架的时候可以注意注意别人是怎么灵活使用这两种赋值的哈，自己也能试试能不能运用这两种方式改造下自己曾经写过的BUG哦！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201910/source/PHP%E7%9A%84%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201910/source/PHP%E7%9A%84%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.variables.basics.php\">https://www.php.net/manual/zh/language.variables.basics.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.oop5.cloning.php\">https://www.php.net/manual/zh/language.oop5.cloning.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:28', '2020-02-09 05:03:09', 1);
INSERT INTO `zy_articles_xs_test` VALUES (26, '了解PHP-FPM', '<p>在服务器上，当我们查看php进程时，全都是php-fpm进程，大家都知道这个就是php的运行环境，那么，它到底是个什么东西呢？</p><h2>PHP-FPM简介</h2><p>PHP-FPM，就是PHP的FastCGI管理器，用于替换PHP FastCGI的大部分附加功能，在PHP5.3.3后已经成为了PHP的标配。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>有小伙伴要问了，FastCGI又是什么鬼？CGI程序又叫做“通用网关接口”，就是让Web服务器和你的应用程序进行交互的一个接口。就像nginx中需要配置的fastcgi_pass，一般我们会使用127.0.0.1:9000或者unix:/tmp/php-cgi.sock来配置这个参数。它的意思就是告诉nginx，过来的请求使用tcp:9000端口的监听程序来处理或者使用unix/socket来处理。它们都是指向的PHP运行程序。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>再说得通俗一点，我们运行php脚本用的是</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nphp aaa.php \n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>php-fpm就相当于是这个php命令。nginx通过fastcgi_pass来运行php $nginx_root(nginx配置文件中网站根目录root配置)下的index.php。所以，如果你用的是python或者其他什么语言，都可以用它们的cgi程序来让nginx调用。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>FastCGI和CGI又有什么不同呢？FastCGI是启动一个socket接口，服务器应用不需要自己去运行php，只需要向这个socket接口提交请求就可以了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>php-fpm在编译php时需要添加--enable-fpm。一些通用的集成安装包如lnmp、phpStudy等都会默认编译并使用php-fpm，毕竟是标配。</p><h2>tcp socket与unix socket</h2><p>上文中说过nginx可以使用127.0.0.1:9000和unix:/tmp/php-cgi.sock这两种方式来调用php-fpm。它们有什么区别呢？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>前者，一般带9000端口号的，是tcp形式的调用。也就是php-fpm启动了一个监听进程对9000端口进行监听。它会调起一个tcp/ip服务，nginx在调用的时候会走一次tcp请求流程，也就是3次握手4次挥手，会走到网络七层中的第四层传输层。相对来说这种方式性能会稍差一点，启动php-fpm后使用nestat查看端口中会出现9000端口的占用。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>后者，使用的是unix套接字socket服务，通过sock文件来交换信息，性能相对好一些，因为它没有tcp连接过程，也不会有9000端口的占用。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>对于高负载大访问量的网站还是推荐使用unix方式，对于普通小网站来说，无所谓使用哪个都可以，tcp方式反而更容易配置和理解，也是php-fpm.conf中默认的监听方式。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>php-fpm.conf配置中的listen属性用来配置监听，这里的配置要和nginx中的一致，使用tcp的就监听127.0.0.1:9000，使用unix的就设置成/tmp/php-cgi-56.sock。</p><h2>PHP-FPM的功能</h2><p>以下内容摘自官方文档：</p><ul><li><p>支持平滑停止/启动的高级进程管理功能</p></li><li><p>可以工作于不同的 uid/gid/chroot 环境下，并监听不同的端口和使用不同的 php.ini 配置文件（可取代 safe_mode 的设置）</p></li><li><p>stdout 和 stderr 日志记录</p></li><li><p>在发生意外情况的时候能够重新启动并缓存被破坏的 opcode</p></li><li><p>文件上传优化支持</p></li><li><p>\"慢日志\" - 记录脚本（不仅记录文件名，还记录 PHP backtrace 信息，可以使用 ptrace或者类似工具读取和分析远程进程的运行数据）运行所导致的异常缓慢;</p></li><li><p>fastcgi_finish_request() - 特殊功能：用于在请求完成和刷新数据后，继续在后台执行耗时的工作（录入视频转换、统计处理等）</p></li><li><p>动态／静态子进程产生</p></li><li><p>基本 SAPI 运行状态信息（类似Apache的 mod_status）</p></li><li><p>基于 php.ini 的配置文件</p></li></ul><blockquote><p>本文参考：</p></blockquote><ul><li><p><a href=\"https://www.php.net/manual/zh/install.fpm.php\">https://www.php.net/manual/zh/install.fpm.php</a></p></li><li><p><a href=\"https://www.cnblogs.com/sunlong88/p/9001184.html\">https://www.cnblogs.com/sunlong88/p/9001184.html</a></p></li><li><p><a href=\"https://www.jianshu.com/p/34a20e8dbf10\">https://www.jianshu.com/p/34a20e8dbf10</a></p></li><li><p><a href=\"https://blog.csdn.net/erlib/article/details/38488937\">https://blog.csdn.net/erlib/article/details/38488937</a></p></li></ul>', 'PHP', 'PHP基础', '2022-07-23 18:06:28', '2020-05-19 17:40:56', 1);
INSERT INTO `zy_articles_xs_test` VALUES (27, '优雅地创建未定义PHP对象', '<h1>优雅地创建未定义类PHP对象</h1><p>在PHP中，如果没有事先准备好类，需要创建一个未定义类的对象，我们可以采用下面三种方式：</p><ul><li><p>new stdClass()</p></li><li><p>new class{}</p></li><li><p>(object)[]</p></li></ul><p>首先是stdClass，这个类是一个空的类模板，是PHP的内部保留关键字及类名。可以把它相像成是Java中的Object基类，在Java中，所有类都天然继承自Object基类。而PHP中的这个stdClass则是完全的一个空的类模板。你自己新创建的类并不是它的子类。但是用这个类模板可以创建一个自己未定义类的对象。当然，这个对象内部没有任何东西。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$a = new stdClass();\nvar_dump($a);\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>new class{}呢？做过一段时间开发，接触过前端js和其他动态语言的应该能猜到，这个是匿名类。一般在参数对象中很常见。它创建出来的对象是可以带属性方法的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$b = new class{\n    public $p = 1;\n};\nvar_dump($b);\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>最后我们来看到的是使用数组强转成对象的形式来生成一个对象。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$c = (object)[\n    \'p\' =&gt; 1\n];\nvar_dump($c);\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>很明显，数组强转的形式生成的对象和第一种对象是一个类型的，而且它可以带属性也可以不带。但是，它不能带方法。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>数组强转方式生成的对象非常的直观好理解。如果只是属性对象的封装，使用这种方式会更加地优雅舒服。复杂的对象生成可以使用匿名类的方式进行生成。而一些仅需要占位的对象，可以使用stdClass的方法，当然用空数组的方式也很方便。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>需要注意的是，数组强转需要遵守类型转换的规则。比如数字下标的问题。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在日常开发中，我们对于一些接口或者数据库ORM框架的使用中会经常用这些功能。比如一些ORM框架的插入、修改需要传入的是只包含属性的对象。这时候就可以使用上述的方法灵活地生成对象而不用完整的定义类模板了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201910/source/%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%9B%E5%BB%BA%E6%9C%AA%E5%AE%9A%E4%B9%89PHP%E5%AF%B9%E8%B1%A1.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201910/source/%E4%BC%98%E9%9B%85%E5%9C%B0%E5%88%9B%E5%BB%BA%E6%9C%AA%E5%AE%9A%E4%B9%89PHP%E5%AF%B9%E8%B1%A1.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><a href=\"https://www.php.net/manual/zh/language.types.object.php#117149\">https://www.php.net/manual/zh/language.types.object.php#117149</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-08-19 19:11:05', 1);
INSERT INTO `zy_articles_xs_test` VALUES (28, '关于PHP数组Key的强制转换', '<h1>关于PHP数组Key的强制类型转换</h1><p>PHP是弱类型语言，就像JavaScript一样，在定义变量时，不需要强制指定变量的类型。同时，PHP又有着强大的数组功能，数组的Key即可以是普通的数字类型下标，也可以是字符串类型的Hash键值，那么，当一个数组的Key同时拥有字符串和数字时，会产生什么情况呢？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>首先来看下面这样一段代码：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$arr = [\n    \"1\" =&gt; \"a\",\n    \"01\" =&gt; \"b\",\n    1 =&gt; \"aa\",\n    1.1 =&gt; \"aaa\",\n    \"0.1\" =&gt; \"bb\",\n];\n\nvar_dump($arr);\n\n// array(3) {\n//     [1] =&gt;\n//     string(3) \"aaa\"\n//     \'01\' =&gt;\n//     string(1) \"b\"\n//     \'0.1\' =&gt;\n//     string(2) \"bb\"\n// }</code></pre></div><p>咦？我们定义的\"1\"、1下标的值都变成了1.1的\"aaa\"了？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>没错，PHP中的数组Key值只接受数字和字符串类型，当Key是字符串时，会强强制转换为数字类型，遵守类型强制转换的规则。浮点数也是同样的道理，直接转换成了向下取整的整型。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>那么\"0.1\"和\"01\"为什么还在？首先，\"01\"不是标准的十进制数值，无法转换成整型，所以\"01\"还是一个字符串下标，那\"0.1\"呢？它当然也不是一个标准的十进制数值。这里是违背了字符串转型数字的强制类型转换原则的，在变量的强制转换中，这两种字符串都会被转换为0，但在数组中则不会，这里会是一个坑，也是需要注意的地方。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在PHP官方文档中给出的Key值转换说明如下：</p><ul><li><p>包含有合法整型值的字符串会被转换为整型。例如键名 \"8\" 实际会被储存为 8。但是 \"08\" 则不会强制转换，因为其不是一个合法的十进制数值。</p></li><li><p>浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。</p></li><li><p>布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。</p></li><li><p>Null 会被转换为空字符串，即键名 null 实际会被储存为 \"\"。</p></li><li><p>数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。</p></li></ul><p>接下来，是笔者曾经做过的一道面试题，和这个类型转换有着非常大的关系，代码如下：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$a      = [\'a\'];\n$a[2]   = \'b\';\n$a[]    = \'c\';\n$a[\'1\'] = \'d\';\n\n// 以下循环的输出结果是？\nforeach ($a as $v) {\n	echo $v, \',\';\n}\n\n// 以下循环的输出结果是？\nfor ($i = 0; $i &lt; count($a); ++$i) {\n	echo $a[$i], \'  ,\';\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>大家先不要运行，直接看代码看看能不能看出这两段代码的输出结果会是什么，然后运行一下，看看结果和你想像的是不是一样。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201910/source/%E5%85%B3%E4%BA%8EPHP%E6%95%B0%E7%BB%84Key%E7%9A%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201910/source/%E5%85%B3%E4%BA%8EPHP%E6%95%B0%E7%BB%84Key%E7%9A%84%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考资料：</p><p><a href=\"https://www.php.net/manual/zh/language.types.array.php\">https://www.php.net/manual/zh/language.types.array.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-10-30 20:21:20', 1);
INSERT INTO `zy_articles_xs_test` VALUES (29, '注意！PHP中字符串与数字的比较', '<h1>注意！PHP中字符串与数字的比较</h1><p>在日常开发过程中，==运算符是我们每天都会接触到的。这个运算符中其实埋了非常多的坑，今天我们就来看下字符串和数字用==比较需要注意的问题。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>首先来看看这些代码：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\necho \'\"1234\" == \" 1234\" is \' . (\'1234\' == \' 1234\'), PHP_EOL;\necho \'\"1234\" == \"\\n1234\" is \' . (\'1234\' == \"\\n1234\"), PHP_EOL;\necho \'\"1234\" == \"1234\" is \' . (\'1234\' == \'1234\'), PHP_EOL;\necho \'\"1234\" == \"1234 \" is \' . (\'1234\' == \'1234 \'), PHP_EOL;\necho \'\"1234\" == \"1234\\n\" is \' . (\'1234\' == \"1234\\n\"), PHP_EOL;\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>都是字符串的==操作，它们的结果会是什么呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n\"1234\" == \" 1234\" is 1\n\"1234\" == \"\\n1234\" is 1\n\"1234\" == \"1234\" is 1\n\"1234\" == \"1234 \" is \n\"1234\" == \"1234\\n\" is \n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>没错，空格或者制表符号在前的会忽略掉这些符号，也就是说，这些字符串在对比的时候进行了类型转换，都被强转成了int型。而特殊字符在后的，则会按照字符串类型进行比对，那么，纯字符类型呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\necho \'\"aa\" == \" aa\" is \' . (\'aa\' == \' aa\'), PHP_EOL;\necho \'\"aa\" == \"\\naa\" is \' . (\'a\' == \'\\naa\'), PHP_EOL;\necho \'\"aa\" == \"aa\" is \' . (\'aa\' == \'aa\'), PHP_EOL;\necho \'\"aa\" == \"aa \" is \' . (\'aa\' == \'aa \'), PHP_EOL;\necho \'\"aa\" == \"aa\\n\" is \' . (\'aa\' == \"aa\\n\"), PHP_EOL;\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>这时候的结果就符合我们的预期了，他们本身就是字符串的比对，不会进行任何类型的转换：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n\"aa\" == \" aa\" is \n\"aa\" == \"\\naa\" is \n\"aa\" == \"aa\" is 1\n\"aa\" == \"aa \" is \n\"aa\" == \"aa\\n\" is \n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>综上实验结果得知，当字符串的内容都是int数据时，字符串的==比较会忽略在字符串前面出现的空格或者制表符号将它们强制转换成int类型。而只要字符串中包含文本或者特殊符号在数字的后面，就会以文本方式进行比较，如纯文本或者混合文本（\"11aa\"、\"11\\n\"、\"aa11 \")。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：<a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201910/source/%E6%B3%A8%E6%84%8F%EF%BC%81PHP%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%AF%94%E8%BE%83.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201910/source/%E6%B3%A8%E6%84%8F%EF%BC%81PHP%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E6%AF%94%E8%BE%83.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考链接：<a href=\"https://www.php.net/manual/zh/language.operators.comparison.php\">https://www.php.net/manual/zh/language.operators.comparison.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-12-30 05:00:36', 1);
INSERT INTO `zy_articles_xs_test` VALUES (30, '还不知道PHP有闭包？那你真OUT了', '<h1>还不知道PHP有闭包？那你真OUT了</h1><p>做过一段时间的Web开发，我们都知道或者了解JavaScript中有个非常强大的语法，那就是闭包。其实，在PHP中也早就有了闭包函数的功能。早在5.3版本的PHP中，闭包函数就已经出现了。到了7以及后来的现代框架中，闭包函数的使用更是无处不在。在这里，我们就先从基础来了解PHP中闭包的使用吧！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>闭包函数（closures）在PHP中都会转换为 Closure 类的实例。在定义时如果是赋值给变量，在结尾的花括号需要添加;分号。闭包函数从父作用域中继承变量，任何此类变量都应该用 use 语言结构传递进去。 PHP 7.1 起，不能传入此类变量：superglobals、 $this 或者和参数重名。</p><blockquote><p>基础语法</p></blockquote><p>闭包的使用非常简单，和JavaScript也非常相似。因为他们都有另外一个别名，叫做匿名函数。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$a = function () {\n    echo \"this is testA\";\n};\n$a(); // this is testA\n\n\nfunction testA ($a) {\n    var_dump($a); \n}\ntestA($a); // class Closure#1 (0) {}\n\n$b = function ($name) {\n    echo \'this is \' . $name;\n};\n\n$b(\'Bob\'); // this is Bob\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>我们将$a和$b两个变量直接赋值为两个函数。这样我们就可以使用变量()的形式调用这两个函数了。通过testA()方法，我们可以看出闭包函数是可以当做普通参数传递的，因为它自动转换成为了 Closure 类的实例。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$age = 16;\n$c = function ($name) {\n    echo \'this is \' . $name . \', Age is \' . $age;\n};\n\n$c(\'Charles\'); // this is Charles, Age is\n\n$c = function ($name) use ($age) {\n    echo \'this is \' . $name . \', Age is \' . $age;\n};\n\n$c(\'Charles\'); // this is Charles, Age is 16\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>如果我们需要调用外部的变量，需要使用use关键字来引用外部的变量。这一点和普通函数不一样，因为闭包有着严格的作用域问题。对于全局变量来说，我们可以使用use，也可以使用global。但是对于局部变量（函数中的变量）时，只能使用use。这一点我们后面再说。</p><blockquote><p>作用域</p></blockquote><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testD(){\n    global $testOutVar;\n    echo $testOutVar;\n}\n$d = function () use ($testOutVar) {\n    echo $testOutVar;\n};\n$dd = function () {\n    global $testOutVar;\n    echo $testOutVar;\n};\n$testOutVar = \'this is d\';\n$d(); // NULL\ntestD(); // this is d\n$dd(); // this is d\n\n$testOutVar = \'this is e\';\n$e = function () use ($testOutVar) {\n    echo $testOutVar;\n};\n$e(); // this is e\n\n$testOutVar = \'this is ee\';\n$e(); // this is e\n\n$testOutVar = \'this is f\';\n$f = function () use (&amp;$testOutVar) {\n    echo $testOutVar;\n};\n$f(); // this is f\n\n$testOutVar = \'this is ff\';\n$f(); // this is ff\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>在作用域中，use传递的变量必须是在函数定义前定义好的，从上述例子中可以看出。如果闭包（$d）是在变量（$testOutVar）之前定义的，那么$d中use传递进来的变量是空的。同样，我们使用global来测试，不管是普通函数（testD()）或者是闭包函数（$dd），都是可以正常使用$testOutVar的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在$e函数中的变量，在函数定义之后进行修改也不会对$e闭包内的变量产生影响。这时候，必须要使用引用传递（$f）进行修改才可以让闭包里面的变量产生变化。这里和普通函数的引用传递与值传递的概念是相同的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>除了变量的use问题，其他方面闭包函数和普通函数基本没什么区别，比如进行类的实例化：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nclass G\n{}\n$g = function () {\n    global $age;\n    echo $age; // 16\n    $gClass = new G();\n    var_dump($gClass); // G info\n};\n$g();\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><blockquote><p>类中作用域</p></blockquote><p>关于全局作用域，闭包函数和普通函数的区别不大，主要的区别体现在use作为桥梁进行变量传递时的状态。在类方法中，有没有什么不一样的地方呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$age = 18;\nclass A\n{\n    private $name = \'A Class\';\n    public function testA()\n    {\n        $insName = \'test A function\';\n        $instrinsic = function () {\n            var_dump($this); // this info\n            echo $this-&gt;name; // A Class\n            echo $age; // NULL\n            echo $insName; // null\n        };\n        $instrinsic();\n\n        $instrinsic1 = function () {\n            global $age, $insName;\n            echo $age; // 18\n            echo $insName; // NULL\n        };\n        $instrinsic1();\n\n        global $age;\n        $instrinsic2 = function () use ($age, $insName) {\n            echo $age; // 18\n            echo $insName; // test A function\n        };\n        $instrinsic2();\n\n    }\n}\n\n$aClass = new A();\n$aClass-&gt;testA();\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><ul><li><p>A::testA()方法中的$insName变量，我们只能通过use来拿到。</p></li><li><p>闭包函数中的$this是调用它的环境的上下文，在这里就是A类本身。闭包的父作用域是定义该闭包的函数（不一定是调用它的函数）。静态闭包函数无法获得$this。</p></li><li><p>全局变量依然可以使用global获得。</p></li></ul><blockquote><p>小技巧</p></blockquote><p>了解了闭包的这些特性后，我们可以来看几个小技巧：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$arr1 = [\n    [\'name\' =&gt; \'Asia\'],\n    [\'name\' =&gt; \'Europe\'],\n    [\'name\' =&gt; \'America\'],\n];\n\n$arr1Params = \' is good!\';\n// foreach($arr1 as $k=&gt;$a){\n//     $arr1[$k][\'name\'] = $a[\'name\'] . $arr1Params;\n// }\n// print_r($arr1);\n\narray_walk($arr1, function (&amp;$v) use ($arr1Params) {\n    $v[\'name\'] .= \' is good!\';\n});\nprint_r($arr1);\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>干掉foreach：很多数组类函数，比如array_map、array_walk等，都需要使用闭包函数来处理。上例中我们就是使用array_walk来对数组中的内容进行处理。是不是很有函数式编程的感觉，而且非常清晰明了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testH()\n{\n    return function ($name) {\n        echo \"this is \" . $name;\n    };\n}\ntestH()(\"testH\'s closure!\"); // this is testH\'s closure!\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>看到这样的代码也不要懵圈了。PHP7支持立即执行语法，也就是JavaScript中的IIFE(Immediately-invoked function expression)。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们再来一个计算斐波那契数列的：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$fib = function ($n) use (&amp;$fib) {\n    if ($n == 0 || $n == 1) {\n        return 1;\n    }\n\n    return $fib($n - 1) + $fib($n - 2);\n};\n\necho $fib(10);\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>同样的还是使用递归来实现。这里直接换成了闭包递归来实现。最后有一点要注意的是，use中传递的变量名不能是带下标的数组项：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$fruits = [\'apples\', \'oranges\'];\n$example = function () use ($fruits[0]) { // Parse error: syntax error, unexpected \'[\', expecting \',\' or \')\'\n    echo $fruits[0]; \n};\n$example();\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>这样写直接就是语法错误，无法成功运行的。</p><blockquote><p>彩蛋</p></blockquote><p>Laravel中的IoC服务容器中，大量使用了闭包能力，我们模拟一个便于大家理解。当然，更好的方案是自己去翻翻Laravel的源码。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class B\n{}\nclass C\n{}\nclass D\n{}\nclass Ioc\n{\n    public $objs = [];\n    public $containers = [];\n\n    public function __construct()\n    {\n        $this-&gt;objs[\'b\'] = function () {\n            return new B();\n        };\n        $this-&gt;objs[\'c\'] = function () {\n            return new C();\n        };\n        $this-&gt;objs[\'d\'] = function () {\n            return new D();\n        };\n    }\n    public function bind($name)\n    {\n        if (!isset($this-&gt;containers[$name])) {\n            if (isset($this-&gt;objs[$name])) {\n                $this-&gt;containers[$name] = $this-&gt;objs[$name]();\n            } else {\n                return null;\n            }\n        }\n        return $this-&gt;containers[$name];\n    }\n}\n\n$ioc = new Ioc();\n$bClass = $ioc-&gt;bind(\'b\');\n$cClass = $ioc-&gt;bind(\'c\');\n$dClass = $ioc-&gt;bind(\'d\');\n$eClass = $ioc-&gt;bind(\'e\');\n\nvar_dump($bClass); // B\nvar_dump($cClass); // C\nvar_dump($dClass); // D\nvar_dump($eClass); // NULL</code></pre></div><blockquote><p>总结</p></blockquote><p>闭包特性经常出现的地方是事件回调类的功能中，另外就是像彩蛋中的IoC的实现。因为闭包有一个很强大的能力就是可以延迟加载。IoC的例子我们的闭包中返回的是新new出来的对象。当我们的程序运行的时候，如果没有调用$ioc-&gt;bind(\'b\')，那么这个B对象是不会创建的，也就是说这时它还不会占用资源占用内存。而当我们需要的时候，从服务容器中拿出来的时候才利用闭包真正的去创建对象。同理，事件的回调也是一样的概念。事件发生时在我们需要处理的时候才去执行回调里面的代码。如果没有闭包的概念，那么$objs容器就这么写了：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$this-&gt;objs[\'b\'] = new B();\n$this-&gt;objs[\'c\'] = new C();\n$this-&gt;objs[\'d\'] = new D();\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>容器在实例化的时候就把所有的类都必须实例化了。这样对于程序来说很多用不上的对象就都被创建了，带来非常大的资源浪费。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>基于闭包的这种强大能力，现在闭包函数已经在Laravel、TP6等框架中无处不在了。学习无止尽，掌握原理再去学习框架往往更能事半功倍。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/%E8%BF%98%E4%B8%8D%E7%9F%A5%E9%81%93PHP%E6%9C%89%E9%97%AD%E5%8C%85%EF%BC%9F%E9%82%A3%E4%BD%A0%E7%9C%9FOUT%E4%BA%86.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/%E8%BF%98%E4%B8%8D%E7%9F%A5%E9%81%93PHP%E6%9C%89%E9%97%AD%E5%8C%85%EF%BC%9F%E9%82%A3%E4%BD%A0%E7%9C%9FOUT%E4%BA%86.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/functions.anonymous.php\">https://www.php.net/manual/zh/functions.anonymous.php</a></p><p><a href=\"https://www.php.net/manual/zh/functions.anonymous.php#100545\">https://www.php.net/manual/zh/functions.anonymous.php#100545</a></p><p><a href=\"https://www.php.net/manual/zh/functions.anonymous.php#119388\">https://www.php.net/manual/zh/functions.anonymous.php#119388</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-10-20 07:42:57', 1);
INSERT INTO `zy_articles_xs_test` VALUES (31, 'PHP中使用if的时候为什么建议将常量放在前面？', '<h1>PHP中使用if的时候为什么建议将常量放在前面？</h1><p>在某些框架或者高手写的代码中，我们会发现有不少人喜欢在进行条件判断的时候将常量写在前面，比如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nif(1 == $a){\n    echo 111;\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>这样做有什么好处呢？我们假设一个不小心的粗心大意，少写了一个=号，会有什么结果。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$a = \'a\';\nif($a = \'b\'){\n    echo 111;\n}\necho $a;\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>没错，111输出了，$a的值也变成了b。少了一个等号，就变成了赋值操作，这样的操作会先给$a赋值，然后根据$a的值进行判断。如果$a = \'\'，就不会输出111，但是$a的值还是会变成\'\'。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><strong>划重点：这样的写法php是不会报错的，这也是有可能造成BUG的情况。</strong></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>那么反过来呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$a = \'a\';\nif(\'b\' = $a){\n    echo 111;\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>首先，大部分的IDE都会报语法错误，也就是直接划红线了。常量是不能被赋值修改的，不管是数字、字符串还是系统或者我们自己已经定义了的常量。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>其次，这种情况下你要是还发现不了这里有问题的话也没关系，运行起来也会报错的，代码是无法继续向下运行的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>当然，这只是一个小技巧，而且最主要的目的是为了应对粗心带来的问题。所以并不是强制的规范，有些公司可能会在代码审计或者规范文档中强调这样写法，当然，最好的还是我们要杜绝这种粗心带来的错误。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：<a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E4%B8%AD%E4%BD%BF%E7%94%A8if%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E5%B0%86%E5%B8%B8%E9%87%8F%E6%94%BE%E5%9C%A8%E5%89%8D%E9%9D%A2%EF%BC%9F.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E4%B8%AD%E4%BD%BF%E7%94%A8if%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E5%B0%86%E5%B8%B8%E9%87%8F%E6%94%BE%E5%9C%A8%E5%89%8D%E9%9D%A2%EF%BC%9F.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-11-29 18:38:28', 1);
INSERT INTO `zy_articles_xs_test` VALUES (32, 'PHP中用+号连接数组的结果是？', '<h1>PHP中用+号连接数组的结果是？</h1><p>我们在开发中，有时候会将两个数组合并连接起来，这个时候要注意了，千万不要偷懒直接使用+号哦，为什么呢？我们看看以下代码：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$a = [1, 2];\n$b = [4, 5, 6];\n\n$c = $a + $b;\nprint_r($c);\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>请用第一直接告诉我它的结果是什么？或许我这么问你应该能猜到，它的结果是：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nArray\n(\n    [0] =&gt; 1\n    [1] =&gt; 2\n    [2] =&gt; 6\n)\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>看出来了吧，用+号操作符连接的数组，结果取的是并集。也就是根据键，相同键的不会覆盖，没有键加入进来形成一个新数组。并不是将两个数组真的加起来。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>如果我们用$b+$a呢？那么结果就是$b的内容。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$c = $b + $a;\nprint_r($c);\n\nArray\n(\n    [0] =&gt; 4\n    [1] =&gt; 5\n    [2] =&gt; 6\n)\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>那么我们要获得1,2,4,5,6这样一个数组要怎么办呢？没错，使用array_merge()函数，请注意数组Key的位置：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$c = array_merge($a, $b);\nprint_r($c);\n\nArray\n(\n    [0] =&gt; 1\n    [1] =&gt; 2\n    [2] =&gt; 4\n    [3] =&gt; 5\n    [4] =&gt; 6\n)\n\n$c = array_merge($b, $a);\nprint_r($c);\n\nArray\n(\n    [0] =&gt; 4\n    [1] =&gt; 5\n    [2] =&gt; 6\n    [3] =&gt; 1\n    [4] =&gt; 2\n)\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>如果是key/value形式的Hash数组呢？结果也是一样的，$a中没有键将合并过来，相同的键将不处理。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$a = [\'a\' =&gt; 1, \'b\' =&gt; 2];\n$b = [\'a\' =&gt; 4, \'b\' =&gt; 5, \'c\' =&gt; 6];\n\nprint_r($a+$b);\n\nArray\n(\n    [a] =&gt; 1\n    [b] =&gt; 2\n    [c] =&gt; 6\n)\n\n$c = array_merge($a, $b);\nprint_r($c);\n\n$c = array_merge($b, $a);\nprint_r($c);\n\nArray\n(\n    [a] =&gt; 1\n    [b] =&gt; 2\n    [c] =&gt; 6\n)\nArray\n(\n    [a] =&gt; 4\n    [b] =&gt; 5\n    [c] =&gt; 6\n)\nArray\n(\n    [a] =&gt; 1\n    [b] =&gt; 2\n    [c] =&gt; 6\n)\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>上述Hash数组，使用array_merge()函数的结果和使用+号的结果是一样的，这是因为他们还是进行了键的对比。所以合并后的数组不会增加内容，如果是未定义下标的则会直接以数字下标添加进去。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>最后，我们再试试.操作符的连接：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$c = $a . $b;\nprint_r($c);\n\nArrayArray\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>好吧，强转成string类型的字符串再拼接起来了，并无特别的意义。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：<a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E4%B8%AD%E7%94%A8%2B%E5%8F%B7%E8%BF%9E%E6%8E%A5%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%EF%BC%9F.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E4%B8%AD%E7%94%A8%2B%E5%8F%B7%E8%BF%9E%E6%8E%A5%E6%95%B0%E7%BB%84%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%EF%BC%9F.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：<a href=\"https://www.php.net/manual/zh/language.operators.array.php\">https://www.php.net/manual/zh/language.operators.array.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-03-22 03:45:19', 1);
INSERT INTO `zy_articles_xs_test` VALUES (33, 'PHP方法参数的那点事儿', '<h1>PHP方法参数的那点事儿</h1><p>在所有的编程语言中，方法或者函数，都可以传递一些参数进来进行业务逻辑的处理或者计算。这没什么可说的，但是在PHP中，方法的参数还有许多非常有意思的能力，下面我们就来说说这方面的内容。</p><blockquote><p>引用参数</p></blockquote><p>涉及到值传递和引用传递的问题。在正常情况下，我们使用值传递的时候，变量是进行了拷贝，方法内外的变量不会共享内存。也就是说，在方法体中修改了变量的值，方法外部的变量不会产生变化。而引用传递则是传递的变量的内存地值。方法内外的变量可以看做是同一个变量，比如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$a = 1;\nfunction test(&amp;$arg){\n    $arg++;\n}\ntest($a);\necho $a; // 2\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>为参数加上&amp;标识，就表明这个参数是引用传递的参数。如果没有加这个标识，则所有的基本类型参数都会以值的方式进行传递。为什么要强调基本类型呢？下面我们用类当参数来测试一下：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nclass A\n{\n    public $a = 1;\n}\nfunction testA($obj)\n{\n    $obj-&gt;a++;\n}\n\n$o = new A();\ntestA($o);\necho $o-&gt;a; // 2\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>在这个例子中，我们并没有使用&amp;标识来表明参数$obj是引用类型的，但如果传递的参数是对象的话，那么它默认就是进行的引用传递。如果想让对象也是值传递呢？抱歉，在方法参数中是没办法实现的，只能在方法体中使用clone方式对对象参数进行克隆。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nclass A\n{\n    public $a = 1;\n}\nfunction testA($obj)\n{\n    $o = clone $obj;\n    $o-&gt;a++;\n}\n$o = new A();\ntestA($o);\necho $o-&gt;a; // 1\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>关于值和引用的问题，可以参考设计模式中原型模式的讲解：</p><p><a href=\"https://mp.weixin.qq.com/s/KO4TuT2t5Xh_3BG3UrfN1w\">PHP设计模式之原型模式</a></p><blockquote><p>默认参数</p></blockquote><p>参数是可以有默认值的，这个我想大家都应该很清楚了。但是在使用的时候也需要注意，那就是默认参数不要放在前面，否则很容易出错，比如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testArgsA($a = 1, $b){\n    echo $a+$b;\n}\n\ntestArgs(); // error\n\nfunction testArgsB($a = 1, $b = 2){\n    echo $a+$b;\n}\n\ntestArgsB(); // 3\n\nfunction testArgsC($a, $b = 2){\n    echo $a+$b;\n}\n\ntestArgsC(1); // 3\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>在复杂的函数或者紧急的业务开发中，很有可能一个不小心就会漏写参数，这时候testArgsA就会返回错误了。当然，这种粗心类的错误是我们应该尽量避免的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>当指定默认值的时候，我们应该根据参数的类型进行指定，比如字符串就指定为\'\'，数字就指定为数字类型。当不确定参数是什么类型时，建议使用NULL做为默认参数。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testArgsD($a = NULL)\n{\n    if ($a) {\n        echo $a;\n    }\n}\n\ntestArgsD(1);\ntestArgsD(\'a\');\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><blockquote><p>类型声明</p></blockquote><p>类型声明是在PHP5之后添加的功能，就像java一样，参数前面加上参数的类型，比如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testAssignA(int $a = 0)\n{\n    echo $a;\n}\n\ntestAssignA(1);\ntestAssignA(\"a\"); // error\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>如果参数的类型不对，直接就会报错。在PHP7以前，只支持类、数组和匿名方法的类型声明。在PHP7之后，支持所有的普通类型，但是这里要注意的是，只支持普通类型的固定写法。</p><ul><li><p>Class/interface name</p></li><li><p>self</p></li><li><p>array</p></li><li><p>callable</p></li><li><p>bool</p></li><li><p>float</p></li><li><p>int</p></li><li><p>string</p></li></ul><p>固定写法是什么意思呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testAssignB(integer $a = 0) // error\n{\n    echo $a;\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>也就是说，int只能写int，不能使用integer，bool也不能使用boolean。只能是上面列出的类型关键字。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>类型声明的好处是什么呢？其实就是Java这种静态语言和PHP这种动态语言之间的差别。动态类型语言的好处就是变量灵活，不用指定类型，方便快速开发迭代。但问题也在于灵活，为了灵活，动态语言往往会在比较或者计算时对变量进行自动类型转换。如果你对变量类型转换的理解不清晰的话，很容易就会出现各种类型的BUG。同时，静态类型的语言一般都会有编译打包，而动态类型则是在执行时确定变量类型，所以很少会进行编译打包，相对来说运行效率也就不如Java之类的编译后语言了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>关于PHP的类型转换问题，可以参考此前的文章：</p><p><a href=\"https://mp.weixin.qq.com/s/dlvUiYjiOc5e6-eUxAItZw\">PHP中的强制类型转换</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>Tips一个小技巧，如果声明了参数类型，是不能传递NULL值的，比如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testAssignC(string $a = \'\')\n{\n    if ($a) {\n        echo __FUNCTION__ . \':\' . $a;\n    }\n}\n\ntestAssignC(NULL); // TypeError\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>这时有两种方式可以解决，一是指定默认值=NULL，二是使用?操作符：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n\nfunction testAssignD(string $a = NULL)\n{\n    if ($a == NULL) {\n        echo \'null\';\n    }\n}\n\ntestAssignD(NULL); // null\n\n\nfunction testAssignE(?string $a)\n{\n    if ($a == NULL) {\n        echo \'null\';\n    }\n}\ntestAssignE(NULL); // null\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><blockquote><p>可变数量参数</p></blockquote><p>php中的方法可以接收可变数量的参数，比如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testMultiArgsA($a)\n{\n    var_dump(func_get_arg(2));\n    var_dump(func_get_args());\n    var_dump(func_num_args());\n    echo $a;\n}\n\ntestMultiArgsA(1, 2, 3, 4);\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>我们只定义了一个参数$a，但是传进去了四个参数，这时我们可以使用三个方法来获取所有的参数：</p><ul><li><p>func_get_arg(int $arg_num)，获取参数列表中的某个指定位置的参数</p></li><li><p>func_get_args()，获取参数列表</p></li><li><p>func_num_args()，获取参数数量</p></li></ul><p>此外，php还提供了...操作符，用于将可变长度的参数定义到一个参数变量中，如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testMultiArgsB($a, ...$b)\n{\n    var_dump(func_get_arg(2));\n    var_dump(func_get_args());\n    var_dump(func_num_args());\n    echo $a;\n    var_dump($b); // 除$a以外的\n}\n\ntestMultiArgsB(1, 2, 3, 4);\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>和参数默认值一样，有多个参数的情况下，...$b也不要放在前面，这样后面的参数并不会有值，所有的参数都会在$b中。不过PHP默认已经帮我们解决了这个问题，如果...参数后面还有参数的话，会直接报错。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>利用这个操作符，我们还可以很方便的解包一些数组或可迭代的对象给方法参数，例如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testMultiArgsC($a, $b){\n    echo $a, $b;\n}\n\ntestMultiArgsC(...[1, 2]);\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>是不是很有意思，那么我们利用这个特性来合并一个数组会是什么效果呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$array1 = [[1],[2],[3]];\n$array2 = [4];\n$array3 = [[5],[6],[7]];\n\n$result = array_merge(...$array1); // Legal, of course: $result == [1,2,3];\nprint_r($result);\n$result = array_merge($array2, ...$array1); // $result == [4,1,2,3]\nprint_r($result);\n$result = array_merge(...$array1, $array2); // Fatal error: Cannot use positional argument after argument unpacking.\n$result = array_merge(...$array1, ...$array3); // Legal! $result == [1,2,3,5,6,7]\nprint_r($result);\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>和方法声明参数时一样，在外部使用...操作符给方法传递参数时，也不能在...后面再有其他参数，所以array_merge(...$array1, $array2)的操作会报错。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/functions.arguments.php\">https://www.php.net/manual/zh/functions.arguments.php</a></p><p><a href=\"https://www.php.net/manual/zh/functions.arguments.php#121579\">https://www.php.net/manual/zh/functions.arguments.php#121579</a></p><p><a href=\"https://www.php.net/manual/zh/functions.arguments.php#120580\">https://www.php.net/manual/zh/functions.arguments.php#120580</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-04-18 16:25:40', 1);
INSERT INTO `zy_articles_xs_test` VALUES (34, 'PHP方法的返回值', '<h1>PHP方法的返回值</h1><p>不仅是PHP，大部分编程语言的函数或者叫方法，都可以用return来定义方法的返回值。从函数这个叫法来看，本身它就是一个计算操作，因此，计算总会有个结果，如果你在方法体中处理了结果，比如进行了持久化保存，那么这个函数就不用返回任何内容。而计算的结果是要给外部使用的，这时候就要将计算结果进行返回了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>&nbsp;</p><blockquote><p>return关键字</p></blockquote><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testA($a, $b)\n{\n    echo $a + $b;\n}\n\nvar_dump(testA(1, 2)); // NULL\n\nfunction testB($a, $b)\n{\n    return $a + $b;\n}\n\nvar_dump(testB(1, 2)); // 3\n\nfunction testC($a, $b)\n{\n    return;\n    echo $a + $b; // 后面不会执行了\n}\n\nvar_dump(testC(1, 2)); // NULL\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>不用return或者直接return;都会返回NULL，return会阻断方法体中后续代码的执行。如果要返回多个值，只能使用数组组装数据。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testD($a, $b)\n{\n    return [\n        $a + $b,\n        $a * $b,\n    ];\n}\n\nvar_dump(testD(1, 2)); // [3, 2]\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>&nbsp;</p><blockquote><p>返回值类型声明</p></blockquote><p>关于返回值这一块还是比较好理解的。下面才是重头戏，在PHP7的新特性中，返回值声明是非常亮眼的一道风景。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testE($a, $b) : bool\n{\n    if($a+$b == 3){\n        return TRUE;\n    }else{\n        return NULL;\n    }\n}\n\nvar_dump(testE(1, 2)); // true\nvar_dump(testE(1.1, 2.2)); //TypeError: Return value of testE() must be of the type bool, null returned\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>如上例所示，如果返回值不是bool类型，那么将直接报TypeError的错误。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>那么定义了返回值类型声明有什么好处呢？我们在<a href=\"https://mp.weixin.qq.com/s/G2N8-BXAQvnac5emez6BPA\">PHP方法参数的那点事儿</a>有介绍过类型声明的好处，这里就不过多赘述了，不管是参数类型声明还是返回值类型声明，都是一样的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testF($a, $b): array\n{\n    return [\n        $a + $b,\n        $a * $b,\n    ];\n}\nvar_dump(testF(1, 2)); // [3, 2]\n\ninterface iA{\n\n}\nclass A implements iA\n{}\nclass B extends A\n{\n    public $b = \'call me B!\';\n}\n\nfunction testG(): A\n{\n    return new B();\n}\n\nfunction testH(): B\n{\n    return new B();\n}\n\nfunction testI(): iA\n{\n    return new B();\n}\n\nvar_dump(testG()); // B的实例\nvar_dump(testH()); // B的实例\nvar_dump(testI()); // B的实例\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>同样，数组和类类型都是可以声明定义的。不过除此之外，返回值声明还可以定义void。它的作用其实就是声明返回值为NULL，不能直接写:NULL，而只能用:void来进行声明。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testJ(): void\n{\n    echo \"testJ\";\n    // return 1;\n}\nvar_dump(testJ());\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>这时，如果尝试进行任何的return返回，都会直接报错：Fatal error: A void function must not return a value。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>&nbsp;</p><blockquote><p>总结</p></blockquote><p>我们可以看到，PHP在不断的发展中一直在吸取其他语言中的优秀特性。很明显，添加这些类型声明的目的就是为了将来的编译器做准备的。这也是PHP8的一个重要特性，让我们拭目以待吧！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p>[https://www.php.net/manual/zh/functions.returning-values.php][https://www.php.net/manual/zh/functions.returning-values.php]</p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-05-22 06:50:47', 1);
INSERT INTO `zy_articles_xs_test` VALUES (35, 'PHP没有定时器？', '<h1>PHP没有定时器？</h1><p>确实，PHP没有类似于JS中的setInterval或者setTimeout这样的原生定时器相关的函数。但是我们可以通过其他方式来实现，比如使用declare。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>先来看看是如何实现的，然后我们再好好学习一下declare表达式到底是个什么东西。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction do_tick($str = \'\')\n{\n    list($sec, $usec) = explode(\' \', microtime());\n    printf(\"[%.4f] Tick.%s\\n\", $sec + $usec, $str);\n}\nregister_tick_function(\'do_tick\');\n\ndo_tick(\'--start--\');\ndeclare (ticks = 1) {\n    while (1) {\n        sleep(1); // 这里，每执行一次就去调用一次do_tick()\n    }\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>很简单的代码，运行起来以后将每秒输出当前的时间。</p><blockquote><p>declare语法的定义如下：</p></blockquote><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">declare (directive)\n    statemaent;</code></pre></div><ul><li><p>declare 结构用来设定一段代码的执行指令</p></li><li><p>directive 部分允许设定 declare 代码段的行为。目前只认识两个指令：ticks以及 encoding</p></li><li><p>Tick（时钟周期）是一个在 declare 代码段中解释器每执行 N 条可计时的低级语句就会发生的事件。N 的值是在 declare 中的 directive 部分用 ticks=N 来指定的</p></li><li><p>在每个 tick 中出现的事件是由 register_tick_function() 来指定的</p></li></ul><p>这里，我们只研究ticks的使用。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上述代码中，我们使用register_tick_function()注册了do_tick()方法给ticks，declare指定了ticks=1，也就是每执行一次可计时的低级语句，就会去执行一次register_tick_function()中注册的方法。当declare代码块中的while每次循环时，都有一个sleep()停顿了一秒，而这个sleep()就是那个可计时的低级语句。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>那么，while()不是可计时的低级语句嘛？当然不是，where、if等条件判断都不是这种可计时的低级语句。</p><blockquote><p>不是所有语句都可计时。通常条件表达式和参数表达式都不可计时。</p></blockquote><p>我们通过下面这个例子再来看看具体到一步步declare是怎样执行的：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction test_tick()\n{\n    static $i = 0;\n    echo \'test_tick:\' . $i++, PHP_EOL;\n}\nregister_tick_function(\'test_tick\');\ntest_tick(); // test_tick:0\n\n$j = 0; \ndeclare (ticks = 1) {\n    $j++; // test_tick:1\n\n    $j++; // test_tick: 2\n    \n    sleep(1); //  停1秒后，test_tick:3\n\n    $j++; // test_tick:4\n\n    if ($j == 3) { // 条件表达式，不会执行ticks\n\n        echo \"aa\", PHP_EOL; // test_tick:5 \\n   test_tick:6，PHP_EOL会计一次ticks\n    }\n}\n\n// declare使用花括号后面所有代码无效果，作用域限定在花括号以内\necho \"bbb\"; // \necho \"ccc\"; // \necho \"ddd\"; // \n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>注释很详细了，我们就不用一一说明了。下面我们来看将ticks定为2，并且declare下面的statemaent不用花括号的结果：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction test_tick1() \n{\n    static $i = 0;\n    echo \'test_tick1:\' . $i++, PHP_EOL;\n}\nregister_tick_function(\'test_tick1\');\n\n$j = 0; // 此处不计时\ndeclare (ticks = 2); \n$j++; // test_tick1:0 \n\n$j++; \n\nsleep(1); //  停1秒后 test_tick1:1\n\n$j++; \n\n$j++; // test_tick1:2\n\nif ($j == 4) { // 条件表达式，不会执行ticks\n    // echo \"aa\", PHP_EOL;\n    echo \"aa\"; // test_tick:10,test_tick1不执行，没有跳两步，如果用了,PHP_EOL，那么算两步，会输出test_tick1:3\n}\n\n//  declare没有使用花括号将对后面所有代码起效果，如果是require或者include将不会对父页面后续内容进行处理\necho \"bbb\"; // test_tick1:3\necho \"ccc\";\necho \"ddd\"; // test_tick1:4\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>可以看出，我们declare对其定义后续的代码都产生了作用，但需要注意的是如果有页面嵌套，对父页面的后续代码是没有效果的。而定义了ticks=2之后，将在两个低级可计时代码后执行一次register_tick_function()注册的函数代码。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：<a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E6%B2%A1%E6%9C%89%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%9F.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E6%B2%A1%E6%9C%89%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%9F.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：<a href=\"https://www.php.net/manual/zh/control-structures.declare.php\">https://www.php.net/manual/zh/control-structures.declare.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-03-18 20:56:08', 1);
INSERT INTO `zy_articles_xs_test` VALUES (36, 'PHP的switch和ifelse谁更快？', '<h1>PHP的switch和ifelse谁更快？</h1><p>对于多个if条件判断的情况下，我们使用switch来代替ifelse对于代码来说会更加的清晰明了，那么他们的效率对比呢？从PHP手册中发现有人已经对比过了，自己也用他的代码进行了实验：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$s = time();\nfor ($i = 0; $i &lt; 1000000000; ++$i) {\n    $x = $i % 10;\n    if ($x == 1) {\n        $y = $x * 1;\n    } elseif ($x == 2) {\n        $y = $x * 2;\n    } elseif ($x == 3) {\n        $y = $x * 3;\n    } elseif ($x == 4) {\n        $y = $x * 4;\n    } elseif ($x == 5) {\n        $y = $x * 5;\n    } elseif ($x == 6) {\n        $y = $x * 6;\n    } elseif ($x == 7) {\n        $y = $x * 7;\n    } elseif ($x == 8) {\n        $y = $x * 8;\n    } elseif ($x == 9) {\n        $y = $x * 9;\n    } else {\n        $y = $x * 10;\n    }\n}\nprint(\"if: \" . (time() - $s) . \"sec\\n\");\n\n$s = time();\nfor ($i = 0; $i &lt; 1000000000; ++$i) {\n    $x = $i % 10;\n    switch ($x) {\n        case 1:\n            $y = $x * 1;\n            break;\n        case 2:\n            $y = $x * 2;\n            break;\n        case 3:\n            $y = $x * 3;\n            break;\n        case 4:\n            $y = $x * 4;\n            break;\n        case 5:\n            $y = $x * 5;\n            break;\n        case 6:\n            $y = $x * 6;\n            break;\n        case 7:\n            $y = $x * 7;\n            break;\n        case 8:\n            $y = $x * 8;\n            break;\n        case 9:\n            $y = $x * 9;\n            break;\n        default:\n            $y = $x * 10;\n    }\n}\nprint(\"switch: \" . (time() - $s) . \"sec\\n\");\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>通过1000000000次的循环并在每个判断条件中都加入了运算操作后，我们发现结果是switch的效率更高，运行速度更快，在我的电脑上的结果是：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n// if: 301sec\n// switch: 255sec\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>虽然switch的效率更高一些，但也有需要注意的地方，首先，判断值只能是数字、浮点数或者是字符串。其次，每个判断都是普通的==判断，也就是说，下面的判断结果并不一定是你相像的结果：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$string = \"2string\";\n\nswitch ($string) {\n    case 1:\n        echo \"this is 1\";\n        break;\n    case 2:\n        echo \"this is 2\";\n        break;\n    case \'2string\':\n        echo \"this is a string\";\n        break;\n}\n\n// this is 2\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>没错，依然是==比较时的类型强转问题，string和int值比较时强转为了int类型，\"2string\"强转的结果正是2。因此，在使用switch的时候，应该保证比较值和每个case的类型一致，否则就可能出现不可预计的错误。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考代码：<a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E7%9A%84switch%E5%92%8Cifelse%E8%B0%81%E6%9B%B4%E5%BF%AB%EF%BC%9F.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E7%9A%84switch%E5%92%8Cifelse%E8%B0%81%E6%9B%B4%E5%BF%AB%EF%BC%9F.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考手册：<a href=\"https://www.php.net/manual/zh/control-structures.switch.php\">https://www.php.net/manual/zh/control-structures.switch.php</a></p>', 'PHP', 'PHP基础,性能', '2022-07-23 18:06:29', '2021-09-14 22:09:50', 1);
INSERT INTO `zy_articles_xs_test` VALUES (37, 'PHP的可变变量与可变函数', '<h1>PHP的可变变量与可变函数</h1><p>什么叫可变。在程序世界中，可变的当然是变量。常量在定义之后都是不可变的，在程序执行过程中，这个常量都是不能修改的。但是变量却不同，它们可以修改。那么可变变量和可变函数又是什么意思呢？很明显，就是用另一个变量来定义他们，这个变量是可变的呀！</p><blockquote><p>可变变量</p></blockquote><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$a = \'hello\';\n\n$$a = \'world\';\n\necho $a, \' \', $hello;\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>咦，我们没有定义\\$hello这个变量呀。嗯，从表面上看我们确实没有定义这个变量，但请注意这个$$符号。$符号的意思就是定义变量，当我们在一个$符号后面跟上一个已经定义的变量名，那么这个变量的内容就成为了新的变量名。也就是说，$a的内容hello成为了一个新的变量名叫$hello，然后给它赋值为world。是不是感觉不太好理解，也不便于我们查看代码，这个问题我们最后再说。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>当然，以下的用法要注意：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$a = 1;\n$$a = 2;\n\necho $1; // Parse error: syntax error, unexpected \'1\'\necho ${1}; // ok\n\n$a = [\'b\', \'c\', \'d\'];\n$$a = \'f\';\n\necho $b, $c, $d;\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><ul><li><p>数字类型不是合法的变量名，不能作为可变变量被定义</p></li><li><p>但是利用{}，是可以输出的，{}会获取{}内部的值并作为一个变量来解析，这里的{1}我们利用可变变量赋值成为了一个变量，直接输出是非常的，但放在{1}中就成为了一个可解析的变量名，我们可以简单的理解为{1}转换成了$\'1\'，成为了一个正式的变量名</p></li><li><p>数组当然是不行啦</p></li><li><p>它们这样写都是不会报错的</p></li></ul><p>使用对象就不行了，直接就会报错了，对象是不能进行可变变量的操作的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nclass A {}\nclass B extends A {}\n\n$a = new A();\n$$a = new B(); // Catchable fatal error: Object of class A could not be converted to string \n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><blockquote><p>可变函数</p></blockquote><p>可变函数其实也大同小异，当我们在一个变量的后面加上()时，PHP就会尝试将这个变量当做函数来解析。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction testA()\n{\n    echo \"testA\";\n}\n\n$a = \'testA\';\n$a(); // testA\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>可变变量是将一个字符串转换成了一个变量名，而可变函数则是将一个字符串当做函数名来调用。比如类中的方法，我们可以这样来调用：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nclass C\n{\n    public function testA()\n    {\n        echo \"C:testA\";\n    }\n    public function testB()\n    {\n        echo \"C:testB\";\n    }\n    public function testC()\n    {\n        echo \"C:testC\";\n    }\n}\n\n$funcs = [\'testA\', \'testB\', \'testC\'];\n\n$c = new C();\nforeach ($funcs as $func) {\n    $c-&gt;$func();\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>可变函数的这种特性和另外两个系统函数的关系非常紧密，它们是：call_user_func()和call_user_func_array()，Laravel中服务容器的核心实现就是使用了call_user_func_array()来实现依赖注入与控制反转的，这个等我们将来学习到的时候再说。</p><blockquote><p>总结</p></blockquote><p>看似很美好很灵活的可变变量与可变函数在我们实际的开发中却很少使用。究其原因当然是可读性不好，代码不仅是写给机器的，也是写给人看的，团队中人员的水平不齐的话过多的使用这两种特性会产生非常多的混乱情况。但是，很多框架代码中会使用这些特性，所以，这也是我们向更高层次迈进所必须要掌握的东西。不管怎么样，学就是了，能在业务场合中使用可变变量或者函数大大节约代码量写出精致易读的代码更能彰显我们的技术实力。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/PHP%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考链接：</p><p><a href=\"https://www.php.net/manual/zh/language.variables.variable.php\">https://www.php.net/manual/zh/language.variables.variable.php</a></p><p><a href=\"https://www.php.net/manual/zh/functions.variable-functions.php\">https://www.php.net/manual/zh/functions.variable-functions.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-01-16 20:01:58', 1);
INSERT INTO `zy_articles_xs_test` VALUES (38, 'PHP设计模式汇总', '<h1>PHP设计模式汇总</h1><p>没想到啊，没想到。自己竟然坚持了下来，完成了设计模式深入的学习，并且输出了23篇用php演示的设计模式的文章。但这不是最主要的，更深层次的收获是顺便背下了这些模式的定义及类图。在深入学习了设计模式之后，对Laravel等框架的架构理解也更清楚明了了。就像我在很多模式的讲解中都引用了在Laravel中相关的实现。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从今年2月份到现在，历时9个月，从开始的一周一篇到一周两篇。也让自己看到了坚持的可贵。同时也渐渐用自身经历体会到了一个道理，<strong>基础的才是最重要的</strong>。就像韩寒电影中所说：”听过那么道理，却依然过不好这一生。“在我们学习的过程中也一样，都知道基础有用，但是却总想去追新追潮流，但这些新的知识或者潮流却是那些最原始基础的演变和发展，万变不离其宗才是硬道理。接下来的计划是？没错，明年是更大的挑战，数据结构与算法，同时补习数学。所以，明年的连载文章会以算法为主。除此之外，也会连载关于Laravel6和TP6相关的文章，各位看官还请多多指教。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>一家之言有时候并不一定能让你深刻的体会或者理解知识。就像《如何阅读一本书》中的主题阅读一样，用多本参考书或者学习资料来相互进行补充的<strong>主题阅读</strong>方式往往能带来更好的效果。注意，这里不是每一本书或者每一篇资料都从头到尾看一遍，那样你的时间耗费不起，而是直接去找资料中和你当前所学习内容相关的内容进行阅读学习。所以，我的参考资料有这些：</p><blockquote><p>书籍</p></blockquote><ul><li><p>《设计模式：可复用面向对象软件的基础》 <a href=\"https://union-click.jd.com/jdc?e=&amp;amp;p=AyIGZRtYFAcXBFIZWR0yEgRSGFkRCxs3EUQDS10iXhBeGlcJDBkNXg9JHU4YDk5ER1xOGRNLGEEcVV8BXURFUFdfC0RVU1JRUy1OVxUBFQRXH1IcMlVjVR4OUFZHZwdfQVB4dWM0WVgPd0QLWStaJQITBVAZWRYBEDdlG1wlUHzf462DsLMO0%2F%2BUjp2VIgZlG18TABIBVxJdFAoQBWUcWxwyWV4FRA1dRkYGURpZJTIiBGUraxUyETcXdV9HAhcFVBJZQVEWBlAcW0YKElVdHQkdA0VTAh1YEgVFN1caWhEL\">https://union-click.jd.com/jdc?e=&amp;p=AyIGZRtYFAcXBFIZWR0yEgRSGFkRCxs3EUQDS10iXhBeGlcJDBkNXg9JHU4YDk5ER1xOGRNLGEEcVV8BXURFUFdfC0RVU1JRUy1OVxUBFQRXH1IcMlVjVR4OUFZHZwdfQVB4dWM0WVgPd0QLWStaJQITBVAZWRYBEDdlG1wlUHzf462DsLMO0%2F%2BUjp2VIgZlG18TABIBVxJdFAoQBWUcWxwyWV4FRA1dRkYGURpZJTIiBGUraxUyETcXdV9HAhcFVBJZQVEWBlAcW0YKElVdHQkdA0VTAh1YEgVFN1caWhEL</a></p></li><li><p>《大话设计模式》 <a href=\"https://union-click.jd.com/jdc?e=&amp;amp;p=AyIGZRNZFQERBVYaWyUCEwRSE1gTCxsEZV8ETVxNNwxeHlRAGRlLQx5BXg1bSkAOClBMW0tdC1ZWDEANTx0KUkBCDUUEG0RCRAFjDhkCEwRSE1gTCxsEZUU4cHdWBAV%2FPlUBZF9QHAFdfFtaUE1XGTITN1UaWRAAEARWGWslAhU3FHVeFQMbBWUaaxUGFAVVHVkdARYEVxhrEgIbNx5CC0pUWkMBGl8UACI3ZRhrJTISN1YrGXtWQlNSEwkRVxUGVh5eEgFHD10aWB0LRlMAGllABkEFXStZFAMWDg%3D%3D\">https://union-click.jd.com/jdc?e=&amp;p=AyIGZRNZFQERBVYaWyUCEwRSE1gTCxsEZV8ETVxNNwxeHlRAGRlLQx5BXg1bSkAOClBMW0tdC1ZWDEANTx0KUkBCDUUEG0RCRAFjDhkCEwRSE1gTCxsEZUU4cHdWBAV%2FPlUBZF9QHAFdfFtaUE1XGTITN1UaWRAAEARWGWslAhU3FHVeFQMbBWUaaxUGFAVVHVkdARYEVxhrEgIbNx5CC0pUWkMBGl8UACI3ZRhrJTISN1YrGXtWQlNSEwkRVxUGVh5eEgFHD10aWB0LRlMAGllABkEFXStZFAMWDg%3D%3D</a></p></li><li><p>《Head Frist设计模式》 <a href=\"https://union-click.jd.com/jdc?e=&amp;amp;p=AyIGZRtYFAcXBFIZWR0yEgZVGloWABU3EUQDS10iXhBeGlcJDBkNXg9JHU4YDk5ER1xOGRNLGEEcVV8BXURFUFdfC0RVU1JRUy1OVxUDEgZUGFkSMmEBNkMEdnJuZwEYAXBLallPGCYUe1QLWStaJQITBVAZWRYBEDdlG1wlUHzf462DsLMO0%2F%2BUjp2VIgZlG18TABIBVxJfEgsRBmUcWxwyWV4FRA1dRkYGURpZJTIiBGUraxUyETcXdV9HAhcFVBJZQVEWBlAcW0YKElVdHQkdA0VTAh1YEgVFN1caWhEL\">https://union-click.jd.com/jdc?e=&amp;p=AyIGZRtYFAcXBFIZWR0yEgZVGloWABU3EUQDS10iXhBeGlcJDBkNXg9JHU4YDk5ER1xOGRNLGEEcVV8BXURFUFdfC0RVU1JRUy1OVxUDEgZUGFkSMmEBNkMEdnJuZwEYAXBLallPGCYUe1QLWStaJQITBVAZWRYBEDdlG1wlUHzf462DsLMO0%2F%2BUjp2VIgZlG18TABIBVxJfEgsRBmUcWxwyWV4FRA1dRkYGURpZJTIiBGUraxUyETcXdV9HAhcFVBJZQVEWBlAcW0YKElVdHQkdA0VTAh1YEgVFN1caWhEL</a></p></li><li><p>《PHP设计模式》 <a href=\"https://union-click.jd.com/jdc?e=&amp;amp;p=AyIGZRtSHAERB1ATXhEyFgJdHl8WBxMFVxhrUV1KWQorAlBHU0VeBUVNR0ZbSkdETlcNVQtHRVNSUVNLXANBRA1XB14DS10cQQVYD21XHgNQE14RARcGVxlYJQBAYidNU253d29PSyl1XEtOBUQ%2BHXIeC2UaaxUDEAJXGVgWACI3VRxrVGwSBlQfXRMCGzdUK1sRBBAHUxlTEAQWAVQrXBULIkwMSwRDSlZTVB9aFzIiN1YrayUCIgRlWTVHUkcAABJaFgEQBVIeXRIFG1NcSVIRUBsGVU8OEAoVBWUZWhQGGw%3D%3D\">https://union-click.jd.com/jdc?e=&amp;p=AyIGZRtSHAERB1ATXhEyFgJdHl8WBxMFVxhrUV1KWQorAlBHU0VeBUVNR0ZbSkdETlcNVQtHRVNSUVNLXANBRA1XB14DS10cQQVYD21XHgNQE14RARcGVxlYJQBAYidNU253d29PSyl1XEtOBUQ%2BHXIeC2UaaxUDEAJXGVgWACI3VRxrVGwSBlQfXRMCGzdUK1sRBBAHUxlTEAQWAVQrXBULIkwMSwRDSlZTVB9aFzIiN1YrayUCIgRlWTVHUkcAABJaFgEQBVIeXRIFG1NcSVIRUBsGVU8OEAoVBWUZWhQGGw%3D%3D</a></p></li><li><p>《JavaScript设计模式》 <a href=\"https://union-click.jd.com/jdc?e=&amp;amp;p=AyIGZRtSFQASAVIfXxIyFgJVH1kVAhYAXBhrUV1KWQorAlBHU0VeBUVNR0ZbSkdETlcNVQtHRVNSUVNLXANBRA1XB14DS10cQQVYD21XHgNQG18XAhIDUhJYJUpFWFxoKEVycVBPfCd3A1B3PWQ8YEQeC2UaaxUDEAJXGVgWACI3VRxrVGwSBlQfXRwDETdUK1sRBBAHUxlTEgQVB1ErXBULIkwMSwRDSlZTVB9aFzIiN1YrayUCIgRlWTVAAhAOUEgLFQIVBgYeWhMDQVdUT1sSARMDBx5eEgIXA2UZWhQGGw%3D%3D\">https://union-click.jd.com/jdc?e=&amp;p=AyIGZRtSFQASAVIfXxIyFgJVH1kVAhYAXBhrUV1KWQorAlBHU0VeBUVNR0ZbSkdETlcNVQtHRVNSUVNLXANBRA1XB14DS10cQQVYD21XHgNQG18XAhIDUhJYJUpFWFxoKEVycVBPfCd3A1B3PWQ8YEQeC2UaaxUDEAJXGVgWACI3VRxrVGwSBlQfXRwDETdUK1sRBBAHUxlTEgQVB1ErXBULIkwMSwRDSlZTVB9aFzIiN1YrayUCIgRlWTVAAhAOUEgLFQIVBgYeWhMDQVdUT1sSARMDBx5eEgIXA2UZWhQGGw%3D%3D</a></p></li></ul><blockquote><p>网络教程</p></blockquote><ul><li><p>腾讯课堂：大话PHP设计模式</p></li><li><p>网易云课堂：JavaScript高级与设计模式 <a href=\"https://study.163.com/course/introduction/1006362058.htm?share=1&amp;amp;shareId=1137475601&amp;amp;utm_content=courseIntro&amp;amp;utm_u=1137475601&amp;amp;utm_source=weixin\">https://study.163.com/course/introduction/1006362058.htm?share=1&amp;shareId=1137475601&amp;utm_content=courseIntro&amp;utm_u=1137475601&amp;utm_source=weixin</a></p></li><li><p>网易云课堂：尚学堂-史上最易懂的设计模式视频</p></li><li><p>GitChat：白话设计模式28讲</p></li><li><p>GitChat：经典设计模式实战演练</p></li></ul><p>当我完成这一系列文章的时候，极客时间的优秀作者王争老师也出了一套设计模式的专栏。他的数据结构与算法专栏卖得非常火爆，而且组织的线下算法训练营也已经开了好几期，期期好评。将来的学习计划中他的这个专栏也是重点要学习的内容。虽说这个设计模式专栏在我已经学习完设计模式之后才出来，但还是抑制不住我这个极客时间铁粉的买买买之路。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>仔细研究了下他的这个《设计模式之美专栏》，发现不仅仅局限于那23种设计模式，还包括：</p><ul><li><p>200+真实案例分析与设计</p></li><li><p>顶尖互联网公司的编程经验分享</p></li><li><p>应对设计模式面试的思路与技巧</p></li></ul><p>下面是具体的课程列表：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>不用我多说了吧，如果是PHPer，配合着我的系列文章一起学习更能事半功倍。快来加入一起学习吧！扫描识别下方二维码进入学习！</p><h1>设计模式文章汇总：</h1><blockquote><p>创建型模式</p></blockquote><ul><li><p>简单工厂</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/01.simple-factory/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/01.simple-factory/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/k_4AOqnW4FPcslcG8r5x_g\">https://mp.weixin.qq.com/s/k_4AOqnW4FPcslcG8r5x_g</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5ced0dd0e51d4550a629b1f6\">https://juejin.im/post/5ced0dd0e51d4550a629b1f6</a></p></li><li><p>工厂方法</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/02.factory/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/02.factory/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/UeLrBQW6sKLgszovzYNt-g\">https://mp.weixin.qq.com/s/UeLrBQW6sKLgszovzYNt-g</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5cf53a3051882506400062f7\">https://juejin.im/post/5cf53a3051882506400062f7</a></p></li><li><p>抽象工厂</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/03.abstract-factory/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/03.abstract-factory/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/8IgYen6QxKUnMFriWrI6yA\">https://mp.weixin.qq.com/s/8IgYen6QxKUnMFriWrI6yA</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5cfde72ef265da1bc64bb6d8\">https://juejin.im/post/5cfde72ef265da1bc64bb6d8</a></p></li><li><p>原型模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/08.prototype/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/08.prototype/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/KO4TuT2t5Xh_3BG3UrfN1w\">https://mp.weixin.qq.com/s/KO4TuT2t5Xh_3BG3UrfN1w</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5d65400bf265da03d60f1044\">https://juejin.im/post/5d65400bf265da03d60f1044</a></p></li><li><p>生成器模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/16.builder/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/16.builder/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/AhCLhH3rQAOULdZ2NtSGDw\">https://mp.weixin.qq.com/s/AhCLhH3rQAOULdZ2NtSGDw</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5da3c17a6fb9a04e046bc7ab\">https://juejin.im/post/5da3c17a6fb9a04e046bc7ab</a></p></li><li><p>单例模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/21.singleton/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/21.singleton/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/xJPF0dJYorbjhDQJMxogpQ\">https://mp.weixin.qq.com/s/xJPF0dJYorbjhDQJMxogpQ</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5db8d763f265da4d2e121d47\">https://juejin.im/post/5db8d763f265da4d2e121d47</a></p></li></ul><blockquote><p>结构型模式</p></blockquote><ul><li><p>适配器模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/05.adapter/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/05.adapter/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/kgBY2gnI65TiCIxatbmO8A\">https://mp.weixin.qq.com/s/kgBY2gnI65TiCIxatbmO8A</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5d47ef645188250525750ac2\">https://juejin.im/post/5d47ef645188250525750ac2</a></p></li><li><p>桥接模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/18.bridge/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/18.bridge/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/_o3FkcbKXHdUIMDgMbQOiA\">https://mp.weixin.qq.com/s/_o3FkcbKXHdUIMDgMbQOiA</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5dabe31e6fb9a04e0855c54d\">https://juejin.im/post/5dabe31e6fb9a04e0855c54d</a></p></li><li><p>组合模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/14.composite/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/14.composite/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/f4YCkz29uwppKNpf3FyZ5Q\">https://mp.weixin.qq.com/s/f4YCkz29uwppKNpf3FyZ5Q</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5d9a9ef66fb9a04e19504b4f\">https://juejin.im/post/5d9a9ef66fb9a04e19504b4f</a></p></li><li><p>装饰器模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/04.decorator/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/04.decorator/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/aimblTTMqqEqmuvU9kUH1g\">https://mp.weixin.qq.com/s/aimblTTMqqEqmuvU9kUH1g</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5d1087366fb9a07eaf2b9d26\">https://juejin.im/post/5d1087366fb9a07eaf2b9d26</a></p></li><li><p>外观模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/19.facade/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/19.facade/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/RzCoM96XnlT610q4AiuAVA\">https://mp.weixin.qq.com/s/RzCoM96XnlT610q4AiuAVA</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5dae4ccaf265da5ba7453baa\">https://juejin.im/post/5dae4ccaf265da5ba7453baa</a></p></li><li><p>享元模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/13.flyweights/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/13.flyweights/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/w0T01O86XobBtrz-4389gQ\">https://mp.weixin.qq.com/s/w0T01O86XobBtrz-4389gQ</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5d914cf0f265da5b81793c5f\">https://juejin.im/post/5d914cf0f265da5b81793c5f</a></p></li><li><p>代理模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/12.proxy/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/12.proxy/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/0CvVMuP-_j-0sqRK_4kcZA\">https://mp.weixin.qq.com/s/0CvVMuP-_j-0sqRK_4kcZA</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5d871413e51d453b1e478b8e\">https://juejin.im/post/5d871413e51d453b1e478b8e</a></p></li></ul><blockquote><p>行为型模式</p></blockquote><ul><li><p>责任链模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/11.chain-of-responsiblity/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/11.chain-of-responsiblity/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/ZA9vyCEkEg9_KTll-Jkcqw\">https://mp.weixin.qq.com/s/ZA9vyCEkEg9_KTll-Jkcqw</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5d7e4926e51d4561a705bbbc\">https://juejin.im/post/5d7e4926e51d4561a705bbbc</a></p></li><li><p>命令模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/09.command/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/09.command/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/meIF_xSo4pHRYBon7tqvfw\">https://mp.weixin.qq.com/s/meIF_xSo4pHRYBon7tqvfw</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5d6ccba15188252e96191b41\">https://juejin.im/post/5d6ccba15188252e96191b41</a></p></li><li><p>迭代器模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/07.iterator/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/07.iterator/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/uycac0OXYYjAG1BlzTUjsw\">https://mp.weixin.qq.com/s/uycac0OXYYjAG1BlzTUjsw</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5d5a3997e51d45620c1c53ba\">https://juejin.im/post/5d5a3997e51d45620c1c53ba</a></p></li><li><p>中介者模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/15.mediator/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/15.mediator/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/RS5HGDAO21LkKbf_JU-0Fw\">https://mp.weixin.qq.com/s/RS5HGDAO21LkKbf_JU-0Fw</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5d9e79b56fb9a04e343d5335\">https://juejin.im/post/5d9e79b56fb9a04e343d5335</a></p></li><li><p>备忘录模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/17.memento/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/17.memento/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/iXF_Vr2Z31tBfq8k0ZRqMA\">https://mp.weixin.qq.com/s/iXF_Vr2Z31tBfq8k0ZRqMA</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5da51488f265da5b6e0a4080\">https://juejin.im/post/5da51488f265da5b6e0a4080</a></p></li><li><p>观察者模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/06.observer/blod.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/06.observer/blod.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/SlSToMIGNBtU06BWNCwWvg\">https://mp.weixin.qq.com/s/SlSToMIGNBtU06BWNCwWvg</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5d4f93d46fb9a06ae439e53d\">https://juejin.im/post/5d4f93d46fb9a06ae439e53d</a></p></li><li><p>状态模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/22.state/blod.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/22.state/blod.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/-hhdecA38V0O0j2gFBE_8g\">https://mp.weixin.qq.com/s/-hhdecA38V0O0j2gFBE_8g</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5dbeea3be51d456e4871af33\">https://juejin.im/post/5dbeea3be51d456e4871af33</a></p></li><li><p>策略模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/10.strategy/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/10.strategy/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/BU6EHMvU9ssvBkUYdJtT9w\">https://mp.weixin.qq.com/s/BU6EHMvU9ssvBkUYdJtT9w</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5d7508d5f265da03b76b4653\">https://juejin.im/post/5d7508d5f265da03b76b4653</a></p></li><li><p>模板方法模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/20.template-method/blod.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/20.template-method/blod.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/2sX1ASQpnMybJ2xFqRR3Ig\">https://mp.weixin.qq.com/s/2sX1ASQpnMybJ2xFqRR3Ig</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5db63432e51d456bd1552325\">https://juejin.im/post/5db63432e51d456bd1552325</a></p></li><li><p>访问者模式</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>GitHub：<a href=\"https://github.com/zhangyue0503/designpatterns-php/blob/master/23.visitor/blog.md\">https://github.com/zhangyue0503/designpatterns-php/blob/master/23.visitor/blog.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>微信公众号：<a href=\"https://mp.weixin.qq.com/s/nXE_RQGSyx9rgs5-cTULUQ\">https://mp.weixin.qq.com/s/nXE_RQGSyx9rgs5-cTULUQ</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>掘金：<a href=\"https://juejin.im/post/5dc2124c518825108334bd09\">https://juejin.im/post/5dc2124c518825108334bd09</a></p></li></ul>', 'PHP', '设计模式', '2022-07-23 18:06:29', '2021-07-08 08:45:04', 1);
INSERT INTO `zy_articles_xs_test` VALUES (39, 'goto语法在PHP中的使用', '<h1>goto语法在PHP中的使用</h1><p>在C++、Java及很多语言中，都存在着一个神奇的语法，就是goto。顾名思义，它的使用是直接去到某个地方。从来代码的角度来说，也就是直接跳转到指定的地方。我们的PHP中也有这个功能，我们先来看看它是如何使用的：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">goto a;\necho \"1\"; // 不会输出\n\na:\necho \'2\'; // 2</code></pre></div><p>代码运行到goto位置时，就跳转到了a:所在的代码行并继续执行下去。感觉很好玩吧，这个功能对于复杂的嵌套if或者在一些循环中进行跳出很有用，特别是针对某些异常或者错误情况的处理，比如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">for ($i = 0, $j = 50; $i &lt; 100; $i++) {\n    while ($j--) {\n        if ($j == 17) { // 假设$j==17是一种异常情况\n            goto end; // 直接跳走了，循环结束的结果也不输出了\n        }\n\n    }\n}\necho \"i = $i\";\nend:\necho \'j hit 17\'; // 直接到这里输出或者处理异常情况了</code></pre></div><p>感觉还不错是吧，不过goto语法也有一些限制情况：</p><ul><li><p>目标位置只能位于同一个文件和作用域，也就是说无法跳出一个函数或类方法，也无法跳入到另一个函数</p></li><li><p>无法跳入到任何循环或者 switch 结构中</p></li><li><p>跳出循环或者 switch，通常的用法是用 goto 代替多层的 break</p></li></ul><p>比如以下的代码都是无效的：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$a = 1;\ngoto switchgo;\nswitch ($a){\n    case 1:\n        echo \'bb\';\n    break;\n    case 2:\n        echo \'cc\';\n        switchgo:\n            echo \"bb\";\n    break;\n}\n\ngoto whilego;\nwhile($a &lt; 10){\n    $a++;\n    whilego:\n        echo $a;\n}\n\n\n// Fatal error: \'goto\' to undefined label \'ifgo\' </code></pre></div><p>它们都会报同样的错误，因为作用域的关系无法找到定义的goto标签。另外还需要注意的，使用goto可能引起死循环，如下所示：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">b:\n    echo \'b\';\n\ngoto b;</code></pre></div><p>代码执行到goto时，跳回了之前的b标签行，然后继续向下执行，又到goto了，成为了一个死循环。有点像while(true)的感觉了。但是，在这个goto循环里是没有break的，只能在goto出去到别的地方。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>所以，goto这个语法的使用非常少，因为它会扰乱你的代码逻辑流程，但喜欢它的人又会感觉到可以让代码非常地灵活多变。这就要仁者见仁智者见智的进行选择了，目前大多数语言的文档中都并不是很提倡使用这个语法，包括PHP。我的建议是，如果不是非常特殊的情况或者是为了炫技，尽量不要使用goto语法，当项目代码复杂起来后，很容易让别人或者自己看懵。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：<a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/goto%E8%AF%AD%E6%B3%95%E5%9C%A8PHP%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.md\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/goto%E8%AF%AD%E6%B3%95%E5%9C%A8PHP%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：<a href=\"https://www.php.net/manual/zh/control-structures.goto.php\">https://www.php.net/manual/zh/control-structures.goto.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-06-27 09:02:48', 1);
INSERT INTO `zy_articles_xs_test` VALUES (40, '在PHP中灵活使用foreach+list处理多维数组', '<h1>在PHP中灵活使用foreach+list处理多维数组</h1><p>先抛出问题，有时候我们接收到的参数是多维数组，我们需要将他们转成普通的数组，比如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$arr = [\n    [1, 2, [3, 4]],\n    [5, 6, [7, 8]],\n];\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>我们需要的结果是元素1变成1,2,3,4，元素2变成5,6,7,8，这时候，我们就可以用foreach配合list来实现，而且非常简单：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nforeach ($arr as list($a, $b, list($c, $d))) {\n    echo $a, \',\', $b, \',\', $c, \',\', $d, PHP_EOL;\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>是不是非常的简单。但是要注意哦，list拆解键值对形式的Hash数组时要指定键名，并且只有在7.1以后的版本才可以使用哦</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n$arr = [\n    [\"a\" =&gt; 1, \"b\" =&gt; 2],\n    [\"a\" =&gt; 3, \"b\" =&gt; 4],\n];\n\nforeach ($arr as list(\"a\" =&gt; $a, \"b\" =&gt; $b)) {\n    echo $a, \',\', $b, PHP_EOL;\n}\n\nforeach ($arr as [\"a\" =&gt; $a, \"b\" =&gt; $b]) {\n    echo $a, \',\', $b, PHP_EOL;\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>注意：如果没有写键名，会输出空而不会报错，这是个BUG点，千万要注意。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上述代码中第二个写法更简单直观，由此发现我们还可以这样来拆解数组。并且指定键值了就不用在乎他们的顺序了：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n[\"b\" =&gt; $b, \"a\" =&gt; $a] = $arr[0];\necho $a, \',\', $b, PHP_EOL;\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>原来list()还有这样的语法糖，果然还是要不断的学习，一直使用却从未深入了解过的方法竟然能有这么多的用处。不多说了，接着研究手册中其他好玩的东西去咯！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：<a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/%E5%9C%A8PHP%E4%B8%AD%E7%81%B5%E6%B4%BB%E4%BD%BF%E7%94%A8foreach%2Blist%E5%A4%84%E7%90%86%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/%E5%9C%A8PHP%E4%B8%AD%E7%81%B5%E6%B4%BB%E4%BD%BF%E7%94%A8foreach%2Blist%E5%A4%84%E7%90%86%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-07-06 07:10:15', 1);
INSERT INTO `zy_articles_xs_test` VALUES (41, '对象赋值在PHP中到底是不是引用？', '<h1>对象赋值在PHP中到底是不是引用？</h1><p>之前的文章中，我们说过变量赋值的问题，其中有一个问题是对象在进行变量赋值的时候，直接就是引用赋值。那么到底真实情况是怎样呢？</p><blockquote><p>之前变量赋值的文章</p></blockquote><p><a href=\"https://mp.weixin.qq.com/s/EYGx3YQuQXgARRgpovuK-Q\">PHP的变量赋值</a></p><blockquote><p>对象引用测试</p></blockquote><p>在继续深入的学习PHP手册后，发现原来对象还真不是直接的引用复制。通过下面手册中的例子来进行分析：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class SimpleClass\n{}\n\n$instance = new SimpleClass();\n\n$assigned = $instance;\n$reference = &amp;$instance;\n\n$instance-&gt;var = \'$assigned will have this value\';\n\n$instance = null; // $instance and $reference become null\n\nvar_dump($instance);\nvar_dump($reference);\nvar_dump($assigned);</code></pre></div><ul><li><p>$instance是实例化后的SimpleClass对象</p></li><li><p>$assigned直接赋值</p></li><li><p>$reference引用赋值</p></li><li><p>首先，我们给$instance对象定义了一个变量var</p></li><li><p>然后将$instance赋值为null</p></li><li><p>对于引用来说，$reference变量自然也为成了null</p></li><li><p>但是$assigned并没有变成null，它依然是SimpleClass的实例对象，并且，划重点哦：它有了var属性</p></li></ul><p>是不是很神奇，照理说，普通赋值是拷贝，两个变量不会相互影响。而引用赋值是复制指针（相同的内存地址），修改任意一个变量其他的变量也会改变。但是对象的普通赋值貌似并不属于它们中的任何一个。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>$reference很好理解，本身使用&amp;符号进行了赋值，表明了这个变量是一个引用赋值。它成为了$instance的快捷方式，$instance的一切变化它都都会跟着改变。这是变量层面的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>$assigned从代码字面上看是一个普通赋值。不过对象是一种特殊的形态，它用普通赋值赋过来的值其实是对象的一个句柄。在PHP手册中有一个Note是如此描述的：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>首先，将PHP中的变量看成是一个一个的数据槽。这个数据槽可以保存一个基本类型（int、string、bool等）。创建引用时，这个槽里保存的是内存地址，或者说是指向引用对象的一个指针，引用没有拷贝操作，仅仅是将指针指向了原变量（参考数据结构）。创建普通赋值时，则是拷贝的基本类型。</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>而对象则与基本类型不同，它不能直接保存在数据槽中，而是将对象的“句柄”保存在了数据槽。这个句柄是指向对象特定实例的标识符。虽然句柄不是我们所能直观操作的类型，但它也属于基本类型。</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>当你获取一个包含对象句柄的变量，并将其分配给另一个变量时，另一个变量获取的是这个对象的句柄。（注意，不是引用！不是引用！不是引用！！）。通过句柄，两个变量都可以修改同一个对象。但是，这两个变量并没有直接关系，它们是两个独立的变量，其中一个变量修改为其他值时，并不会对另一个变量产生影响。只有该变量在修改对象内部的内容时，另一个变量因为持有相同的句柄，所以它的对象内容也会相应地发生改变。</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>Note原文：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.basic.php#79856\">https://www.php.net/manual/zh/language.oop5.basic.php#79856</a></p><blockquote><p>总结</p></blockquote><p>通过本文的分析，我们可以看出，变量赋值说白了就是变量层面的操作。它保存的永远只是一个值而已。当普通赋值时，这个值就是一个基本类型。当引用赋值时，这个保存的基本类型就是一个指针。不管怎么样，它也不会因为保存的是对象而将普通赋值直接转变为引用赋值，真正的引用赋值是必须要加&amp;符的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这个内容有点绕，不过这样的内容才能更体现自己的核心能力。读书百遍其义自现，对于手册中的很多知识本人也是来回不断学习才能理解。上面的Note作者写得非常好，英文好的朋友可以直接去看英文原版。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E5%9C%A8PHP%E4%B8%AD%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BC%95%E7%94%A8%EF%BC%9F.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E5%9C%A8PHP%E4%B8%AD%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BC%95%E7%94%A8%EF%BC%9F.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.basic.php\">https://www.php.net/manual/zh/language.oop5.basic.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-03-26 18:05:02', 1);
INSERT INTO `zy_articles_xs_test` VALUES (42, '彻底搞明白PHP中的include和require', '<h1>彻底搞明白PHP中的include和require</h1><p>在PHP中，有两种包含外部文件的方式，分别是include和require。他们之间有什么不同呢？</p><blockquote><p>如果文件不存在或发生了错误，require产生E_COMPILE_ERROR级别的错误，程序停止运行。而include只产生警告，脚本会继续执行。</p></blockquote><p>这就是它们最主要的区别，其他方面require基本等同于include。</p><ul><li><p>被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 include_path 指定的目录寻找。如果在 include_path 下没找到该文件则 include 最后才在调用脚本文件所在的目录和当前工作目录下寻找</p></li><li><p>如果定义了路径不管是绝对路径还是当前目录的相对路径 include_path 都会被完全忽略</p></li><li><p>include_path 在php.ini中定义</p></li><li><p>当一个文件被包含时，其中所包含的代码继承了 include 所在行的变量范围。从该处开始，调用文件在该行处可用的任何变量在被调用的文件中也都可用。不过所有在包含文件中定义的函数和类都具有全局作用域</p></li></ul><p>除了普通的require和include之外，还有require_once和include_once，他们的作用是：</p><ul><li><p>如果该文件中已经被包含过，则不会再次包含。如同此语句名字暗示的那样，只会包含一次</p></li><li><p>可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题</p></li></ul><p>我们来看些例子：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\n// a.php 不存在\ninclude \"a.php\"; // warning\n// require \"a.php\"; // error\n\necho 111; // 使用include时111会输出\n\n// file1.php 中只有一行代码echo \'file1\';\nrequire_once \'includeandrequire/file1.php\'; // file1\nrequire_once \'includeandrequire/file1.php\'; // noting\n\ninclude_once \'includeandrequire/file1.php\'; // noting\ninclude_once \'includeandrequire/file1.php\'; // noting\n\nrequire \'includeandrequire/file1.php\'; // file1\nrequire \'includeandrequire/file1.php\'; // file1\n\nrequire \'includeandrequire/file1.php\'; // file1\nrequire \'includeandrequire/file1.php\'; // file1\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>我们可以看出当第一个_once加载成功后，后面不管是require_once还是include_once，都不会再加载这个文件了。而不带_once的则会重复加载文件。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfile2.php\n\n&lt;?php\n\necho \'file2:\' . $a, PHP_EOL;\necho \'file2:\' . $b, PHP_EOL;\n$b = \"file2\";\n\nmyFile.php\n\n&lt;?php\n\n$a = \'myFile\';\n$b = \'youFile\';\nrequire_once \'includeandrequire/file2.php\';\necho $a, PHP_EOL;\necho $b, PHP_EOL;\n\n// 输出结果\n// file2:myFile\n// file2:youFile\n// myFile\n// file2\n\nfile3.php\n&lt;?php\n\n$c = \'file3\';\n\nmyFile.php\n&lt;?php\nfunction test(){\n    require_once \'includeandrequire/file3.php\';\n    echo $c, PHP_EOL; // file3\n}\ntest();\necho $c, PHP_EOL; // empty\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>被包含文件中可以获取到父文件中的变量，父文件也可以获得包含文件中的变量，但是，需要注意_once的一个特殊情况。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction foo(){\n    require_once \'includeandrequire/file3.php\';\n    return $c;\n}\n\nfor($a=1;$a&lt;=5;$a++){\n    echo foo(), PHP_EOL;\n}\n\n// file3\n// empty\n// empty\n// empty\n// empty\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>使用_once并循环加载时，只有第一次会输出file3.php中的内容，这是为什么呢？因为现在的变量范围作用域在方法中，第一次加载完成后，后面的的文件不会再被加载了，这时后面四次循环并没有$c被定义，$c默认就是空值了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>如果两个方法中同时用_once加载了一个文件，第二个方法还会加载吗？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction test1(){\n    require_once \'includeandrequire/file1.php\';\n}\nfunction test2(){\n    require_once \'includeandrequire/file1.php\';\n}\ntest1(); // file1\ntest2(); // empty\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>抱歉，只有第一个方法会加载成功，第二个方法不会再次加载了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>那么，我们在日常的开发中，使用哪个更好呢？</p><ul><li><p>从效率来说，_once需要验证是否已经加载过文件，效率会低一些，但是并不是绝对的，甚至是我们肉眼不可见的降低，所以可以忽略它的效率问题。而它带来的好处则比不带_once的多得多</p></li><li><p>本着错误提前的原则，使用require_once更好。因为将PHP报错级别调整为不显示警告后，include的警告信息会不可见，会带来不可预知的错误</p></li><li><p>在方法中使用时，不应该用_once来加载文件，特别是这个文件需要在多个类或者方法中使用时，使用_once可能会导致后面的方法中无法载相同的文件</p></li><li><p>使用require或include时，最好不要用括号，虽然的确可以这么使用，如 include (\'xxx.php\'); 它们是表达式关键字，不是系统方法，所以直接用 include \'xxx.php\' 即可</p></li></ul><p>include和require的文件如果有return，可以用变量接收retun回来的数据，另外它们还可以加载非PHP文件以及远程文件（远程加载需要确定php.ini中的allow_url_include为On），如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfile4.php\n&lt;?php\n\nreturn \'file4\';\n\nfile4.txt\n可以吧\n\nmyFile.php\n&lt;?php\n$v = require \'includeandrequire/file4.php\';\necho $v, PHP_EOL; // file4\n\ninclude \'includeandrequire/file4.txt\';\n// 可以吧\n\ninclude \'https://www.baidu.com/index.html\';\n// 百度首页的html代码\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>这下我们对于include和require的了解就非常深入了吧，这两个加载文件的方式并不复杂，但也很容易出现一些坑，特别是_once在方法中使用的时候一定要特别注意。最后，给一个小福利，封装一个一次性加载目录中所有文件的方法：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nfunction include_all_once ($pattern) {\n    foreach (glob($pattern) as $file) { \n        require $file;\n    }\n}\n\ninclude_all_once(\'includeandrequire/*\');\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>测试代码：<a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%98%8E%E7%99%BDPHP%E4%B8%AD%E7%9A%84include%E5%92%8Crequire.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201911/source/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%98%8E%E7%99%BDPHP%E4%B8%AD%E7%9A%84include%E5%92%8Crequire.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/function.require.php\">https://www.php.net/manual/zh/function.require.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.include.php\">https://www.php.net/manual/zh/function.include.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.require-once.php\">https://www.php.net/manual/zh/function.require-once.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.include-once.php\">https://www.php.net/manual/zh/function.include-once.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-11-02 04:40:20', 1);
INSERT INTO `zy_articles_xs_test` VALUES (43, 'PHP中的“重载”是个啥？', '<h1>PHP中的“重载”是个啥？</h1><p>很多面试官在面试的时候都会问一些面向对象的问题，面向对象的三大特性中，多态最主要的实现方式就是方法的重载和重写。但是在PHP中，只有重写，并没有完全的重载能力的实现。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>重写，子类重写父类方法。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 重写\nclass A\n{\n    public function test($a)\n    {\n        echo \'This is A：\' . $a, PHP_EOL;\n    }\n}\n\nclass childA extends A\n{\n    public function test($a)\n    {\n        echo \'This is A child：\' . $a, PHP_EOL;\n    }\n}\n\n$ca = new childA();\n$ca-&gt;test(1);</code></pre></div><p>这个在PHP中是没有任何问题的，子类可以重写父类的方法。当实例化子类的时候，调用的就是子类实现的重写的方法。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>重载，相同方法名但参数数量或者类型不同。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class A{\n    function foo($a){\n        echo $a;\n    }\n    // Fatal error: Cannot redeclare A::foo()\n    function foo($a, $b){\n        echo $a+$b;\n    }\n}</code></pre></div><p>抱歉，这样写的结果将会是直接的报错。PHP并不支持这样的重载能力。而在PHP的官方手册上，重载的定义是使用__set()、__get()、__call()、__callStatic()等魔术方法来对无法访问的变量或方法进行重载。这与我们所学习的面向对象中的重载完全不同，在手册中的note里也有很多人对此提出了疑问。当然，我们今天并不会再去讲这些魔术方法的使用。关于它们的使用可以参考我们之前写过的文章：<a href=\"https://mp.weixin.qq.com/s/QXCH0ZttxhuEBLQWrjB2_A\">PHP中的那些魔术方法（一）</a>、<a href=\"https://mp.weixin.qq.com/s/8WgQ3eVYKjGaEd2CwnB0Ww\">PHP的那些魔术方法（二）</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>那么，在PHP中可以实现重载吗？当然可以，只不过会麻烦一些：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 重载\nclass B\n{\n    public function foo(...$args)\n    {\n        if (count($args) == 2) {\n            $this-&gt;fooAdd(...$args);\n        } else if (count($args) == 1) {\n            echo $args[0], PHP_EOL;\n        } else {\n            echo \'other\';\n        }\n    }\n\n    private function fooAdd($a, $b)\n    {\n        echo $a + $b, PHP_EOL;\n    }\n}\n\n$b = new B();\n$b-&gt;foo(1);\n$b-&gt;foo(1, 2);</code></pre></div><p>使用一个方法来调用其他方法，根据参数数量来进行判断，就可以实现参数数量不同的方法重载。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 使用__call()进行重载\nclass C\n{\n    public function __call($name, $args)\n    {\n        if ($name == \'foo\') {\n            $funcIndex = count($args);\n            if (method_exists($this, \'foo\' . $funcIndex)) {\n                return $this-&gt;{\'foo\' . $funcIndex}(...$args);\n            }\n        }\n    }\n\n    private function foo1($a)\n    {\n        echo $a, PHP_EOL;\n    }\n\n    private function foo2($a, $b)\n    {\n        echo $a + $b, PHP_EOL;\n    }\n\n    private function foo3($a, $b, $c)\n    {\n        echo $a + $b + $c, PHP_EOL;\n    }\n\n}\n\n$c = new C();\n$c-&gt;foo(1);\n$c-&gt;foo(1, 2);\n$c-&gt;foo(1, 2, 3);</code></pre></div><p>使用__call()魔术方法或许会更简单，但也会让一些新手在接手项目的时候蒙圈。毕竟魔术方法对IDE是不友好的，这样的开发让__call()成为了一个模板方法，由它来定义操作的算法骨架。我们也可以根据参数类型来模拟重载能力。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 参数类型不同的重载\nclass D {\n    function __call($name, $args){\n        if($name == \'foo\'){\n            if(is_string($args[0])){\n                $this-&gt;fooString($args[0]);\n            }else {\n                $this-&gt;fooInt($args[0]);\n            }\n        }\n    }\n    private function fooInt(int $a){\n        echo $a . \' is Int\', PHP_EOL;\n    }\n\n    private function fooString(string $a){\n        echo $a . \' is String\', PHP_EOL;\n    }\n}\n\n$d = new D();\n$d-&gt;foo(1);\n$d-&gt;foo(\'1\');</code></pre></div><p>不管怎么说，用上述方法实现的方法重载都非常麻烦，因为会让某一个方法或者魔术方法非常重，它需要成为一个控制器来根据参数对内部的方法进行调度。更多的情况下，我们应该还是使用不同的方法名然后抽象公共的部分提取成独立的私有内部方法来实现不同方法名的“重载”。毕竟不同的语言还是要掌握它们不同的个性，并且根据这些个性灵活地运用在我们的项目中。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/PHP%E4%B8%AD%E7%9A%84%E2%80%9C%E9%87%8D%E8%BD%BD%E2%80%9D%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/PHP%E4%B8%AD%E7%9A%84%E2%80%9C%E9%87%8D%E8%BD%BD%E2%80%9D%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.overloading.php#77843\">https://www.php.net/manual/zh/language.oop5.overloading.php#77843</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-09-11 20:24:25', 1);
INSERT INTO `zy_articles_xs_test` VALUES (44, 'PHP中类的自动加载', '<h1>PHP中类的自动加载</h1><p>在之前，我们已经学习过Composer自动加载的原理，其实就是利用了PHP中的类自动加载的特性。在文末有该系列文章的链接。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>PHP中类的自动加载主要依靠的是__autoload()和spl_autoload_register()这两个方法。今天我们就来简单的看一下这两个方法的使用。</p><h3><strong>__autoload()</strong></h3><p>做为一个已经快要被淘汰的魔术方法，我们只需要了解即可。如果在PHP7中使用这个方法的话，会报出过时的警告，系统会建议我们使用spl_autoload_register()方法。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function __autoload($name){\n    include __DIR__ . \'/autoload/\' . $name . \'.class.php\';\n}\n\n$autoA = new AutoA();\nvar_dump($autoA);</code></pre></div><p>当我们实例化AutoA类时，当前的文件并没有这个类，也没有从其他文件中include或者require，这时，就会自动进入魔术方法__autoload()中。我们在__autoload()方法中只需要去include这个类所在的文件即可。</p><h3><strong>spl_autoload_register()</strong></h3><p>这个方法目前已经替代了上述魔术方法自动加载类的功能。它是spl扩展库中的一个方法，spl扩展库现在已经默认集成在了PHP中，大家可以放心地直接使用。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>spl_autoload_register()相对于__autoload()的好处是它可以去注册一个__autoload()，并且实现并维护了一个__autoload()队列。原来在一个文件中只能有一个__autoload()方法，但现在，你拥有的是一个队列。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这样，你就不需要将所有加载代码都写在一个__autoload()方法中，而是可以使用多个spl_autoload_register()去单独进行每个类的加载处理。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">spl_autoload_register(function($name){\n    include __DIR__ . \'/autoload/\' . $name . \'.class.php\';\n});\n\n$autoA = new AutoA();\nvar_dump($autoA);</code></pre></div><p>参考：<a href=\"https://mp.weixin.qq.com/s/KzRSF12WzFvHqpdHFSk_3w\">深入学习Composer原理（二）</a></p><h3><strong>使用include还是include_once</strong></h3><p>在自动加载中，我们只需要使用include就可以了，类并不会重复加载。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">spl_autoload_register(function($name){\n    include __DIR__ . \'/autoload/\' . $name . \'.class.php\';\n    echo $name, PHP_EOL;\n});\n\n$autoA = new AutoA();\nvar_dump($autoA);\n\n$autoA = new AutoA();\nvar_dump($autoA);\n\n$autoA = new AutoA();\nvar_dump($autoA);\n\n$autoB = new AutoB();\nvar_dump($autoB);</code></pre></div><p>从代码中，我们可以看出$name在多次实例化类的情况下只被输出了一次。所以并不需要关心会有类文件重复加载的问题。而且在大型框架中使用composer的时候会加载非常多的类，_once方法也会带来效率的问题。</p><h3><strong>总结</strong></h3><p>这次的文章只是对类自动加载进行了简单的介绍，想深入了解这方面知识的可以移步之前写过的Composer系列文章：</p><ul><li><p><a href=\"https://mp.weixin.qq.com/s/fHWBqDu4xrixMhxh3eftkA\">深入学习Composer原理（一）</a></p></li><li><p><a href=\"https://mp.weixin.qq.com/s/KzRSF12WzFvHqpdHFSk_3w\">深入学习Composer原理（二）</a></p></li><li><p><a href=\"https://mp.weixin.qq.com/s/jkNf8_HU3swnMH4pFMyADA\">深入学习Composer原理（三）</a></p></li><li><p><a href=\"https://mp.weixin.qq.com/s/EEDjqzLcKaAJhQ-VWDBX8w\">深入学习Composer原理（四）</a></p></li></ul><p>测试代码：<a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/PHP%E4%B8%AD%E7%B1%BB%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/PHP%E4%B8%AD%E7%B1%BB%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.autoload.php\">https://www.php.net/manual/zh/language.oop5.autoload.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-07-29 23:17:44', 1);
INSERT INTO `zy_articles_xs_test` VALUES (45, 'PHP匿名类的用法', '<h1>PHP匿名类的用法</h1><p>在PHP7之后，PHP中加入了匿名类的特性。匿名类和匿名方法让PHP成为了更现代化的语言，也让我们的代码开发工作越来越方便。我们先来看看匿名类的简单使用。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 直接定义\n$objA = new class\n\n{\n    public function getName()\n    {\n        echo \"I\'m objA\";\n    }\n};\n$objA-&gt;getName();\n\n// 方法中返回\nfunction testA()\n{\n    return new class\n\n    {\n        public function getName()\n        {\n            echo \"I\'m testA\'s obj\";\n        }\n    };\n}\n\n$objB = testA();\n$objB-&gt;getName();\n\n// 作为参数\nfunction testB($testBobj)\n{\n    echo $testBobj-&gt;getName();\n}\ntestB(new class{\n        public function getName()\n    {\n            echo \"I\'m testB\'s obj\";\n        }\n    });</code></pre></div><p>一次性给出了三种匿名类的使用方法。匿名类可以直接定义给变量，可以在方法中使用return返回，也可以当做参数传递给方法内部。其实，匿名类就像一个没有事先定义的类，而在定义的时候直接就进行了实例化。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 继承、接口、访问控制等\nclass A\n{\n    public $propA = \'A\';\n    public function getProp()\n    {\n        echo $this-&gt;propA;\n    }\n}\ntrait B\n{\n    public function getName()\n    {\n        echo \'trait B\';\n    }\n}\ninterface C\n{\n    public function show();\n}\n$p4 = \'b4\';\n$objC = new class($p4) extends A implements C\n{\n    use B;\n    private $prop1 = \'b1\';\n    protected $prop2 = \'b2\';\n    public $prop3 = \'b3\';\n\n    public function __construct($prop4)\n    {\n        echo $prop4;\n    }\n\n    public function getProp()\n    {\n        parent::getProp();\n        echo $this-&gt;prop1, \'===\', $this-&gt;prop2, \'===\', $this-&gt;prop3, \'===\', $this-&gt;propA;\n        $this-&gt;getName();\n        $this-&gt;show();\n    }\n    public function show()\n    {\n        echo \'show\';\n    }\n};\n\n$objC-&gt;getProp();</code></pre></div><p>匿名类和普通类一样，可以继承其他类，可以实现接口，当然也包括各种访问控制的能力。也就是说，匿名类在使用方面和普通类并没有什么不同。但如果用get_class()获取类名将是系统自动生成的类名。相同的匿名类返回的名称当然也是相同的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 匿名类的名称是通过引擎赋予的\nvar_dump(get_class($objC));\n\n// 声明的同一个匿名类，所创建的对象都是这个类的实例\nvar_dump(get_class(testA()) == get_class(testA()));</code></pre></div><p>那么匿名类中的静态成员呢？当然也和普通类一样，静态成员是属于类而不是实例的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 静态变量\nfunction testD()\n{\n    return new class{\n        public static $name;\n    };\n}\n$objD1 = testD();\n$objD1::$name = \'objD1\';\n\n$objD2 = testD();\n$objD2::$name = \'objD2\';\n\necho $objD1::$name;</code></pre></div><p>当类中的静态变量修改时，所有类实例的这个静态变量都会跟着变化。这也是普通类静态成员的特性。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/PHP%E5%8C%BF%E5%90%8D%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/PHP%E5%8C%BF%E5%90%8D%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.anonymous.php\">https://www.php.net/manual/zh/language.oop5.anonymous.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-08-17 03:19:38', 1);
INSERT INTO `zy_articles_xs_test` VALUES (46, 'PHP怎么遍历对象？', '<h1>PHP怎么遍历对象？</h1><p>对于php来说，foreach是非常方便好用的一个语法，几乎对于每一个PHPer它都是日常接触最多的请求之一。那么对象是否能通过foreach来遍历呢？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>答案是肯定的，但是有个条件，那就是对象的遍历只能获得它的公共属性。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 普通遍历\nclass A\n{\n    public $a1 = \'1\';\n    public $a2 = \'2\';\n    public $a3 = \'3\';\n\n    private $a4 = \'4\';\n    protected $a5 = \'5\';\n\n    public $a6 = \'6\';\n\n    public function test()\n    {\n        echo \'test\';\n    }\n}\n$a = new A();\nforeach ($a as $k =&gt; $v) {\n    echo $k, \'===\', $v, PHP_EOL;\n}\n\n// a1===1\n// a2===2\n// a3===3\n// a6===6</code></pre></div><p>不管是方法还是受保护或者私有的变量，都无法遍历出来。只有公共的属性才能被遍历出来。其实，我们之前在讲设计模式时讲过的<strong>迭代器模式</strong>就是专门用来进行对象遍历的，而且PHP已经为我们准备好了相关的接口，我们只需要去实现这个接口就可以完成迭代器模式的创建了。具体的内容可以参考之前的设计模式系列文章：<a href=\"https://mp.weixin.qq.com/s/uycac0OXYYjAG1BlzTUjsw\">PHP设计模式之迭代器模式</a></p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 实现迭代器接口\nclass B implements Iterator\n{\n    private $var = [];\n\n    public function __construct($array)\n    {\n        if (is_array($array)) {\n            $this-&gt;var = $array;\n        }\n    }\n\n    public function rewind()\n    {\n        echo \"rewinding\\n\";\n        reset($this-&gt;var);\n    }\n\n    public function current()\n    {\n        $var = current($this-&gt;var);\n        echo \"current: $var\\n\";\n        return $var;\n    }\n\n    public function key()\n    {\n        $var = key($this-&gt;var);\n        echo \"key: $var\\n\";\n        return $var;\n    }\n\n    public function next()\n    {\n        $var = next($this-&gt;var);\n        echo \"next: $var\\n\";\n        return $var;\n    }\n\n    public function valid()\n    {\n        $var = $this-&gt;current() !== false;\n        echo \"valid: {$var}\\n\";\n        return $var;\n    }\n}\n\n$b = new B([1, 2, 3, 4]);\n\nforeach ($b as $k =&gt; $v) {\n    echo $k, \'===\', $v, PHP_EOL;\n}\n\n// rewinding\n// current: 1\n// valid: 1\n// current: 1\n// key: 0\n// 0===1\n// next: 2\n// current: 2\n// valid: 1\n// current: 2\n// key: 1\n// 1===2\n// next: 3\n// current: 3\n// valid: 1\n// current: 3\n// key: 2\n// 2===3\n// next: 4\n// current: 4\n// valid: 1\n// current: 4\n// key: 3\n// 3===4\n// next:\n// current:\n// valid:</code></pre></div><p>假如今天的文章只是讲之前讲过的迭代器模式，那就太没意思了，所以，咱们还要来学习一个更有意思的应用。那就是让对象可以像数组一样进行操作。这个其实也是使用PHP早已为我们准备好的一个接口：ArrayAccess。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 让类可以像数组一样操作\nclass C implements ArrayAccess, IteratorAggregate\n{\n    private $container = [];\n    public function __construct()\n    {\n        $this-&gt;container = [\n            \"one\" =&gt; 1,\n            \"two\" =&gt; 2,\n            \"three\" =&gt; 3,\n        ];\n    }\n    public function offsetSet($offset, $value)\n    {\n        if (is_null($offset)) {\n            $this-&gt;container[] = $value;\n        } else {\n            $this-&gt;container[$offset] = $value;\n        }\n    }\n    public function offsetExists($offset)\n    {\n        return isset($this-&gt;container[$offset]);\n    }\n    public function offsetUnset($offset)\n    {\n        unset($this-&gt;container[$offset]);\n    }\n    public function offsetGet($offset)\n    {\n        return isset($this-&gt;container[$offset]) ? $this-&gt;container[$offset] : null;\n    }\n\n    public function getIterator() {\n        return new B($this-&gt;container);\n    }\n}\n\n$c = new C();\nvar_dump($c);\n\n$c[\'four\'] = 4;\nvar_dump($c);\n\n$c[] = 5;\n$c[] = 6;\nvar_dump($c);\n\nforeach($c as $k=&gt;$v){\n    echo $k, \'===\', $v, PHP_EOL;\n}\n\n// rewinding\n// current: 1\n// valid: 1\n// current: 1\n// key: one\n// one===1\n// next: 2\n// current: 2\n// valid: 1\n// current: 2\n// key: two\n// two===2\n// next: 3\n// current: 3\n// valid: 1\n// current: 3\n// key: three\n// three===3\n// next: 4\n// current: 4\n// valid: 1\n// current: 4\n// key: four\n// four===4\n// next: 5\n// current: 5\n// valid: 1\n// current: 5\n// key: 0\n// 0===5\n// next: 6\n// current: 6\n// valid: 1\n// current: 6\n// key: 1\n// 1===6\n// next: \n// current: \n// valid: </code></pre></div><p>这个接口需要我们实现四个方法：</p><ul><li><p>offsetSet($offset, $value)，根据偏移量设置值</p></li><li><p>offsetExists($offset)，根据偏移量确定是否存在内容</p></li><li><p>offsetUnset($offset)，根据偏移量删除内容</p></li><li><p>offsetGet($offset)，根据依稀量获取内容</p></li></ul><p>这里的偏移量就是我们常说的下标。通过实现这四个方法，我们就可以像操作数组一样的操作对象。当然，日常开发中我们可能并不会很经常的使用包括迭代器在内的这些对象遍历的能力。通常我们会直接去将对象转换成数组 (array) obj 来进行下一步的操作。不过，在java中，特别是JavaBean中会经常在类的内部有一个 List 为自己的对象来表示自身的集合状态。通过对比，我们发现PHP也完全可以实现这样的能力，而且使用迭代器和 ArrayAccess 接口还能够更方便的实现类似的能力。这是非常有用的一种知识扩展，或许下一个项目中你就能运用上这些能力哦！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/PHP%E6%80%8E%E4%B9%88%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%EF%BC%9F.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/PHP%E6%80%8E%E4%B9%88%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%EF%BC%9F.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.iterations.php\">https://www.php.net/manual/zh/language.oop5.iterations.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-01-01 12:26:12', 1);
INSERT INTO `zy_articles_xs_test` VALUES (47, 'PHP类中访问控制的一些Tips', '<h1>PHP类中访问控制的一些Tips</h1><p>包括PHP在内的大部分面向对象的编程语言，都提供了对类的变量或方法的访问控制。这是实现面向对象封装能力的基础。变量其实就是数据，而方法函数就是处理这些数据的操作，根据最少知识原则，一些数据你不需要知道它的存在。这时，就需要使用private私有的变量和方法，私有的变量或方法只有这个类自己可以访问。而有些变量和方法自己的子类需要使用，但又不能暴露给外部，那么我们就会使用protected，也就是受保护的。最后就是公开不管类内部、外部还是继承的子类都可以使用的public公共变量或方法了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们通过变量的访问控制先来复习一下这三种访问控制符的作用。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class A {\n    private $private;\n    protected $protected;\n    public $public;\n\n    public function setPrivate($p){\n        $this-&gt;private = $p;\n    }\n\n    public function setProtected($p){\n        $this-&gt;protected = $p;\n    }\n\n    public function setPublic($p){\n        $this-&gt;public = $p;\n    }\n\n    public function testA(){\n        echo $this-&gt;private, \'===\', $this-&gt;protected, \'===\', $this-&gt;public, PHP_EOL;\n    }\n}\n\nclass B extends A{\n    public function testB(){\n        echo $this-&gt;private, \'===\';\n        echo $this-&gt;protected, \'===\', $this-&gt;public, PHP_EOL;\n    }\n}\n\n$a = new A();\n// $a-&gt;private = \'a-private\'; // atal error: Uncaught Error: Cannot access private property A::$private \n$a-&gt;setPrivate(\'a-private\');\n// $a-&gt;protected = \'a-protected\'; // atal error: Uncaught Error: Cannot access protected property A::$protected \n$a-&gt;setProtected(\'a-protected\');\n$a-&gt;public = \'c-public\';\n$a-&gt;testA();\n\necho \"Out side public:\" . $a-&gt;public, PHP_EOL;\n// echo \"Out side private:\" . $a-&gt;private, PHP_EOL; // Fatal error: Uncaught Error: Cannot access private property A::$private\n// echo \"Out side protected:\" . $a-&gt;protected, PHP_EOL; // Fatal error: Uncaught Error: Cannot access protected property A::$protected\n\n$b = new B();\n$b-&gt;setProtected(\'b-protected\');\n$b-&gt;public = \'b-public\';\n$b-&gt;testB(); // 没有b-private\n\n$b-&gt;setPrivate(\'b-private\');\n$b-&gt;testB(); // 没有b-private\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>从上述代码中很清晰的可以看出，除了public之外的变量都不能在类外部直接调用或者赋值。所以我们使用setXXX()的public方法来为$private和$protected赋值。这里就出现了封装的概念了，比如在setPrivate()中我们就可以对传递过来的$p变量进行逻辑判断而决定是否将值赋给$private。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>B类继承了A类，所以它可以访问到A类的$public和$protected变量，但是，请注意，$private变量是无法访问到的。所以即使调用了setPrivate()方法为$private赋值了，但因为B无法访问，所以依然取不到$private的值。有小伙伴要问了，这种情况不报错？当然不会报错，B类会在自己的范围内查找$private变量，没有定义的话就会生成一个局部的变量并赋值为空。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>那么子类要使用$private应该怎么办呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class C extends A {\n    private $private;\n\n    public function testC(){\n        echo $this-&gt;private, \'===\', $this-&gt;protected, \'===\', $this-&gt;public, PHP_EOL;\n    }\n\n    // public function setPrivate($p){\n    //     $this-&gt;private = $p;\n    // }\n}\n\n$c = new C();\n$c-&gt;setProtected(\'c-protected\');\n$c-&gt;public = \'c-public\';\n$c-&gt;setPrivate(\'c-private\');\n$c-&gt;testC();</code></pre></div><p>先不要打开C类setPrivate()方法的注释，你会发现$private依然是空值。也就是说，定义了同名的$private私有变量并不是对父类的变量覆盖，而是在本类作用域内新建了一个。父类的setPrivate()方法当然也不能访问子类的private变量，因此，子类也要重写一个setPrivate()方法来为自己的$private变量赋值。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>记住一点：<strong>private修饰的变量或方法仅对当前类开放</strong></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>对于方法的修饰也是一样的效果。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class D {\n    public function testD(){\n        $this-&gt;show();\n    }\n    private function show(){\n        echo \'This is D\', PHP_EOL;\n    }\n}\n\nclass E extends D {\n    private function show(){\n        echo \'This is E\', PHP_EOL;\n    }\n}\n\n$e = new E();\n$e-&gt;testD(); // This is D</code></pre></div><p>子类E调用父类D的testD()方法，testD()方法中调用的是private修饰的show()方法，根据上面的原则，它依然调用的是自己D类的show()方法。</p><h3><strong>总结</strong></h3><p>关于访问控制的内容还是比较简单的，最主要的就是private这个修饰符的问题需要注意，其他的其实还是比较好理解的。不过越是简单的东西越是基础，面向对象脱离不了这三个简单的访问修饰符，它们在现代软件开发中的份量十足，只有牢牢掌握它们才是我们正确的学习之道。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/PHP%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9BTips.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/PHP%E7%B1%BB%E4%B8%AD%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9BTips.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.visibility.php#87413\">https://www.php.net/manual/zh/language.oop5.visibility.php#87413</a></p><p><a href=\"https://www.php.net/manual/zh/language.oop5.visibility.php#110555\">https://www.php.net/manual/zh/language.oop5.visibility.php#110555</a></p><p><a href=\"https://www.php.net/manual/zh/language.oop5.visibility.php\">https://www.php.net/manual/zh/language.oop5.visibility.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-11-10 21:47:07', 1);
INSERT INTO `zy_articles_xs_test` VALUES (48, 'final关键字在PHP中的使用', '<h1>final关键字在PHP中的使用</h1><p>final关键字的使用非常简单，在PHP中的最主要作用是定义不可重写的方法。什么叫不可重写的方法呢？就是子类继承后也不能重新再定义这个同名的方法。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class A {\n    final function testA(){\n        echo \'This is class A!\', PHP_EOL;\n    }\n}\n\nclass childA extends A {\n    //  Fatal error: Cannot override final method A::testA()\n    function testA(){\n        echo \'This is class childA\', PHP_EOL;\n    }\n}</code></pre></div><p>而如果在类定义前加上这个关键字的话，则类也是不可继承的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">final class B {\n    function testB(){\n        echo \'This is class B!\', PHP_EOL;\n    }\n}\n\n// Fatal error: Class childB may not inherit from final class (B)\nclass childB extends B{\n\n}</code></pre></div><p>由此可见，final关键字就和他本身的意义一样，这个类或者方法是不可改变的。那么接口能不能用这个关键字呢？答案当然是否定的，接口的意义本身就是定义一个契约让实现类来实现，如果定义了final关键字，那么接口的意义就不存在了，所以从语言层面来说接口以及接口中的方法就不能使用final关键字。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">interface C {\n    // Fatal error: Access type for interface method C::testC() must be omitted \n    final function testC();\n}</code></pre></div><p>在Java中，final还可以用来定义常量，但在PHP中，类常量是通过const来定义的。所以final定义不了变量。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/final%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8PHP%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/final%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8PHP%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.final.php\">https://www.php.net/manual/zh/language.oop5.final.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-10-21 06:50:42', 1);
INSERT INTO `zy_articles_xs_test` VALUES (49, 'trait能力在PHP中的使用', '<h1>trait能力在PHP中的使用</h1><p>相信大家对trait已经不陌生了，早在5.4时，trait就已经出现在了PHP的新特性中。当然，本身trait也是特性的意思，但这个特性的主要能力就是为了代码的复用。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们都知道，PHP是现代化的面向对象语言。为了解决C++多重继承的混乱问题，大部分语言都是单继承多接口的形式，但这也会让一些可以复用的代码必须通过组合的方式来实现，如果要用到组合，不可避免的就要实例化类或者使用静态方法，无形中增加了内存的占用。而PHP为了解决这个问题，就正式推出了trait能力。你可以把它看做是组合能力的一种变体。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">trait A\n{\n    public $a = \'A\';\n    public function testA()\n    {\n        echo \'This is \' . $this-&gt;a;\n    }\n}\n\nclass classA\n{\n    use A;\n}\nclass classB\n{\n    use A;\n    public function __construct()\n    {\n        $this-&gt;a = \'B\';\n    }\n}\n\n$a = new classA();\n$b = new classB();\n\n$a-&gt;testA();\n$b-&gt;testA();</code></pre></div><p>从上述代码中，我们可以看出，trait可以给应用于任意一个类中，而且可以定义变量，非常方便。trait最需要注意的是关于同名方法的重载优先级问题。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">trait B {\n    function test(){\n        echo \'This is trait B!\';\n    }\n}\ntrait C {\n    function test(){\n        echo \'This is trait C!\';\n    }\n}\n\nclass testB{\n    use B, C;\n    function test(){\n        echo \'This is class testB!\';\n    }\n}\n\n$b = new testB();\n$b-&gt;test(); // This is class testB!\n// class testC{\n//     use B, C;\n// }\n\n// $c = new testC();\n// $c-&gt;test(); // Fatal error: Trait method test has not been applied, because there are collisions with other trait methods on testC</code></pre></div><p>在这里，我们的类中重载了test()方法，这里输出的就是类中的方法了。如果注释掉testB类中的test()方法，则会报错。因为程序无法区分出你要使用的是哪一个trait中的test()方法。我们可以使用insteadof来指定要使用的方法调用哪一个trait。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class testE{\n    use B, C {\n        B::test insteadOf C;\n        C::test as testC;\n    }\n}\n$e = new testE();\n$e-&gt;test(); // This is trait B!\n$e-&gt;testC(); // This is trait C!</code></pre></div><p>当然，现实开发中还是尽量规范方法名，不要出现这种重复情况。另外，如果子类引用了trait，而父类又定义了同样的方法呢？当然还是调用父类所继承来的方法。trait的优先级是低于普通的类继承的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">trait D{\n    function test(){\n        echo \'This is trait D!\';\n    }\n}\n\nclass parentD{\n    function test(){\n        echo \'This is class parentD\';\n    }\n}\n\nclass testD extends parentD{\n    use D;\n}\n\n$d = new testD();\n$d-&gt;test(); // This is trait D!</code></pre></div><p>最后，trait中也是可以定义抽象方法的。这个抽象方法是引用这个trait的类所必须实现的方法，和抽象类中的抽象方法效果一致。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">trait F{\n    function test(){\n        echo \'This is trait F!\';\n    }\n    abstract function show();\n}\n\nclass testF{\n    use F;\n    function show(){\n        echo \'This is class testF!\';\n    }\n}\n$f = new testF();\n$f-&gt;test();\n$f-&gt;show();</code></pre></div><p>trait真的是PHP是非常灵活的一个功能。当然，越是灵活的东西越需要我们去弄明白它的一些使用规则，这样才能避免一些不可预见的错误。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/trait%E8%83%BD%E5%8A%9B%E5%9C%A8PHP%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/trait%E8%83%BD%E5%8A%9B%E5%9C%A8PHP%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.traits.php\">https://www.php.net/manual/zh/language.oop5.traits.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-11-19 05:37:27', 1);
INSERT INTO `zy_articles_xs_test` VALUES (50, '再谈PHP中的self与static', '<h1>再谈PHP中的self与static</h1><p>之前的文章中有介绍过self、static和parent的传递问题。今天，通过一个小实验，我们来看看self和static操作变量的问题。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class A\n{\n    public static $name = \"I\'m A!\";\n\n    public function selfName()\n    {\n        echo self::$name;\n    }\n\n    public function staticName()\n    {\n        echo static::$name;\n    }\n}\n\nclass B extends A{\n    public static $name = \"I\'m B!\";\n}\n\n$b = new B();\n$b-&gt;selfName(); // I\'m A!\n$b-&gt;staticName(); // I\'m B!\n\nclass C extends A{\n    public static $name = \"I\'m C!\";\n\n    public function selfName()\n    {\n        echo self::$name;\n    }\n}\n\n$c = new C();\n$c-&gt;selfName(); // I\'m C!\n$c-&gt;staticName(); // I\'m C!</code></pre></div><p>通过这个简单的例子，我们可以看出两点：</p><ol><li><p>self写在哪个类里面，它固定指向的就是当前的这个类</p></li><li><p>static就是哪个对象调用它，它指向的就是这个调用者</p></li></ol><p>从代码中我们可以看出，B类没有重写selfName()方法，所以B类调用selfName()时调用的是父类A的selfName()方法，self在这个方法中指向的是A类。而C类重写了父类的selfName()方法，在调用C类的selfName()时，这里面的self指向的便是C类自己了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>static就比较简单了，例子中都是由B类和C类来调用的A类的staticName()方法，根据谁调用就指向谁来看，输出的结果符合我们的预期，B类对象指向的是B类，C类对象指向的是C类。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们也可以转而理解为self是个常量，写在哪里就不会变了，它就是指明当前这个类。而static是个变量，哪个类用到它了它就被赋值成调用它的这个类。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/%E5%86%8D%E8%B0%88PHP%E4%B8%AD%E7%9A%84self%E4%B8%8Estatic.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/%E5%86%8D%E8%B0%88PHP%E4%B8%AD%E7%9A%84self%E4%B8%8Estatic.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.cnblogs.com/mr-amazing/p/5953227.html\">https://www.cnblogs.com/mr-amazing/p/5953227.html</a></p><p><a href=\"https://www.php.net/manual/zh/language.oop5.constants.php\">https://www.php.net/manual/zh/language.oop5.constants.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-05-02 15:41:16', 1);
INSERT INTO `zy_articles_xs_test` VALUES (51, '构造函数以及析构函数在PHP中需要注意的地方', '<h1>构造函数以及析构函数在PHP中需要注意的地方</h1><p>基本上所有的编程语言在类中都会有构造函数和析构函数的概念。构造函数是在函数实例创建时可以用来做一些初始化的工作，而析构函数则可以在实例销毁前做一些清理工作。相对来说，构造函数我们使用得非常多，而析构函数则一般会用在释放资源上，比如数据库链接、文件读写的句柄等。</p><h3><strong>构造函数与析构函数的使用</strong></h3><p>我们先来看看正常的构造与析构函数的使用：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class A\n{\n    public $name;\n    public function __construct($name)\n    {\n        $this-&gt;name = $name;\n        echo \"A：构造函数被调用，{$this-&gt;name}\", PHP_EOL;\n    }\n\n    public function __destruct()\n    {\n        echo \"A：析构函数被调用，{$this-&gt;name}\", PHP_EOL;\n    }\n}\n\n$a = new A(\'$a\');\necho \'-----\', PHP_EOL;\n\nclass B extends A\n{\n    public function __construct($name)\n    {\n        $this-&gt;name = $name;\n        parent::__construct($name);\n        echo \"B：构造函数被调用，{$this-&gt;name}\", PHP_EOL;\n    }\n\n    public function __destruct()\n    {\n        parent::__destruct();\n        echo \"B：析构函数被调用，{$this-&gt;name}\", PHP_EOL;\n    }\n}\n\nclass C extends A\n{\n    public function __construct($name)\n    {\n        $this-&gt;name = $name;\n        echo \"C：构造函数被调用，{$this-&gt;name}\", PHP_EOL;\n    }\n\n    public function __destruct()\n    {\n        echo \"C：析构函数被调用，{$this-&gt;name}\", PHP_EOL;\n    }\n}\n\nclass D extends A\n{\n\n}\n// unset($a); // $a的析构提前\n// $a = null; // $a的析构提前\n$b = new B(\'$b\');\n\n$c = new C(\'$c\');\n\n$d = new D(\'$d\');\n\necho \'-----\', PHP_EOL;exit;\n\n// A：构造函数被调用，$a\n// -----\n// A：构造函数被调用，$b\n// B：构造函数被调用，$b\n// C：构造函数被调用，$c\n// A：构造函数被调用，$d\n// -----\n// A：析构函数被调用，$d\n// C：析构函数被调用，$c\n// A：析构函数被调用，$b\n// B：析构函数被调用，$b\n// A：析构函数被调用，$a</code></pre></div><p>上面的代码是不是有一些内容和我们的预期不太一样？没事，我们一个一个来看：</p><ul><li><p>子类如果重写了父类的构造或析构函数，如果不显式地使用parent::__constuct()调用父类的构造函数，那么父类的构造函数不会执行，如C类</p></li><li><p>子类如果没有重写构造或析构函数，则默认调用父类的</p></li><li><p>析构函数如果没显式地将变量置为NULL或者使用unset()的话，会在脚本执行完成后进行调用，调用顺序在测试代码中是类似于栈的形式先进后出（C-&gt;B-&gt;A，C先被析构），但在服务器环境中则不一定，也就是说顺序不一定固定</p></li></ul><h3><strong>析构函数的引用问题</strong></h3><p>当对象中包含自身相互的引用时，想要通过设置为NULL或者unset()来调用析构函数可能会出现问题。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class E\n{\n    public $name;\n    public $obj;\n    public function __destruct()\n    {\n        echo \"E：析构函数被调用，\" . $this-&gt;name, PHP_EOL;\n        echo \'-----\', PHP_EOL;\n    }\n}\n\n$e1 = new E();\n$e1-&gt;name = \'e1\';\n$e2 = new E();\n$e2-&gt;name = \'e2\';\n\n$e1-&gt;obj = $e2;\n$e2-&gt;obj = $e1;</code></pre></div><p>类似于这样的代码，$e1和$e2都是E类的对象，他们又各自持有对方的引用。其实简单点来说的话，自己持有自己的引用都会出现类似的问题。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$e1 = new E();\n$e1-&gt;name = \'e1\';\n$e2 = new E();\n$e2-&gt;name = \'e2\';\n\n$e1-&gt;obj = $e2;\n$e2-&gt;obj = $e1;\n$e1 = null;\n$e2 = null;\n// gc_collect_cycles();\n\n$e3 = new E();\n$e3-&gt;name = \'e3\';\n$e4 = new E();\n$e4-&gt;name = \'e4\';\n\n$e3-&gt;obj = $e4;\n$e4-&gt;obj = $e3;\n$e3 = null;\n$e4 = null;\n\necho \'E destory\', PHP_EOL;</code></pre></div><p>如果我们不打开gc_collect_cycles()那一行的注释，析构函数执行的顺序是这样的：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 不使用gc回收的结果\n// E destory\n// E：析构函数被调用，e1\n// -----\n// E：析构函数被调用，e2\n// -----\n// E：析构函数被调用，e3\n// -----\n// E：析构函数被调用，e4\n// -----</code></pre></div><p>如果我们打开了gc_collect_cycles()的注释，析构函数的执行顺序是：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 使用gc回收后结果\n// E：析构函数被调用，e1\n// -----\n// E：析构函数被调用，e2\n// -----\n// E destory\n// E：析构函数被调用，e3\n// -----\n// E：析构函数被调用，e4\n// -----</code></pre></div><p>可以看出，必须要让php使用gc回收一次，确定对象的引用都被释放了之后，类的析构函数才会被执行。引用如果没有释放，析构函数是不会执行的。</p><h3><strong>构造函数的低版本兼容问题</strong></h3><p>在PHP5以前，PHP的构造函数是与类名同名的一个方法。也就是说如果我有一个F类，那么function F(){}方法就是它的构造函数。为了向低版本兼容，PHP依然保留了这个特性，在PHP7以后如果有与类名同名的方法，就会报过时警告，但不会影响程序执行。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class F\n{\n    public function f() \n    {\n        // Deprecated: Methods with the same name as their class will not be constructors in a future version of PHP; F has a deprecated constructor \n        echo \"F：这也是构造函数，与类同名，不区分大小写\", PHP_EOL;\n    }\n    // function F(){\n    //     // Deprecated: Methods with the same name as their class will not be constructors in a future version of PHP; F has a deprecated constructor \n    //     echo \"F：这也是构造函数，与类同名\", PHP_EOL;\n    // }\n    // function __construct(){\n    //     echo \"F：这是构造函数，__construct()\", PHP_EOL;\n    // }\n}\n$f = new F();</code></pre></div><p>如果__construc()和类同名方法同时存在的话，会优先走__construct()。另外需要注意的是，<strong>函数名不区分大小写</strong>，所以F()和f()方法是一样的都会成为构造函数。同理，因为不区分大小写，所以f()和F()是不能同时存在的。当然，我们都不建议使用类同名的函数来做为构造函数，毕竟已经是过时的特性了，说不定哪天就被取消了。</p><h3><strong>构造函数重载</strong></h3><p>PHP是不运行方法的重载的，只支持重写，就是子类重写父类方法，但不能定义多个同名方法而参数不同。在Java等语言中，重载方法非常方便，特别是在类实例化时，可以方便地实现多态能力。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$r1 = new R(); // 默认构造函数\n$r2 = new R(\'arg1\'); // 默认构造函数 一个参数的构造函数重载，arg1\n$r3 = new R(\'arg1\', \'arg2\'); // 默认构造函数 两个参数的构造函数重载，arg1，arg2</code></pre></div><p>就像上述代码一样，如果你尝试定义多个__construct()，PHP会很直接地告诉你运行不了。那么有没有别的方法实现上述代码的功能呢？当然有，否则咱也不会写了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class R\n{\n    private $a;\n    private $b;\n    public function __construct()\n    {\n        echo \'默认构造函数\', PHP_EOL;\n        $argNums = func_num_args();\n        $args = func_get_args();\n        if ($argNums == 1) {\n            $this-&gt;constructA(...$args);\n        } elseif ($argNums == 2) {\n            $this-&gt;constructB(...$args);\n        }\n    }\n    public function constructA($a)\n    {\n        echo \'一个参数的构造函数重载，\' . $a, PHP_EOL;\n        $this-&gt;a = $a;\n    }\n    public function constructB($a, $b)\n    {\n        echo \'两个参数的构造函数重载，\' . $a . \'，\' . $b, PHP_EOL;\n        $this-&gt;a = $a;\n        $this-&gt;b = $b;\n    }\n}\n$r1 = new R(); // 默认构造函数\n$r2 = new R(\'arg1\'); // 默认构造函数 一个参数的构造函数重载，arg1\n$r3 = new R(\'arg1\', \'arg2\'); // 默认构造函数 两个参数的构造函数重载，arg1，arg2</code></pre></div><p>相对来说比Java之类的语言要麻烦一些，但是也确实是实现了相同的功能哦。</p><h3><strong>构造函数和析构函数的访问限制</strong></h3><p>构造函数和析构函数默认都是public的，和类中的其他方法默认值一样。当然它们也可以设置成private和protected。如果将构造函数设置成非公共的，那么你将无法实例化这个类。这一点在单例模式被广泛应用，下面我们直接通过一个单例模式的代码看来。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class Singleton\n{\n    private static $instance;\n    public static function getInstance()\n    {\n        return self::$instance == null ? self::$instance = new Singleton() : self::$instance;\n    }\n\n    private function __construct()\n    {\n\n    }\n}\n\n$s1 = Singleton::getInstance();\n$s2 = Singleton::getInstance();\necho $s1 === $s2 ? \'s1 === s2\' : \'s1 !== s2\', PHP_EOL;\n\n// $s3 = new Singleton(); // Fatal error: Uncaught Error: Call to private Singleton::__construct() from invalid context</code></pre></div><p>当$s3想要实例化时，直接就报错了。关于单例模式为什么要让外部无法实例化的问题，我们可以看看之前的设计模式系统文章中的<a href=\"https://mp.weixin.qq.com/s/xJPF0dJYorbjhDQJMxogpQ\">单例模式</a>。</p><h3><strong>总结</strong></h3><p>没想到我们天天用到的构造函数还能玩出这么多花样来吧，日常在开发中比较需要注意的就是子类继承时对构造函数重写时父类构造函数的调用问题以及引用时的析构问题。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：<a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%9C%A8PHP%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%9C%A8PHP%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.decon.php#105368\">https://www.php.net/manual/zh/language.oop5.decon.php#105368</a></p><p><a href=\"https://www.php.net/manual/zh/language.oop5.decon.php#76446\">https://www.php.net/manual/zh/language.oop5.decon.php#76446</a></p><p><a href=\"https://www.php.net/manual/zh/language.oop5.decon.php#81458\">https://www.php.net/manual/zh/language.oop5.decon.php#81458</a></p><p><a href=\"https://www.php.net/manual/zh/language.oop5.decon.php\">https://www.php.net/manual/zh/language.oop5.decon.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-02-24 10:21:47', 1);
INSERT INTO `zy_articles_xs_test` VALUES (52, '玩转PHP中的抽象类与接口', '<h1>玩转PHP中的抽象类与接口</h1><p>在面向对象开发中，特别是使用现代化框架的过程中，我们经常会和接口、抽象类打交道。特别是我们自己尝试去封装一些功能时，接口和抽象类往往会是我们开始的第一步，但你真的了解它们吗？</p><h4><strong>抽象类定义</strong></h4><p>抽象类的特点：</p><ul><li><p>顾名思义，它是抽象的，当然也就是不能被实例化的。所以，抽象类一般是作为我们的基类来进行定义的。</p></li><li><p>在一个类中，只要有一个方法被定义为抽象的，那么这个类就必须加上abstract关键字成为抽象类。</p></li><li><p>被定义为抽象的方法只声明其调用方式，不能定义其具体的功能实现。</p></li><li><p>子类必须定义父类中的所有抽象方法，这些方法的访问控制必须和父类一致或者更为宽松。</p></li><li><p>方法的调用方式必须匹配，即类型和所需参数数量必须一致。子类实现的抽象方法可以增加参数但必须有默认值。</p></li></ul><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">abstract class A {\n    public function show(){\n        $this-&gt;getName();\n        echo PHP_EOL;\n    }\n\n    protected abstract function getName();\n    public abstract function getAge($age);\n}\n\nclass ChildA1 extends A {\n    public function getName(){\n        echo \"I\'m ChildA1\";\n    }\n    public function getAge($age){\n        echo \"Age is \" . $age;\n    }\n}\n\nclass ChildA2 extends A {\n    protected function getName(){\n        echo \"I\'m ChildA2\";\n    }\n    public function getAge($age, $year = \'\'){\n        echo \"Age is \". $age . \', bron \' . $year;\n    }\n}\n\n$ca1 = new ChildA1();\n$ca1-&gt;show();\n$ca1-&gt;getAge(18);\n\n$ca2 = new ChildA2();\n$ca2-&gt;show();\n$ca2-&gt;getAge(20, 2000);</code></pre></div><h4><strong>接口定义</strong></h4><p>接口的特点：</p><ul><li><p>可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。</p></li><li><p>就像定义一个标准的类一样，但其中定义所有的方法都是空的。</p></li><li><p>接口中定义的所有方法都必须是公有，这是接口的特性。</p></li><li><p>类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。</p></li><li><p>类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误</p></li><li><p>接口也可以继承，通过使用 extends 操作符</p></li><li><p>接口中也可以定义常量。接口常量和类常量的使用完全相同，但是不能被子类或子接口所覆盖</p></li></ul><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">interface B1 {\n    const B1_NAME = \'Interface B1\';\n    function getName();\n    function getAge($age);\n}\n\ninterface B2 extends B1 {\n    function show();\n}\n\ninterface B3 {\n    function getSchool();\n}\n\nclass ChildB implements B2, B3{\n    function getName(){\n        echo \"I\'m ChildB\";\n    }\n    function getAge($age, $year = \'\'){\n        echo \"Age is \" . $age;\n    }\n    function show(){\n        $this-&gt;getName();\n        echo PHP_EOL;\n\n        $this-&gt;getAge(23, 1997);\n        echo PHP_EOL;\n\n        echo self::B1_NAME;\n        echo PHP_EOL;\n    }\n    \n    function getSchool(){\n        echo \"study in Peking University\";\n        echo PHP_EOL;\n    }\n}\n\n$b = new ChildB();\n$b-&gt;show();\n$b-&gt;getSchool();</code></pre></div><h4><strong>抽象类和接口的区别</strong></h4><p>从上面我们可以总结出一些抽象类和接口的区别：</p><ul><li><p>抽象类的子类遵循继承原则，只能有一个父类；但一个类可以实现多个接口</p></li><li><p>抽象类中可以有非抽象的已经实现的方法；接口中全是抽象的方法，都是方法定义</p></li><li><p>抽象类中方法和变量的访问控制自己定义；接口中只能是公共的</p></li></ul><p>那么问题来了，这两货哪个好？抱歉，这个问题可没有答案，它们的作用不同。抽象类可以作为基类，为子类提供公共方法，并定制公共的抽象让子类来实现。而接口则是更高层次的抽象，它可以让我们依赖于抽象而不是具体的实现，为软件开发带来更多的扩展性。</p><h4><strong>面向接口开发</strong></h4><p>接口，实际上也可以看做是一种契约。我们经常会拿电脑主机箱后面的插口来说明。比如USB接口，我们定义了它的大小，里面的线路格式，不管你插进来的是什么，我们都可以连通。而具体的实现则是取决于电脑软件对插入的硬件的解释，比如U盘就会去读取它里面的内容，而键盘则会识别为一个外设。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从这里可以看出，接口能够为我们程序的扩展提供非常强大的支撑。任何面向对象语言中接口都是非常重要的特性。下面我们来用接口模拟刚刚说的USB插口。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">interface USB{\n    function run();\n}\n\nclass Keyboard implements USB{\n    function run(){\n        echo \"这是键盘\";\n    }\n}\n\nclass UDisk implements USB{\n    function run(){\n        echo \"这是U盘\";\n    }\n}</code></pre></div><p>这么写有什么好处呢？我们再深入一个概念：依赖注入。如果使用面向接口开发的话：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function testUSB (USB $u){\n    $u-&gt;run();\n}\n\n// 插入U盘\ntestUSB(new UDisk);\n\n// 插入键盘\ntestUSB(new Keyboard);</code></pre></div><p>testUSB方法中的$u并不是某个具体实例，只是USB接口的抽象，在不知道它是什么实例的情况下我们通过接口契约，保证它一定会有一个run()方法。而具体的实现，则是在外部我们调用方法的时候注入进来的。</p><h3><strong>总结</strong></h3><p>掌握好接口的设计原则，往往就能看懂一大半的框架的设计思想。这也是我们面向对象中最最基础的特性。抽象类作为公共基类来说可以为多态提供比较好的范本，它能够让你的子类有自己的个性又能使用父类的能力。总之，深入场景业务，选择合适的方式实现代码，靠的是能力、经验与智慧的综合，决不是一句谁好谁不好所能定性的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/%E7%8E%A9%E8%BD%ACPHP%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/%E7%8E%A9%E8%BD%ACPHP%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.abstract.php\">https://www.php.net/manual/zh/language.oop5.abstract.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.oop5.interfaces.php\">https://www.php.net/manual/zh/language.oop5.interfaces.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.oop5.interfaces.php#79110\">https://www.php.net/manual/zh/language.oop5.interfaces.php#79110</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-12-27 21:24:34', 1);
INSERT INTO `zy_articles_xs_test` VALUES (53, '静态成员在PHP中是怎么继承的？', '<h1>静态成员在PHP中是怎么继承的？</h1><p>静态成员，也就是用static修饰的变量或者方法，如果搞不清楚它们实现的原理，就很容易会出现一些错误。这次我们来研究的是在继承中静态成员的调用情况。首先来看这样一段代码：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class A\n{\n    static $a = \'This is A!\';\n\n    public function show()\n    {\n        echo self::$a, PHP_EOL;\n        echo static::$a, PHP_EOL;\n    }\n}\n\nclass B extends A\n{\n    static $a = \'This is B!\';\n\n}\n\n$b = new B;\n$b-&gt;show();</code></pre></div><p>之前的文章中，我们有说过self的问题。self仅仅只是指向当前这个类。注意，是类，不是实例化后的对象。所以上面的输出结果是：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">This is A!\nThis is B!</code></pre></div><p>好了，有了这个基础之后，我们知道静态成员是和类有关的，和对象无关。那么以下的代码也就更容易理解了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class C\n{\n    static $c = 1;\n    public $d = 1;\n}\nclass D extends C\n{\n    public function add()\n    {\n        self::$c++;\n        $this-&gt;d++;\n    }\n}\n\n$d1 = new D();\n$d2 = new D();\n\n$d1-&gt;add();\necho \'c：\' . D::$c . \',d：\' . $d1-&gt;d . \';\', PHP_EOL;\n\n$d2-&gt;add();\necho \'c：\' . D::$c . \',d：\' . $d2-&gt;d . \';\', PHP_EOL;</code></pre></div><p>直接读代码能推导出输出的结果吗？其实只要掌握了上文中所说的原则，这段代码就很容易理解了。$c是静态变量，$d是普通变量。通过类实例的add()方法进行操作后，$c因为是和类有关，所以不管是哪个实例对象，操作它之后都会是共享的。而$d作为普通变量，它的作用域仅限制在当前这个实例对象中。因此，输出的结果是：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">c：2,d：2;\nc：3,d：2;</code></pre></div><p>最后，我们还是来复习一次self、parent和static关键字。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class E {\n    public static function test(){\n        echo \"This is E test!\";\n    }\n}\n\nclass F extends E{\n    public static function t(){\n        self::test();\n        parent::test();\n        static::test();\n    }\n\n    public static function test(){\n        echo \"This is F test!\";\n    }\n}\n\nF::t();</code></pre></div><p>t()输出的三个结果是什么呢？详情可以查看之前的文章<a href=\"https://mp.weixin.qq.com/s/vJc2lXnIg7GCgPkrTh_xsw\">PHP中的Static</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%9C%A8PHP%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%A7%E6%89%BF%E7%9A%84%EF%BC%9F.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/201912/source/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%9C%A8PHP%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E7%BB%A7%E6%89%BF%E7%9A%84%EF%BC%9F.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.static.php\">https://www.php.net/manual/zh/language.oop5.static.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-06-21 12:16:04', 1);
INSERT INTO `zy_articles_xs_test` VALUES (54, 'PHP中命名空间是怎样的存在？（三）', '<h1>PHP中命名空间是怎样的存在？（三）</h1><p>这是与命名空间有关的最后一篇。最后还是两个比较简单的内容，是关于命名空间和全局相关的一些类、函数、常量的使用对比。当然，最后我们还会总结一下命名空间的名称解析规则做为这三篇系列文章的结束。</p><h2>全局空间</h2><p>当文件中定义了命名空间，也就是namesapce指定了当前的命名空间后，在调用全局类、函数、常量时，需要添加一个“\\”，也就是完全限定访问符号来标明这个类、函数、常量是全局的那个，而不是当前命名空间中的。特别是当前命名空间中包含与全局类、函数、常量同名的内容时。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">namespace FILE6;\n\nfunction show()\n{\n    echo strtoupper(\'aaa\'), PHP_EOL; // 调用自己的\n    echo \\strtoupper(\'aaa\'), PHP_EOL; // 调用全局的\n}\n\nfunction strtoupper($str)\n{\n    return __NAMESPACE__ . \'：\' . \\strtoupper($str);\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>在这个FILE6命名空间中，我们定义了一个strtoupper()方法。之间说过，命名空间就是为了解决同名问题而出现的，这个方法和全局php自带的那个方法是完全相同的名称的。所以，在调用的时候我们需要调用的是哪个方法。那么如果当前命名空间中没有定义这个方法呢？别急，接下来的内容就是讲这个问题。</p><h2>后备全局函数/常量</h2><p>从上个例子中，我们就可以看出全局完全限定访问符的作用，当没有使用全局符时，strtoupper()方法会先调用当前命名空间下的方法。那么后备的作用就是如果当前命名空间中没有找到时，会去全局找相关的函数。在文档中的定义是这样的：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>当 PHP 遇到一个非限定的类、函数或常量名称时，它使用不同的优先策略来解析该名称。类名称总是解析到当前命名空间中的名称。因此在访问系统内部或不包含在命名空间中的类名称时，必须使用完全限定名称。对于函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP 会退而使用全局空间中的函数或常量。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>意思也就是说，函数和常量，会有后备去全局查找的能力。但是类不行！！如果要使用全局类，一定要加全局完全限定符。我们通过一个例子来看：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">namespace FILE7;\n\n// 类必须使用完全限定的全局空间\n$o1 = new \\stdClass();\n// $o2 = new stdClass(); // Fatal error: Uncaught Error: Class \'FILE7\\stdClass\' not found\n\n// 方法会先在本命名空间查找，如果没找到会去全局找\nfunction strlen($str)\n{\n    return __NAMESPACE__ . \'：\' . (\\strlen($str) - 1);\n}\necho strlen(\'abc\'), PHP_EOL; // FILE7：2 ，当前命名空间\necho \\strlen(\'abc\'), PHP_EOL; // 3 ， 全局\n\necho strtoupper(\'abc\'), PHP_EOL; // ABC， 全局\n\n// 常量也是有后备能力的\n\nconst E_ERROR = 22; \necho E_ERROR, PHP_EOL; // 22， 当前命名空间\necho \\E_ERROR, PHP_EOL; // 1， 全局\n\necho INI_ALL, PHP_EOL; // 7， 全局</code></pre></div><h2>名称解析规则</h2><ol><li><p>对完全限定名称的函数，类和常量的调用在编译时解析。例如 new \\A\\B 解析为类 A\\B。</p></li><li><p>所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 A\\B\\C 被导入为 C，那么对 C\\D\\e() 的调用就会被转换为 A\\B\\C\\D\\e()。</p></li><li><p>在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 A\\B 内部调用 C\\D\\e()，则 C\\D\\e() 会被转换为 A\\B\\C\\D\\e() 。</p></li><li><p>非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 A\\B\\C 导入为C，则 new C() 被转换为 new A\\B\\C() 。</p></li><li><p>在命名空间内部（例如A\\B），对非限定名称的函数调用是在运行时解析的。例如对函数 foo() 的调用是这样解析的：</p><ul><li><p>在当前命名空间中查找名为 A\\B\\foo() 的函数</p></li><li><p>尝试查找并调用 全局(global) 空间中的函数 foo()。</p></li></ul></li><li><p>在命名空间（例如A\\B）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用 new C() 及 new D\\E() 的解析过程： new C()的解析:</p><ul><li><p>在当前命名空间中查找A\\B\\C类。</p></li><li><p>尝试自动装载类A\\B\\C。</p></li></ul></li></ol><p>new D\\E()的解析:</p><ol><li><p>在类名称前面加上当前命名空间名称变成：A\\B\\D\\E，然后查找该类。</p></li><li><p>尝试自动装载类 A\\B\\D\\E。</p></li></ol><p>为了引用全局命名空间中的全局类，必须使用完全限定名称 new \\C()。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/namespace/file6.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/namespace/file6.php</a></p><p>[https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/namespace/file7.php]https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/namespace/file7.php()</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.namespaces.global.php\">https://www.php.net/manual/zh/language.namespaces.global.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.namespaces.fallback.php\">https://www.php.net/manual/zh/language.namespaces.fallback.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.namespaces.rules.php\">https://www.php.net/manual/zh/language.namespaces.rules.php</a></p>', '', 'PHP基础,命名空间', '2022-07-23 18:06:29', '2020-12-07 09:00:03', 1);
INSERT INTO `zy_articles_xs_test` VALUES (55, 'PHP中命名空间是怎样的存在？（二）', '<h1>PHP中命名空间是怎样的存在？（二）</h1><p>今天带来的依然是命名空间相关的内容，本身命名空间就是PHP中非常重要的一个特性。所以关于它的各种操作和使用还是非常复杂的，光使用方式就有很多种，我们一个一个的来看。</p><h2>子命名空间</h2><p>命名空间本身就像目录一样，所以命名空间当然也是可以定义子命名空间的，真的就和操作系统的各种目录层级是完全一样的。我们通过简单的例子来看看。首先还是创建三个php文件，其中3-2和3-2-1是使用的相同的二级命名空间，3-2-1在FILE32的基础上继续向下扩展了第三级的命名空间FILE321。他们都是MyProject命名空间的子命名空间。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// file3-1.php\n\nnamespace MyProject\\FILE31;\n\nfunction testA31(){\n    echo \'FILE31\\testA()\', PHP_EOL;\n}\n\n\n// file3-2.php\nnamespace MyProject\\FILE32;\n\nconst CONST_A32 = \"file3-2\";\nfunction testA32(){\n    echo \'FILE32\\testA()\', PHP_EOL;\n}\n\nclass objectA32{\n    function test(){\n        echo \'FILE32\\ObjectA\', PHP_EOL;\n    }\n}\n\n// file3-2-1.php\n\nnamespace MyProject\\FILE32\\FILE321;\n\nfunction testA321(){\n    echo \'FILE321\\testA()\', PHP_EOL;\n}</code></pre></div><p>接下来的使用就很简单了，和使用一级命名空间一样，直接使用use进行导入就可以了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 子命名空间\nrequire \'namespace/file3-1.php\';\nrequire \'namespace/file3-2.php\';\nrequire \'namespace/file3-2-1.php\';\n\nuse MyProject\\FILE31;\nuse MyProject\\FILE32;\nuse MyProject\\FILE32\\FILE321;\n\nFILE31\\testA31(); // FILE31\\testA()\nFILE32\\testA32(); // FILE32\\testA()\nFILE32\\FILE321\\testA321(); // FILE321\\testA()\nFILE321\\testA321(); // FILE321\\testA()\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><h2>同一文件中定义多个命名空间</h2><p>PHP是允许在一个文件中定义多个命名空间的，但是并不推荐这么做，因为这样可能会带来各种未知的混乱。在这里，我们只要了解到可以这样使用就行了，在日常的开发中还是尽量要避免。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// file4.php\nnamespace FILE41;\n\nfunction testA41(){\n    echo \'FILE41\\testA()\', PHP_EOL;\n}\n\nnamespace FILE42;\n\nfunction testA42(){\n    echo \'FILE42\\testA()\', PHP_EOL;\n}</code></pre></div><p>在使用中当然也和其他命名空间的使用没什么两样，直接use使用即可。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 一个文件中多个命名空间\nrequire \'namespace/file4.php\';\n\nuse FILE41, FILE42;\n\nFILE41\\testA41(); // FILE41\\testA()\nFILE42\\testA42(); // FILE42\\testA()</code></pre></div><h2>非限定名称、限定名称、完全限定名称</h2><p>不要被术语吓到，这三个术语其实非常好理解。</p><ul><li><p>非限定名称，名称中不包含命名空间分隔符的标识符，例如 Foo 。</p></li><li><p>限定名称，名称中含有命名空间分隔符的标识符，例如 Foo\\Bar 。</p></li><li><p>名称中包含命名空间分隔符，并以命名空间分隔符开始的标识符，例如 \\Foo\\Bar。 namespace\\Foo 也是一个完全限定名称。</p></li></ul><p>直接用例子来说就非常清晰了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 非限定名称、限定名称、完全限定名称\nuse MyProject\\FILE32\\objectA32 as obj32;\n\n$o = new obj32(); // 非限定名称\n$o-&gt;test(); // FILE32\\ObjectA\n\n$o = new FILE32\\objectA32(); // 限定名称\n$o-&gt;test(); // FILE32\\ObjectA\n\n$o = new \\MyProject\\FILE32\\objectA32(); // 完全限定名称\n$o-&gt;test(); // FILE32\\ObjectA\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><h2>namespace关键字和__NAMESPACE__常量</h2><ul><li><p>namesapce，显式访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符。</p></li><li><p><strong>NAMESPACE</strong>，包含当前命名空间名称的字符串。在全局的，不包括在任何命名空间中的代码，它包含一个空的字符串。</p></li></ul><p>也是很简单的内容吧，直接来看例子。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// file5.php\nnamespace FILE5;\n\nfunction test(){\n    echo __NAMESPACE__ . \': test()\', PHP_EOL;\n}\n\n// test.php\nnamespace Pro;\n// namespace与__NAMESPACE__\nrequire \'namespace/file5.php\';\n\nfunction test(){\n    echo __NAMESPACE__ . \': test()\', PHP_EOL;\n}\n\nnamespace\\test(); // Pro: test()\n\n\\FILE5\\test(); // FILE5: test()</code></pre></div><p>我们给当前命名空间定义为Pro，引入了file5文件。这两个文件中都有一个test()方法，test()方法内都输出了__NAMESPACE__来打印当前的命名空间名称。然后在test.php中，通过namespace关键字调用的就是当前文件的Pro命名空间中的test()方法，输出的是 Pro: test() 。直接使用完全限定名称调用FILE5的test()方法，输出了 FILE5: test() 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/PHP%E4%B8%AD%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%AD%98%E5%9C%A8%EF%BC%9F%EF%BC%88%E4%BA%8C%EF%BC%89%20.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/PHP%E4%B8%AD%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%AD%98%E5%9C%A8%EF%BC%9F%EF%BC%88%E4%BA%8C%EF%BC%89%20.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.namespaces.nsconstants.php\">https://www.php.net/manual/zh/language.namespaces.nsconstants.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.namespaces.rules.php\">https://www.php.net/manual/zh/language.namespaces.rules.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.namespaces.nested.php\">https://www.php.net/manual/zh/language.namespaces.nested.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.namespaces.definitionmultiple.php\">https://www.php.net/manual/zh/language.namespaces.definitionmultiple.php</a></p>', 'PHP', 'PHP基础,命名空间', '2022-07-23 18:06:29', '2020-10-01 14:05:02', 1);
INSERT INTO `zy_articles_xs_test` VALUES (56, 'PHP中的对象比较', '<h1>PHP中的对象比较</h1><p>在之前的文章中，我们讲过<a href=\"https://mp.weixin.qq.com/s/FMfjNarP7_xFiYgderph-g\">PHP中比较数组的时候发生了什么？</a>。这次，我们来讲讲在对象比较的时候PHP是怎样进行比较的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>首先，我们先根据PHP文档来定义对象比较的方式：</p><ul><li><p>同一个类的实例，比较属性大小，根据顺序，遇到不同的属性值后比较返回，后续的不会再比较</p></li><li><p>不同类的实例，比较属性值</p></li><li><p>===，必须是同一个实例</p></li></ul><p>我们通过一个例子来看下：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function bool2str($bool)\n{\n    if ($bool === false) {\n        return \'FALSE\';\n    } else {\n        return \'TRUE\';\n    }\n}\n\nfunction compareObjects(&amp;$o1, &amp;$o2)\n{\n    echo \'o1 == o2 : \' . bool2str($o1 == $o2) . \"\\n\";\n    echo \'o1 === o2 : \' . bool2str($o1 === $o2) . \"\\n\";\n}\n\nclass A {\n    private $t = true;\n    public function setT($t){\n        $this-&gt;t = $t;\n    }\n}\n\nclass B {\n    protected $t = true;\n    public function setT1($t){\n        $this-&gt;t = $t;\n    }\n}\n\nclass C {\n    private $t = true;\n    public function setT($t){\n        $this-&gt;t = $t;\n    }\n}\n\n$a1 = new A();\n$a2 = new A();\n\ncompareObjects($a1, $a2); // 相同的类\n// o1 == o2 : TRUE\n// o1 === o2 : FALSE\n\n$a11 = $a1;\n\ncompareObjects($a1, $a11); // 相同的实例\n// o1 == o2 : TRUE\n// o1 === o2 : TRUE\n\n$a11-&gt;setT(false);\n\ncompareObjects($a1, $a11); // 相同实例属性值不同\n// o1 == o2 : TRUE\n// o1 === o2 : TRUE\n\n$b = new B();\n\ncompareObjects($a1, $b); // 不同的类\n// o1 == o2 : FALSE\n// o1 === o2 : FALSE\n\n$c = new C();\n\ncompareObjects($a1, $b); // 相同属性不同的类\n// o1 == o2 : FALSE\n// o1 === o2 : FALSE</code></pre></div><p>从例子中，我们可以看出基本都是符合上述三个条件的，不过需要注意的是，在===的情况下，如果是同一个实例对象，属性值不同也会返回TRUE。我们再通过一个更复杂的例子来观察：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$c = new stdClass();\n$d = new stdClass();\n\n$c-&gt;t1 = \'c\';\n$c-&gt;t2 = 10;\n$c-&gt;t3 = 50;\n\n$d-&gt;t1 = \'c\';\n$d-&gt;t2 = 11;\n$d-&gt;t3 = 40;\n\necho \'c &gt; d:\', $c &gt; $d ? \'TRUE\' : \'FALSE\', PHP_EOL; // FALSE\necho \'c &lt; d:\', $c &lt; $d ? \'TRUE\' : \'FALSE\', PHP_EOL; // TRUE\n\n$d-&gt;t2 = 10; // $t2属性改成相等的\necho \'c &gt; d:\', $c &gt; $d ? \'TRUE\' : \'FALSE\', PHP_EOL; // TRUE\necho \'c &lt; d:\', $c &lt; $d ? \'TRUE\' : \'FALSE\', PHP_EOL; // FALSE\n\n$d-&gt;t3 = 50; // $c、$d属性都相等了\necho \'c &gt;= d:\', $c &gt;= $d ? \'TRUE\' : \'FALSE\', PHP_EOL; // TRUE\necho \'c &lt;= d:\', $c &lt;= $d ? \'TRUE\' : \'FALSE\', PHP_EOL; // TRUE\necho \'c == d:\', $c == $d ? \'TRUE\' : \'FALSE\', PHP_EOL; // TRUE\necho \'c === d:\', $c === $d ? \'TRUE\' : \'FALSE\', PHP_EOL; // FALSE\n\n$c1 = clone $c; // 复制同一个对象\necho \'c == c1:\', $c == $c1 ? \'TRUE\' : \'FALSE\', PHP_EOL; // TRUE\necho \'c === c1:\', $c === $c1 ? \'TRUE\' : \'FALSE\', PHP_EOL; // FALSE\n\n$c1-&gt;t4 = \'f\'; // 增加了一个属性\necho \'c &gt; c1:\', $c &gt; $c1 ? \'TRUE\' : \'FALSE\', PHP_EOL; // TRUE\necho \'c &lt; c1:\', $c &lt; $c1 ? \'TRUE\' : \'FALSE\', PHP_EOL; // FALSE\necho \'c == c1:\', $c == $c1 ? \'TRUE\' : \'FALSE\', PHP_EOL; // FALSE\necho \'c === c1:\', $c === $c1 ? \'TRUE\' : \'FALSE\', PHP_EOL; // FALSE\n\nunset($c1-&gt;t4);\n$c1-&gt;t1 = \'d\';  // 修改了一个值\necho \'c == c1:\', $c == $c1 ? \'TRUE\' : \'FALSE\', PHP_EOL; // FALSE\necho \'c === c1:\', $c === $c1 ? \'TRUE\' : \'FALSE\', PHP_EOL; // FALSE</code></pre></div><p>这个例子中，我们进行了&lt;、&gt;的对比，在这种对比中，都是根据属性值来进行比对的，而对比的顺序也是属性值的英文排序。当$t2有了不相等的比较结果时，$t3就不会再进行比对了。此外，clone之后的对象并不是原来的实例对象了，所以clone后的对象和原对象是无法用===来获得相等的结果的。当一个对象的属性比另一个对象多时，这个对象也会比属性少的对象大。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>对象的比较其实和数组是有些类似的，但它们又有着些许的不同。一个重要的方面就是把握住它们都会进行属性比较，另外还有就是===的差别，数组中===必须是所有属性的类型都相同，而对象中则必须是同一个实例，而且对象只要是同一个实例，使用===就不会在乎它属性值的不同了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/PHP%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/PHP%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.object-comparison.php\">https://www.php.net/manual/zh/language.oop5.object-comparison.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-06-03 18:40:23', 1);
INSERT INTO `zy_articles_xs_test` VALUES (57, 'use关键字在PHP中的几种用法', '<h1>use关键字在PHP中的几种用法</h1><p>在学习了和使用了这么多年的PHP之后，您知道use这个关键字在PHP中都有哪些用法吗？今天我们就来看一下它的三种常见用法。</p><h2>1. 用于命名空间的别名引用</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 命名空间\ninclude \'namespace/file1.php\';\n\nuse FILE1\\objectA;\nuse FILE1\\objectA as objectB;\n\necho FILE1\\CONST_A, PHP_EOL; // 2\n\n$oA = new objectA();\n$oA-&gt;test(); // FILE1\\ObjectA\n\n$oB = new objectB();\n$oB-&gt;test(); // FILE1\\ObjectA</code></pre></div><p>这个想必在日常的工程化开发中会非常常见。毕竟现在的框架都是使用了命名空间的，不管做什么都离不开各种类依赖的调用，在各种控制器文件的上方都会有大量的use xxx\\xxx\\xxx;语句。</p><h2>2. 用于trait特性能力的引入</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// trait\ntrait A{\n    function testTrait(){\n        echo \'This is Trait A!\', PHP_EOL;\n    }\n}\n\nclass B {\n    use A;\n}\n\n$b = new B();\n$b-&gt;testTrait();</code></pre></div><p>即使在最近这两年，依然还是见过完全没有用过trait的PHP程序员，不要惊讶，这是真实存在的。想想还有那么多项目都还在用TP3也就不奇怪了。trait特性还是非常方便的一种类功能扩展模式，其实我们可以看作是将这个use放在了类中就成为了trait的引用定义了。</p><h2>3. 匿名函数传参</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 匿名函数传参\n\n$a = 1;\n$b = 2;\n// function test($fn) use ($a) // arse error: syntax error, unexpected \'use\' (T_USE), expecting \'{\' \nfunction test($fn)\n{\n    global $b;\n    echo \'test:\', $a, \'---\', $b, PHP_EOL; // test:---2\n    $fn(3);\n}\n\ntest(function ($c) use ($a) {\n    echo $a, \'---\', $b, \'---\', $c, PHP_EOL;\n});\n// 1------3</code></pre></div><p>这个就有点意思了吧，方法中要调用外部的变量是需要global的，在这里我们直接通过use()也是可以将变量传递过去的。而且这个仅限于在匿名函数中使用。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/use%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8PHP%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/use%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8PHP%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-07-04 05:37:38', 1);
INSERT INTO `zy_articles_xs_test` VALUES (58, '关于PHP中对象复制的那点事儿', '<h1>关于PHP中对象复制的那点事儿</h1><p>我们已经在<a href=\"https://mp.weixin.qq.com/s/KO4TuT2t5Xh_3BG3UrfN1w\">PHP设计模式之原型模式</a>中讨论过关于PHP中对象复制的问题，这次就当做是一次复习。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>原型模式可以看作是对象复制中的一个重要内容。在学习原型模式时，我们了解到对象中的引用变量，也就是变量也是一个对象时，直接复制这个对象会导致其中的引用变量还是指向同一个对象。是不是有点绕，我们还是用例子来说明：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// clone方法\nclass testA{\n    public $testValue;\n}\nclass A\n{\n    public static $reference = 0;\n    public $instanceReference = 0;\n    public $t;\n\n    public function __construct()\n    {\n        $this-&gt;instanceReference = ++self::$reference;\n        $this-&gt;t = new testA();\n\n    }\n\n    public function __clone()\n    {\n        $this-&gt;instanceReference = ++self::$reference;\n        $this-&gt;t = new testA();\n    }\n}\n\n$a1 = new A();\n$a2 = new A();\n$a11 = clone $a1;\n$a22 = $a2;\n\nvar_dump($a11); // $instanceReference, 3\nvar_dump($a22); // $instanceReference, 2\n\n$a1-&gt;t-&gt;testValue = \'现在是a1\';\necho $a11-&gt;t-&gt;testValue, PHP_EOL; // \'\'\n\n\n$a2-&gt;t-&gt;testValue = \'现在是a2\';\necho $a22-&gt;t-&gt;testValue, PHP_EOL; // 现在是a2\n$a22-&gt;t-&gt;testValue = \'现在是a22\';\necho $a2-&gt;t-&gt;testValue, PHP_EOL; // 现在是a22\n\n// 使用clone后\n$a22 = clone $a2;\nvar_dump($a22); // $instanceReference, 4\n\n$a2-&gt;t-&gt;testValue = \'现在是a2\';\necho $a22-&gt;t-&gt;testValue, PHP_EOL; // NULL\n$a22-&gt;t-&gt;testValue = \'现在是a22\';\necho $a2-&gt;t-&gt;testValue, PHP_EOL; // 现在是a2</code></pre></div><p>首先，通过变量的变化，我们可以看出使用clone关键字的对象复制会调用__clone()方法。这个魔术方法正在原型模式的核心所在。在这个方法中，我们可以重新实例化或者定义对象中的引用成员。通过clone，我们让$t变量重新实例化，从而让$t成为了新的对象，从而避免引用带来的问题。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在对象的复制中，我们需要特别注意的递归引用的问题。也就是对象内部引用了自身，将会导致来回的重复引用形成递归死循环。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 循环引用问题\nclass B\n{\n    public $that;\n\n    function __clone()\n    {\n        // Segmentation fault: 11\n        $this-&gt;that = clone $this-&gt;that;\n        // $this-&gt;that = unserialize(serialize($this-&gt;that));\n        // object(B)#6 (1) {\n        //     [\"that\"]=&gt;\n        //     object(B)#7 (1) {\n        //       [\"that\"]=&gt;\n        //       object(B)#8 (1) {\n        //         [\"that\"]=&gt;\n        //         *RECURSION*  无限递归\n        //       }\n        //     }\n        //   }\n    }\n}\n\n$b1 = new B();\n$b2 = new B();\n$b1-&gt;that = $b2;\n$b2-&gt;that = $b1;\n\n$b3 = clone $b1;\n\nvar_dump($b3);</code></pre></div><p>B类中的that指向自身的实例，两个对象相互指向后再进行复制，就会出现这种死循环的情况。使用序列化和反序列化输出后，我们会看到<em>RECURSION</em>的引用提示。这就是形成了递归的死循环。这种情况一定要极力避免。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上述例子中，我们使用了序列化和反序列化这一招来解决引用问题。对象复制的对象变量来说（对象变量里面还有更多层次的引用变量），这种方式能够一次性地在最顶层的对象__clone()方法中解决引用问题。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/%E5%85%B3%E4%BA%8EPHP%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/%E5%85%B3%E4%BA%8EPHP%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.cloning.php\">https://www.php.net/manual/zh/language.oop5.cloning.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-03-05 20:45:46', 1);
INSERT INTO `zy_articles_xs_test` VALUES (59, '关于PHP的方法参数类型约束', '<h1>关于PHP的方法参数类型约束</h1><p>在之前的文章<a href=\"https://mp.weixin.qq.com/s/G2N8-BXAQvnac5emez6BPA\">PHP方法参数的那点事儿</a>中，我们讲过关于PHP方法参数的一些小技巧。今天，我们带来的是更加深入的研究一下PHP中方法的参数类型。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在PHP5之后，PHP正式引入了方法参数类型约束。也就是如果指定了方法参数的类型，那么传不同类型的参数将会导致错误。在PHP手册中，方法的类型约束仅限于类、接口、数组或者callable回调函数。如果指定了默认值为NULL，那么我们也可以传递NULL作为参数。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class A{}\nfunction testA(A $a){\n    var_dump($a);\n}\n\ntestA(new A());\n// testA(1); \n// Fatal error: Uncaught TypeError: Argument 1 passed to testA() must be an instance of A, int given,</code></pre></div><p>在这个例子中，我们定义了参数类型为A类，所以当我们传递一个标量类型时，直接就会返回错误信息。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function testB(int $a){\n    var_dump($a);\n}\ntestB(1);\ntestB(\'52aadfdf\'); // 字符串强转为int了\n// testB(\'a\');\n// Fatal error: Uncaught TypeError: Argument 1 passed to testB() must be of the type int, string given\n\nfunction testC(string $a){\n    var_dump($a);\n}\ntestC(\'测试\');\ntestC(1);  // 数字会强转为字符串\n// testC(new A()); \n// Fatal error: Uncaught TypeError: Argument 1 passed to testC() must be of the type string</code></pre></div><p>在手册中明确说明了标量类型是不能使用类型约束的。但其实是可以使用的，不过如果都是标量类型则会进行相互的强制转换，并不能起到很好的约束作用。比如上例中int和string类型进行了相互强制转换。指定了非标量类型，则会报错。此处是本文的重点，小伙伴们可要划个线了哦。其实说白了，如果我们想指定参数的类型为固定的标量类型的话，在参数中指定并不是一个好的选择，最好还是在方法中进行再次的类型判断。而且如果参数中进行了强转，也会导致方法内部的判断产生偏差。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>最后我们再看一看接口和匿名方法的类型约束。匿名参数类型在Laravel等框架中非常常见。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 接口类型\ninterface D{}\nclass childD implements D{}\nfunction testD(D $d){\n    var_dump($d);\n}\ntestD(new childD());\n\n// 回调匿名函数类型\nfunction testE(Callable $e, string $data){\n    $e($data);\n}\ntestE(function($data){\n    var_dump($data);\n}, \'回调函数\');</code></pre></div><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/%E5%85%B3%E4%BA%8EPHP%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F.md\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/%E5%85%B3%E4%BA%8EPHP%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F.md</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.typehinting.php\">https://www.php.net/manual/zh/language.oop5.typehinting.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-08-31 06:38:54', 1);
INSERT INTO `zy_articles_xs_test` VALUES (60, '后期静态绑定在PHP中的使用', '<h1>后期静态绑定在PHP中的使用</h1><p>什么叫后期静态绑定呢？其实我们在之前的文章<a href=\"https://mp.weixin.qq.com/s/vJc2lXnIg7GCgPkrTh_xsw\">PHP中的static</a>中已经说过这个东西了。今天我们还是再次深入的理解一下这个概念。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>首先，我们通过一段代码来引入后期静态绑定这一概念：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class A\n{\n    public static function who()\n    {\n        echo __CLASS__, PHP_EOL;\n    }\n    public static function test()\n    {\n        self::who();\n    }\n}\n\nclass B extends A\n{\n    public static function who()\n    {\n        echo __CLASS__, PHP_EOL;\n    }\n}\n\nB::test(); // A</code></pre></div><p>在这段代码中，我们使用了self关键字，当使用B类调用test()静态方法时，self指向的是A类的who()方法，因此，输出的是A。别激动，这是普通的静态绑定。self关键字调用的内容取决于它定义时所在的类。也就是说不管怎么继承，用哪个子类来调用test()方法，self关键字都会调用的是A类的who()方法。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>而后期静态绑定呢？其实就有点像实例化的类对象，每个实例化的对象，调用的都是自身，而不是父类的属性方法。普通的静态调用可不是这样，但是现实中我们又有这样的需求，就像实例化对象的调用方式一样来调用静态属性方法，这时，我们就可以使用static关键字来实现后期静态绑定。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class C\n{\n    public static function who()\n    {\n        echo __CLASS__, PHP_EOL;\n    }\n    public static function test()\n    {\n        static::who();\n    }\n}\n\nclass D extends C\n{\n    public static function who()\n    {\n        echo __CLASS__, PHP_EOL;\n    }\n}\n\nD::test(); // D</code></pre></div><p>当使用static关键字后，这里D类调用的test()方法内部调用的who()就是D类自己了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>官方文档中的定义如下：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>当进行静态方法调用时，该类名即为明确指定的那个（通常在 :: 运算符左侧部分）；当进行非静态方法调用时，即为该对象所属的类。</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>该功能从语言内部角度考虑被命名为“后期静态绑定”。“后期绑定”的意思是说，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但不限于）静态方法的调用。</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>除了self和static关键字外，我们还有一个parent关键字，这个关键字的意义就很明显了，调用父类的静态内容。我们同时用三个关键字一起来进行测试：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class E\n{\n    public static function who()\n    {\n        echo __CLASS__, PHP_EOL;\n    }\n    public static function test()\n    {\n        self::who();\n        static::who();\n    }\n}\n\nclass F extends E\n{\n    public static function who()\n    {\n        echo __CLASS__, PHP_EOL;\n    }\n}\n\nclass G extends F\n{\n    public static function who()\n    {\n        parent::who();\n        echo __CLASS__, PHP_EOL;\n    }\n}\n\nG::test();\n\n// E\n// F\n// G</code></pre></div><p>最后，我们再来看两个PHP的方法，一个是get_called_class()方法，用来获取当前调用的是哪个类。在静态方法中可以根据调用方式判断当前类是哪个类来进行其他的业务逻辑操作。另一个是forward_static_call()方法，用于静态方法的调用。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class H\n{\n    public static function who()\n    {\n        echo __CLASS__ . \':\' . join(\',\', func_get_args()), PHP_EOL;\n    }\n    public static function test()\n    {\n        echo get_called_class(), PHP_EOL;\n        forward_static_call(\'who\', \'a\', \'b\'); // xxx:a,b\n        forward_static_call([\'I\', \'who\'], \'c\', \'d\'); // I:c,d\n        forward_static_call_array([\'H\', \'who\'], [\'e\', \'f\']); // H:e,f\n    }\n}\n\nclass I extends H\n{\n    public static function who()\n    {\n        echo __CLASS__ . \':\' . join(\',\', func_get_args()), PHP_EOL;\n    }\n}\n\nfunction who()\n{\n    echo \'xxx:\' . join(\',\', func_get_args()), PHP_EOL;\n}\n\nH::test(); // H\n// xxx:a,b\n// I:c,d\n// H:e,f\nI::test(); // I\n// xxx:a,b\n// I:c,d\n// H:e,f</code></pre></div><p>注意，如果forward_static_call()不指定类名的话，将调用全局的方法。forward_static_call_array()则是将参数使用数组进行传递。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/%E5%90%8E%E6%9C%9F%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%9C%A8PHP%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202001/source/%E5%90%8E%E6%9C%9F%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%9C%A8PHP%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.oop5.late-static-bindings.php\">https://www.php.net/manual/zh/language.oop5.late-static-bindings.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.get-called-class.php\">https://www.php.net/manual/zh/function.get-called-class.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.forward-static-call.php\">https://www.php.net/manual/zh/function.forward-static-call.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-06-28 07:12:43', 1);
INSERT INTO `zy_articles_xs_test` VALUES (61, '记一次PHP的Invalid binding type问题', '<h1>记一次PHP的Invalid binding type问题</h1><p>首先说明下环境问题，新旧服务器的迁移。代码在老服务器运行没有任何问题。环境都是PHP7.3，结果新的服务器上流量导过来以后，就报出了如下问题：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">FastCGI sent in stderr: \"PHP message: PHP Fatal error:  Invalid binding type in /base.inc.php on line 221</code></pre></div><p>这个base.inc.php的第221行是什么东东呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">221 }</code></pre></div><p>额，这就有点诡异了。注释掉相关的方法后，报错信息又顺延到下一个花括号的结尾处了。这就神奇了。于是去百度谷歌了半天，并没有什么有用的资料，唯一一个提到的内容是说重新编译一下PHP。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://stackoverflow.com/questions/3960323/why-dont-php-attributes-allow-functions\">https://stackoverflow.com/questions/3960323/why-dont-php-attributes-allow-functions</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>好吧，咱们就重新编译，可是编译完了一旦导流过来，马上就又挂掉。PHP-FPM正常运行，但不是所有的都会出问题，于是测试访问的时候是有的可以有的报错的。再深入对比发现，新服务器为了将来的扩展我们安装了swoole扩展。可能问题就出在这里，马上删掉swoole扩展，问题解决。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在swoole官网也并没有找到相关的信息。预估可能是代码中或者在PHP-FPM的配置中有和swoole不兼容的地方。所以在运行的过程中没有流量的时候正常测试不会有影响，但流量较大的情况下就会产生这种错误。有的时候很多代码看似运行没毛病，但真正的问题往往还是要在大流量高并发的场景下才能体现出来。</p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-12-25 04:13:09', 1);
INSERT INTO `zy_articles_xs_test` VALUES (62, 'PHP中使用DOMDocument来处理HTML、XML文档', '<h1>PHP中使用DOMDocument来处理HTML、XML文档</h1><p>其实从PHP5开始，PHP就为我们提供了一个强大的解析和生成XML相关操作的类，也就是我们今天要讲的 DOMDocument 类。不过我估计大部分人在爬取网页时还是会喜欢用正则去解析网页内容，学了今天的这个类下回就可以尝试下使用这个PHP自带的方式来进行解析分析了。</p><h2>解析HTML</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 解析 HTML\n$baidu = file_get_contents(\'https://www.baidu.com\');\n\n$doc = new DOMDocument();\n@$doc-&gt;loadHTML($baidu);\n\n// 百度输出框\n$inputSearch = $doc-&gt;getElementById(\'kw\');\nvar_dump($inputSearch);\n\n// object(DOMElement)#2 \n//     ....\n\necho $inputSearch-&gt;getAttribute(\'name\'), PHP_EOL; // wd\n\n// 获取所有图片的链接\n$allImageLinks = [];\n$imgs = $doc-&gt;getElementsByTagName(\'img\');\nforeach($imgs as $img){\n    $allImageLinks[] = $img-&gt;getAttribute(\'src\');\n}\n\nprint_r($allImageLinks);\n\n// Array\n// (\n//     [0] =&gt; //www.baidu.com/img/baidu_jgylogo3.gif\n//     [1] =&gt; //www.baidu.com/img/bd_logo.png\n//     [2] =&gt; http://s1.bdstatic.com/r/www/cache/static/global/img/gs_237f015b.gif\n// )\n\n// 利用 parse_url 分析链接\nforeach($allImageLinks as $link){\n    print_r(parse_url($link));\n}\n\n// Array\n// (\n//     [host] =&gt; www.baidu.com\n//     [path] =&gt; /img/baidu_jgylogo3.gif\n// )\n// Array\n// (\n//     [host] =&gt; www.baidu.com\n//     [path] =&gt; /img/bd_logo.png\n// )\n// Array\n// (\n//     [scheme] =&gt; http\n//     [host] =&gt; s1.bdstatic.com\n//     [path] =&gt; /r/www/cache/static/global/img/gs_237f015b.gif\n// )</code></pre></div><p>是不是感觉好清晰，好有面向对象的感觉。就像第一次使用 ORM库 来进行数据库操作一样的感觉。我们一段一段来看。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$baidu = file_get_contents(\'https://www.baidu.com\');\n\n$doc = new DOMDocument();\n@$doc-&gt;loadHTML($baidu);</code></pre></div><p>首先是加载文档内容，这个比较好理解，直接使用 loadHTML() 方法加载 HTML 内容。它还提供了其它的几个方法，分别是：load() 从一个文件加载XML；loadXML() 从字符串加载XML；loadHTMLFile() 从文件加载HTML。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 百度输出框\n$inputSearch = $doc-&gt;getElementById(\'kw\');\nvar_dump($inputSearch);\n\n// object(DOMElement)#2 \n//     ....\n\necho $inputSearch-&gt;getAttribute(\'name\'), PHP_EOL; // wd</code></pre></div><p>接下来我们使用和前端 JS 一样的 DOM 操作API来操作HTML里面的元素。这个例子中就是获取百度的文本框，直接使用 getElementById() 方法获得id为指定内容的 DOMElement 对象。然后就可以获取它的值、属性之类的内容了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 获取所有图片的链接\n$allImageLinks = [];\n$imgs = $doc-&gt;getElementsByTagName(\'img\');\nforeach($imgs as $img){\n    $allImageLinks[] = $img-&gt;getAttribute(\'src\');\n}\n\nprint_r($allImageLinks);\n\n// Array\n// (\n//     [0] =&gt; //www.baidu.com/img/baidu_jgylogo3.gif\n//     [1] =&gt; //www.baidu.com/img/bd_logo.png\n//     [2] =&gt; http://s1.bdstatic.com/r/www/cache/static/global/img/gs_237f015b.gif\n// )\n\n// 利用 parse_url 分析链接\nforeach($allImageLinks as $link){\n    print_r(parse_url($link));\n}\n\n// Array\n// (\n//     [host] =&gt; www.baidu.com\n//     [path] =&gt; /img/baidu_jgylogo3.gif\n// )\n// Array\n// (\n//     [host] =&gt; www.baidu.com\n//     [path] =&gt; /img/bd_logo.png\n// )\n// Array\n// (\n//     [scheme] =&gt; http\n//     [host] =&gt; s1.bdstatic.com\n//     [path] =&gt; /r/www/cache/static/global/img/gs_237f015b.gif\n// )</code></pre></div><p>这一段例子则是获取HTML文档中所有的图片链接。相比正则来说，是不是方便很多，而且代码本身就是自解释的，不用考虑正则的匹配失效的问题。配合另外一个PHP中自带的 parse_url() 方法也能非常方便地对链接进行分析，提取自己想要的内容。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>XML的解析和对HTML的解析也是类似的，都使用 DOMDocument 和 DOMElement 提供的这个方法接口就可以很方便的进行解析了。那么我们想要生成一个标准格式的XML呢？当然也非常的简单，不需要再去拼接字符串了，使用这个类一样的进行对象化的操作。</p><h2>生成一个XML</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 生成一个XML文档\n$xml = new DOMDocument(\'1.0\', \'UTF-8\');\n\n$node1 = $xml-&gt;createElement(\'First\', \'This is First Node.\');\n$node1-&gt;setAttribute(\'type\', \'1\');\n\n$node2 = $xml-&gt;createElement(\'Second\');\n$node2-&gt;setAttribute(\'type\', \'2\');\n$node2_child = $xml-&gt;createElement(\'Second-Child\', \'This is Second Node Child.\');\n$node2-&gt;appendChild($node2_child);\n\n$xml-&gt;appendChild($node1);\n$xml-&gt;appendChild($node2);\nprint $xml-&gt;saveXML();\n\n/*\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;First type=\"1\"&gt;This is First Node.&lt;/First&gt;\n&lt;Second type=\"2\"&gt;&lt;Second-Child&gt;This is Second Node Child.&lt;/Second-Child&gt;&lt;/Second&gt;\n*/</code></pre></div><p>其实只要有一点点的前端 JS 的基础都不难看出这段代码的含义。使用 createElement() 方法创造 DOMElement 对象，然后就可以为它添加属性和内容。使用 appendChild() 方法就可以为当前的 DOMElement 或者 DOMDocument 添加下级节点。最后使用 saveXML() 就能够生成标准的XML格式内容了。</p><h2>总结</h2><p>通过上面两个简单的小例子，相信大家已经对这个 DOMDocument 操作XML类文件解析的方式非常感兴趣了。不过相对于正则解析的方式它们的性能有多大的差异并没有找到相关的测试，不过一般正常的情况下网站的HMTL文档都不会太大，毕竟各个网站也会考虑自身的加载速度，如果文档非常大的话用户体验也会很差，所以这套接口用来进行日常爬虫的分析处理工作基本是没有任何问题的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/PHP%E4%B8%AD%E4%BD%BF%E7%94%A8DOMDocument%E6%9D%A5%E5%A4%84%E7%90%86HTML%E3%80%81XML%E6%96%87%E6%A1%A3.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/PHP%E4%B8%AD%E4%BD%BF%E7%94%A8DOMDocument%E6%9D%A5%E5%A4%84%E7%90%86HTML%E3%80%81XML%E6%96%87%E6%A1%A3.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/class.domdocument.php\">https://www.php.net/manual/zh/class.domdocument.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-12-19 00:14:31', 1);
INSERT INTO `zy_articles_xs_test` VALUES (63, '一起搞懂PHP的错误和异常（一）', '<h1>一起搞懂PHP的错误和异常（一）</h1><p>在PHP的学习过程中，我们会接触到两个概念，一个是错误，一个是异常。啥玩意？他们不是一个东西嘛？如果接触过Java、C#之类的纯面向对象语言的同学，可能对异常是没有什么问题，毕竟所有的问题都可以try...catch来解决。但是像PHP这种从面向过程发展到面向对象的语言来说，错误和异常就是两个完全不同的东西了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们将用一系列的文章来彻底的搞懂PHP中的错误和异常到底是怎么回事，有哪些处理这些错误和异常的机制，我们应该如何对待它们。</p><h2>什么是错误？</h2><p>错误，一般是由PHP本身的因素所导致的问题，错误的语法、环境的配置不当等都会引起错误。错误和php.ini文件当中的error_reporting参数有直接的关系。相信大家都配过这个参数。一般会把它配置为 E_ALL &amp; ~E_NOTICE 。这是什么意思呢？我们先来看看PHP中有哪些错误类型：</p><ul><li><p>Fatal Error:致命错误（脚本终止运行）</p><ul><li><p>E_ERROR         // 致命的运行错误，错误无法恢复，暂停执行脚本</p></li><li><p>E_CORE_ERROR    // PHP启动时初始化过程中的致命错误</p></li><li><p>E_COMPILE_ERROR // 编译时致命性错，就像由Zend脚本引擎生成了一个E_ERROR</p></li><li><p>E_USER_ERROR    // 自定义错误消息。像用PHP函数trigger_error（错误类型设置为：E_USER_ERROR）</p></li></ul></li><li><p>Parse Error：编译时解析错误，语法错误（脚本终止运行）</p><ul><li><p>E_PARSE  //编译时的语法解析错误</p></li></ul></li><li><p>Warning Error：警告错误（仅给出提示信息，脚本不终止运行）</p><ul><li><p>E_WARNING         // 运行时警告 (非致命错误)。</p></li><li><p>E_CORE_WARNING    // PHP初始化启动过程中发生的警告 (非致命错误) 。</p></li><li><p>E_COMPILE_WARNING // 编译警告</p></li><li><p>E_USER_WARNING    // 用户产生的警告信息</p></li></ul></li><li><p>Notice Error：通知错误（仅给出通知信息，脚本不终止运行）</p><ul><li><p>E_NOTICE      // 运行时通知。表示脚本遇到可能会表现为错误的情况.</p></li><li><p>E_USER_NOTICE // 用户产生的通知信息。</p></li></ul></li></ul><p>在配置文件中的 E_ALL &amp; ~E_NOTICE 就是显示所有错误但通知错误类错误除外的意思。当然，我们在代码中也可以手动的改变这种错误信息的通知。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">error_reporting(E_ALL);</code></pre></div><p>通过这行代码，我们就让当前文件代码中的错误全部显示出来了。Notice 和 Warning 类型的错误是不会中断代码运行的，他们是通知和报警，并不是致命的错误。而其他类型的错误则会中断代码的执行。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$a = 100 / 0; // Warning: Division by zero\necho $f; // Notice: Undefined variable: f \ntest(); // Fatal error: Uncaught Error: Call to undefined function test()\n\necho 1;</code></pre></div><p>上述代码中分别是Warning的除0错误警告和echo $f;的未定义变量提示，这两行代码都是可以在报错后可以继续向下运行的。而未定义的方法则是Fatal级别的致命错误了。所以最后那个1也不会输出了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>那么错误要如何处理呢？原则上我们应该是要去消灭这些错误的，因为他们基本上不会是我们写代码的逻辑没理清而产生的逻辑错误，是实打实的一些语法及环境错误，这种错误在生产环境是不应该出现的。同时，它们与异常最最重要的一个区别就是，它们无法通过try...catch进行捕获。也就是说，这种错误没有非常好的错误后处理机制。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">try {\n    $a = 100 / 0; // Warning: Division by zero\n    echo $f; // Notice: Undefined variable: f \n} catch (Excepiton $e) {\n    print_r($e); // 无法捕获\n} </code></pre></div><p>不过，PHP还是提供了一些处理错误的函数供我们使用。</p><ol><li><p>set_error_handler()</p></li></ol><p>基本上只能处理 Warning 和 Notice 级别的错误。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">set_error_handler(function( $errno , $errstr ){\n    echo \'set_error_handler：\', $errno, $errstr, PHP_EOL;\n});\n$a = 100 / 0; // Warning: Division by zero\necho $f; // Notice: Undefined variable: f \ntest(); // Fatal error: Uncaught Error: Call to undefined function test()\n\n// set_error_handler：2Division by zero\n// set_error_handler：8Undefined variable: f</code></pre></div><p>从代码中可以看出，Fatal error这种致命错误并没有捕获到。</p><ol start=\"2\"><li><p>register_shutdown_function()</p></li></ol><p>其实它也不是用来处理错误的，这个函数的作用是在发生致命错误，程序停止前最后会调用的一个函数。可以用来记录日志或者关闭一些重要的外部句柄，不过在生产环境中，我们一般会用php.ini中的log_error来进行日志的记录。所以这个函数也用得并不多。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">register_shutdown_function(function(){\n    echo \'register_shutdown_function：\', PHP_EOL;\n    print_r(error_get_last());\n});\ntest();\n\n// register_shutdown_function：\n// Array\n// (\n//     [type] =&gt; 1\n//     [message] =&gt; Uncaught Error: Call to undefined function test() in /php/202002/source/一起搞懂PHP的错误和异常（一）.php:16\n// Stack trace:\n// #0 {main}\n//   thrown\n//     [file] =&gt; /php/202002/source/一起搞懂PHP的错误和异常（一）.php\n//     [line] =&gt; 16\n// )</code></pre></div><p>这个函数的回调函数中没有任何的参数变量，所以我们需要通过 error_get_last() 来拿到本次执行中发生的所有错误情况。另外要注意的是，只有在运行时产生的错误都会调用到这个注册函数的回调中，编译时的错误是也是无法通过这个函数捕获到的，比如直接的语法错误：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">register_shutdown_function(function(){\n    echo \'register_shutdown_function：\', PHP_EOL;\n    print_r(error_get_last());\n});\n\ntest(a+-); // Parse error: syntax error, unexpected \')\' </code></pre></div><h2>总结</h2><p>综上所述，就像在文章前面说过的，错误是应该尽量不要带到生产环境中去的，它们并没有很好的处理机制。或者说，错误就是我们要尽量避免的东西，因为大部分情况下它和我们的逻辑代码并没有太大的关系。而且严重的错误会直接导致程序运行的中止，无法像异常一样通过catch机制保证程序继续运行。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>下一篇我们将继续学习下一个知识点：<strong>异常</strong>及其处理机制。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E4%B8%80%E8%B5%B7%E6%90%9E%E6%87%82PHP%E7%9A%84%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%EF%BC%88%E4%B8%80%EF%BC%89.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E4%B8%80%E8%B5%B7%E6%90%9E%E6%87%82PHP%E7%9A%84%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%EF%BC%88%E4%B8%80%EF%BC%89.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.cnblogs.com/zyf-zhaoyafei/p/6928149.html\">https://www.cnblogs.com/zyf-zhaoyafei/p/6928149.html</a></p><p><a href=\"https://www.php.net/manual/zh/language.errors.basics.php\">https://www.php.net/manual/zh/language.errors.basics.php</a></p><p><a href=\"https://www.php.net/manual/zh/errorfunc.constants.php\">https://www.php.net/manual/zh/errorfunc.constants.php</a></p><p><a href=\"https://www.php.net/manual/zh/errorfunc.configuration.php#ini.error-reporting\">https://www.php.net/manual/zh/errorfunc.configuration.php#ini.error-reporting</a></p><p><a href=\"https://www.php.net/manual/zh/function.error-reporting.php\">https://www.php.net/manual/zh/function.error-reporting.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.set-error-handler.php\">https://www.php.net/manual/zh/function.set-error-handler.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.register-shutdown-function.php\">https://www.php.net/manual/zh/function.register-shutdown-function.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-05-29 04:40:19', 1);
INSERT INTO `zy_articles_xs_test` VALUES (64, '一起搞懂PHP的错误和异常（三）', '<h1>一起搞懂PHP的错误和异常（三）</h1><p>关于错误与异常的最后一篇文章，我们来进行一些总结。</p><h2>PHP中错误和异常的区别</h2><p>通过前面两篇文章的学习，我们来直接将错误和异常摆上来进行对比，看看他们的区别与联系：</p><ul><li><p>错误的出现通常是语法或编译运行时错误，是我们要避免的。而异常一般与业务逻辑有关，基本上是人为抛出，需要上层来处理</p></li><li><p>错误有通知、警告类不会中断程序运行，有严重错误会让程序立即中止运行。中止运行的程序没有别的方式让程序继续运行。异常可以通过try...catch捕获，捕获后的异常可以继续运行，不捕获的异常直接导致程序中止运行</p></li><li><p>错误的提示与php.ini中的配置有关，线上尽量不要显示错误。错误也尽量不要带线上。线上的错误记录到日志中，开发的错误显示则尽量打开方便开发人员及时调试。</p></li></ul><h2>PHP7对待错误的变化</h2><p>PHP7中重新定义了一些错误的处理方式，让大部分错误可以进行捕获。而且增加了一个 Throwable 接口，它可以捕获大部分的错误和所有的异常。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>也就是说，很多错误可以通过try...catch进行捕获了。而无法捕获的基本上是警告类的错误，这些错误可以通过  set_exception_handler() 进行注册处理。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>Error 类不是继承自 Exception 类，所以想全局捕获的话最好还是使用 Throwable 来进行捕获，不管是 Error 还是 Exception 都实现了这个接口。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">try {\n    test();\n} catch (Throwable $e) {\n    print_r($e);\n}\n\necho \'未定义test()\', PHP_EOL;\n\n\ntry {\n    new PDO();\n} catch (ArgumentCountError $e) {\n    print_r($e);\n}\n\necho \'没给PDO参数\', PHP_EOL;\n\nfunction test1() : int{\n    return \'test\';\n}\ntry {\n    test1();\n} catch (TypeError $e) {\n    print_r($e);\n}\n\necho \'返回值类型不正确\', PHP_EOL;</code></pre></div><p>上面的例子中我们捕获了在PHP5中被定义为错误的异常。如果不使用try...catch进行捕获的话，它们在PHP7中依然会被当做错误来对待。我们来看看 Throwable 下面都有哪些新增加的错误异常处理类。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>Throwable</p><ul><li><p>Error</p><ul><li><p>ArithmeticError</p><ul><li><p>DivisionByZeroError</p></li></ul></li><li><p>AssertionError</p></li><li><p>CompileError</p><ul><li><p>ParseError</p></li></ul></li><li><p>TypeError</p><ul><li><p>ArgumentCountError</p></li></ul></li></ul></li><li><p>Exception</p><ul><li><p>...</p></li></ul></li></ul><p>另外我们还可以通过全局注册来对异常进行全局处理，也就是上面所说的 set_exception_handler() 方法。注意，使用这个全局注册异常处理后，出现异常后面的代码将不执行了。相当于进行了截断，这样的话只能记录一个异常日志。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">set_exception_handler(function ($ex) {\n    echo \'set_exception_handler：\', PHP_EOL;\n    print_r($ex);\n});\ntest();\necho \'Not Execute...\'; // 不会输出了</code></pre></div><p>像是除0这种错误，经过测试发现 DivisionByZeroError 类还是无法捕获，这样的错误如果想捕获，我们可以使用 set_error_handler() 获取异常后再抛出错误。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">set_error_handler(function ($errno, $errmsg) {\n    if($errmsg == \'Division by zero\'){\n        throw new DivisionByZeroError();\n    }else{\n        throw new Error($errmsg, $errno + 10000);\n    }\n});\n\ntry{\n    100 / 0; // DivisionByZeroError：DivisionByZeroError Object\n    // echo $f; // Error: code = 10008\n}catch(DivisionByZeroError $e){\n    echo \'DivisionByZeroError：\'; \n    print_r($e);\n}catch(Error $e){\n    echo \'Error\'; \n    print_r($e);\n}</code></pre></div><p>通过 set_error_handler() 抛出异常，我们就可以捕获这些警告类型的错误了，不管是 warning 还是 notice 。可以切换注释来查看除0错误和未定义变量错误分别抛出的异常。不过就像我们一直强调的那样，这类错误是可以直接避免的，除前先对除数判断一下就可以直接抛出异常或者返回错误信息了，不要让PHP来报错。</p><h2>总结</h2><p>通过这三篇文章，可以说我们基本上能够清楚地了解PHP中错误和异常的区别、特点以及他们的使用场景，并且能够针对不同的错误和异常进行相应的处理了。当然，相关的内容其实还有很多，将来在发现类似的内容时我们还会通过单独的文章来进行独立的讲解。这次我们就先完结了总体的错误和异常的学习哈。接下来的学习将继续围绕PHP官方文档进行，后续依然精彩！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E4%B8%80%E8%B5%B7%E6%90%9E%E6%87%82PHP%E7%9A%84%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%EF%BC%88%E4%B8%89%EF%BC%89.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E4%B8%80%E8%B5%B7%E6%90%9E%E6%87%82PHP%E7%9A%84%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%EF%BC%88%E4%B8%89%EF%BC%89.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.errors.php7.php\">https://www.php.net/manual/zh/language.errors.php7.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.set-exception-handler.php\">https://www.php.net/manual/zh/function.set-exception-handler.php</a></p><p><a href=\"https://www.php.net/manual/en/class.error.php\">https://www.php.net/manual/en/class.error.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-12-14 09:56:53', 1);
INSERT INTO `zy_articles_xs_test` VALUES (65, '一起搞懂PHP的错误和异常（二）', '<h1>一起搞懂PHP的错误和异常（二）</h1><p>上回文章中我们讲到了错误是编译和语法运行时会出现的，它们与逻辑无关，是程序员在码代码时不应该出现的，也就是说，这些错误应该是尽量避免带到线上环境的，他们不能通过try...catch捕获到。而异常则正好相反。</p><h2>什么是异常？</h2><p>异常，指的是程序运行中出现的不符合预期的情况，通常允许它发生，并交由相应的异常处理来进行处理。当然，你也可以选择忽略掉异常的处理，但是就像严重错误一样，代码马上会终止运行。异常属于业务逻辑上的错误，基本上是我们人为的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>还是先通过一个简单的代码看下异常的抛出和捕获：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function test()\n{\n    throw new Exception(\'This is test Error...\');\n}\n\ntry {\n    test();\n} catch (Exception $e) {\n    print_r($e);\n}</code></pre></div><p>我们通过 throw 来抛出异常，然后在调用方法时将方法包裹在 try...catch 块中来捕获抛出的异常。这就是异常最基础的结构。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从这里我们可以看出，异常基本都是通过我们手动进行抛出的，让外部来进行处理。在PHP内部多数也是在类中会进行异常的抛出，这就是面向对象的错误处理思想了。比如说PDO类：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">try {\n    // $pdo = new PDO(); // Fatal error: Uncaught ArgumentCountError: PDO::__construct() expects at least 1 parameter, 0 given\n    $pdo = new PDO(\'\');\n} catch (PDOException $e) {\n    print_r($e); // invalid data source name\n}</code></pre></div><p>注意上面那行注释的代码，没有传参数是错误，是无法捕获的。而传了的参数不对，就是异常了，在PDO类的源码中发现参数不对进行了抛出。交给上层代码也就是我们这些调用方来进行捕获。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来，我们看下自定义的异常类和finally语句块的使用。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>自定义的异常类都会去继承 Exception 类，这个类可以看做是所有异常的基类。它的结构如下：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class Exception\n{\n    protected $message = \'Unknown exception\';   // 异常信息\n    private   $string;                          // __toString cache\n    protected $code = 0;                        // 用户自定义异常代码\n    protected $file;                            // 发生异常的文件名\n    protected $line;                            // 发生异常的代码行号\n    private   $trace;                           // backtrace\n    private   $previous;                        // previous exception if nested exception\n\n    public function __construct($message = null, $code = 0, Exception $previous = null);\n\n    final private function __clone();           // 不能被复制，如果clone异常类将直接产生致命错误\n\n    final public  function getMessage();        // 返回异常信息\n    final public  function getCode();           // 返回异常代码\n    final public  function getFile();           // 返回发生异常的文件名\n    final public  function getLine();           // 返回发生异常的代码行号\n    final public  function getTrace();          // backtrace() 数组\n    final public  function getPrevious();       // 之前的 exception\n    final public  function getTraceAsString();  // 已格成化成字符串的 getTrace() 信息\n\n    // Overrideable\n    public function __toString();               // 可输出的字符串\n}</code></pre></div><p>通过上述类定义，我们可以看出，我们能重写 构造函数 和 __toString() 方法，也能使用一些受保护的属性。那么我们就来定义一个自定义的异常类吧。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class TestException extends Exception\n{\n    protected $code = 200;\n\n    public function __construct($message = null, $code = 0, Exception $previous = null){\n        $this-&gt;message = \'TestException：\' . $message;\n    }\n\n    public function __toString(){\n        return \'code: \' . $this-&gt;code . \'; \' . $this-&gt;message;\n    }\n}\n\nfunction test2()\n{\n    throw new TestException(\'This is test2 Error...\');\n}\n\ntry {\n    test2();\n} catch (TestException $e) {\n    echo $e, PHP_EOL; // code: 200; TestException：This is test2 Error...\n}</code></pre></div><p>还是非常好理解的吧，大部分的PHP框架都会有自定义异常的组件或者能力供我们使用，因为现代框架还是以面向对象为基础的，所以异常会定义的比较详细。不同组件会提供不同的异常类来进行异常的提示封装。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来就是 finally 关键字，其实这个并没有什么可多说的，finally 的特点就是不管有没有出现异常，都会去执行 finally 关键字所定义代码块内部的内容。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">try {\n    test2();\n} catch (TestException $e) {\n    echo $e, PHP_EOL; \n} finally {\n    echo \'continue this code ...\', PHP_EOL;\n}\n// code: 200; TestException：This is test2 Error...\n// continue this code ...</code></pre></div><p>说了这么多，最后我们来结合上述内容来处理下除0错误的异常抛出。在文章开头已经说过，错误是应该避免的，而异常是属于逻辑业务的。所以当我们接到一个需要做除法的参数时，可以先判断这个数是否为0，如果是0的话，就抛出异常让上层调用者来处理，如果不是0的话，就让它正常进行除法运算就好了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function test3($d)\n{\n    if ($d == 0) {\n        throw new Exception(\'除数不能为0\');\n    }\n    return 1 / $d;\n}\n\ntry {\n    echo test3(2), PHP_EOL;\n} catch (Exception $e) {\n    echo \'Excepition：\' . $e-&gt;getMessage(), PHP_EOL;\n} finally {\n    echo \'finally：继续执行！\', PHP_EOL;\n}\n\n// 0.5\n// finally：继续执行！\n\ntry {\n    echo test3(0), PHP_EOL;\n} catch (Exception $e) {\n    echo \'Excepition：\' . $e-&gt;getMessage(), PHP_EOL;\n} finally {\n    echo \'finally：继续执行！\', PHP_EOL;\n}\n\n// Excepition：除数不能为0\n// finally：继续执行！</code></pre></div><h2>总结</h2><p>异常相关的使用就是这些了，通过这两篇文章，相信大家已经对PHP的错误和异常有了一些直观的了解了。接下来的文章我们将一起对比下错误和异常，并且说明一下PHP7对错误有了哪些改进。内容依然精彩，值得期待哦！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E4%B8%80%E8%B5%B7%E6%90%9E%E6%87%82PHP%E7%9A%84%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%EF%BC%88%E4%BA%8C%EF%BC%89.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E4%B8%80%E8%B5%B7%E6%90%9E%E6%87%82PHP%E7%9A%84%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%EF%BC%88%E4%BA%8C%EF%BC%89.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.cnblogs.com/init-007/p/11242813.html\">https://www.cnblogs.com/init-007/p/11242813.html</a></p><p><a href=\"https://www.php.net/manual/zh/language.exceptions.php\">https://www.php.net/manual/zh/language.exceptions.php</a></p><p><a href=\"https://www.php.net/manual/zh/class.exception.php\">https://www.php.net/manual/zh/class.exception.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.exceptions.extending.php\">https://www.php.net/manual/zh/language.exceptions.extending.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-07-02 22:28:11', 1);
INSERT INTO `zy_articles_xs_test` VALUES (66, '变着花样来接参，PHP中接收外部参数的方式', '<h1>变着花样来接参，PHP中接收外部参数的方式</h1><p>对于PHP这样一个web语言来说，接参是非常重要的一个能力。毕竟从前端表单或异步请求传递上来的数据都要获取到才能进行正常的交互展示。当然，这也是所有能够进行web开发的语言的必备能力。今天我们就来看看PHP各种各样的接参形式。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>首先，我们要准备一个静态页面，就像下面这个一样，它提供了一个表单，同时url里还带有一个GET参数：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;form action=\"?show=1\" method=\"post\"&gt;\n        姓名：&lt;input type=\"text\" name=\"name\"/&gt;&lt;br /&gt;\n        电话：&lt;input type=\"text\" name=\"tel\"/&gt;&lt;br/&gt;\n\n        地址（省）：&lt;input type=\"text\" name=\"address.prov\"/&gt;&lt;br/&gt;\n        地址（市）：&lt;input type=\"text\" name=\"address city\"/&gt;&lt;br/&gt;\n\n        兴趣1：&lt;input type=\"text\" name=\"interest[]\"/&gt;&lt;br/&gt;\n        兴趣2：&lt;input type=\"text\" name=\"interest[]\"/&gt;&lt;br/&gt;\n        兴趣3：&lt;input type=\"text\" name=\"interest[]\"/&gt;&lt;br/&gt;\n\n        学历1：&lt;input type=\"text\" name=\"edu[one]\"/&gt;&lt;br/&gt;\n        学历2：&lt;input type=\"text\" name=\"edu[two]\"/&gt;&lt;br/&gt;\n\n        &lt;input type=\"submit\" value=\"提交\" &gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre></div><h2>正常的$_GET、$_POST方式</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 正常的GET、POST\n    echo $_GET[\'show\'], \'&lt;br/&gt;\'; // 1\n    echo $_POST[\'name\'], \'&lt;br/&gt;\'; // 提交的内容</code></pre></div><p>这是最基础的也是最直接的接参方式，GET参数通过 $_GET 获取，POST参数通过 $_POST 获取，互相都不干扰。</p><h2>正常的$_REQUEST方式</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">    // 使用REQUEST\n    echo $_REQUEST[\'show\'], \'&lt;br/&gt;\'; // 1\n    echo $_REQUEST[\'tel\'], \'&lt;br/&gt;\'; // 提交的内容</code></pre></div><p>$_REQUEST 则是获取所有请求中的参数，不包括上传文件。也就是说，它包含了 $_GET 、 $_POST 以及 $_COOKIE(需要配置，默认不包含) 这三个接参变量中的所有内容。这里需要注意的一点是，PHP5.3以后， $_REQUEST 接受的参数变量内容由 php.ini 文件中的 request_order 指定，默认情况下这个配置参数的值是 GP 也就是 GET 和 POST ，并没有 COOKIE ，想要 COOKIE 的话需要修改这里添加一个C就可以了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>如果 $_GET 、 $_POST 中有同名的内容呢？ $_REQUEST 展示的顺序也是根据这配置参数的顺序来的，从左至右，后面的覆盖前面的，比如你配置的是GP 那么参数覆盖的顺序是： POST &gt; GET，最终显示的就是 POST 中的内容。</p><h2>register_globals问题</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">    // register_globals 如果打开\n    echo $name, \'&lt;br/&gt;\'; // 提交的内容\n    echo $tel, \'&lt;br/&gt;\'; // 提交的内容</code></pre></div><p>这是一个不安全的配置，也是在 php.ini 文件中进行配置的。它的作用就是将请求来的参数直接转成变量，有全局变量污染的问题，不要打开！！！现在的 php.ini 文件中基本都是默认关闭的。</p><h2>import_request_variables</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">    // import_request_variables 抱歉，5.4之后已经取消了\n    import_request_variables(\'pg\', \'pg_\');\n    echo $pg_show, \'&lt;br/&gt;\';\n    echo $pg_name, \'&lt;br/&gt;\';</code></pre></div><p>这个函数是手动将指定的参数变量里面的内容注册为全局变量，同样的，它也在5.4之后被取消的，这样的函数都会存在风险，我们了解一下曾经有过这样一个函数即可。</p><h2>extract</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">    extract($_POST, EXTR_PREFIX_ALL, \'ex\');\n    echo $ex_name, \'&lt;br/&gt;\'; // 提交的内容\n    echo $ex_tel, \'&lt;br/&gt;\'; // 提交的内容</code></pre></div><p>extract 是目前可以代替上面两种参数转变量的方式中目前依然支持的。它是由我们自己来控制对已存在变量的覆盖的，也就是第二个参数，这样在可控的环境下可以极大地避免污染全局变量的问题，当然前提还是我们自己要确定使用它，具体内容可以自行查找文档参考哦！</p><h2>参数名中的.和空格</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">    // 参数名中的.和空格\n    echo $_REQUEST[\'address_prov\'], \'&lt;br/&gt;\'; // 提交的内容\n    echo $_REQUEST[\'address_city\'], \'&lt;br/&gt;\'; // 提交的内容</code></pre></div><p>表单提交的 input 的 name 中如果包含 . 或者 空格 ，将直接转换成 下划线 。不过我们在前端命名中也不建议使用 . 或者 空格 ，需要的时候直接就使用 下划线 就好了，前后端不要造成歧义。</p><h2>参数名中的[]</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">    // 参数名中的[]\n    print_r($_REQUEST[\'interest\']); // Array (v,....) \n    echo \'&lt;br /&gt;\';\n    print_r($_REQUEST[\'edu\']); // Array (k/v,....) </code></pre></div><p>当表单提交的 input 的 name 是数组形式的，也就是 \"interest[]\" 或 \"edu[one]\" 这种形式时，我们接收到的参数默认就会成为一个数组形式的内容。</p><h2>高大上的php://input</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">    // php://input\n    $content = file_get_contents(\'php://input\');   \n    print_r($content); //name=xxx&amp;.....</code></pre></div><p>最后就是现在接口开发中经常会使用的 php://input 形式接参。一般是因为安全或参数字段较多的情况下，前端通过 Body Raw 的形式直接传递一整段的 Body 内容过来。这时候就只能用这种形式获取到了，这个 Body Raw 的原始内容一般会是一整段的文字，也有可能是进行过一些加密处理的内容，格式可以自己定义。而面对普通表单，我们将会接收到的也是原始的表单内容，就像上面的 name=xxx&amp;tel=xxx&amp;.... 这样的内容。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>需要注意的是 enctype=\"multipart/form-data\" 时它是无法获取到内容的。同时，这种方式也是代替 $HTTP_RAW_POST_DATA 全局变量的，不要再使用淘汰的能力了哦，尽早更新新版本的PHP使用新的语法特性哦！</p><h2>总结</h2><p>随便一整理就发现原来简简单单的一个接参就有这么多种形式和需要注意的地方，还真是大开眼界。依然是那句话，学无止尽，继续深入的钻研早晚你也会成为大牛！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E5%8F%98%E7%9D%80%E8%8A%B1%E6%A0%B7%E6%9D%A5%E6%8E%A5%E5%8F%82%EF%BC%8CPHP%E4%B8%AD%E6%8E%A5%E6%94%B6%E5%A4%96%E9%83%A8%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E5%8F%98%E7%9D%80%E8%8A%B1%E6%A0%B7%E6%9D%A5%E6%8E%A5%E5%8F%82%EF%BC%8CPHP%E4%B8%AD%E6%8E%A5%E6%94%B6%E5%A4%96%E9%83%A8%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.variables.external.php\">https://www.php.net/manual/zh/language.variables.external.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.import-request-variables.php\">https://www.php.net/manual/zh/function.import-request-variables.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.extract.php\">https://www.php.net/manual/zh/function.extract.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-03-30 02:26:08', 1);
INSERT INTO `zy_articles_xs_test` VALUES (67, '在PHP中如何为匿名函数指定this？', '<h1>在PHP中如何为匿名函数指定this？</h1><p>在之前的文章中，我们已经学习过匿名函数的使用，没有看过的小伙伴可以进入传送门先去了解下闭包匿名函数的用法，传送：<a href=\"https://mp.weixin.qq.com/s/R6vkVxidjsFf5YJ-kHN1Cw\">还不知道PHP有闭包？那你真OUT了</a>。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>关于闭包匿名函数，在JS中有个很典型的问题就是要给它绑定一个 this 作用域。其实这个问题在PHP中也是存在的，比如下面这段代码：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$func = function($say){\n    echo $this-&gt;name, \'：\', $say, PHP_EOL;\n};\n$func(\'good\'); // Fatal error: Uncaught Error: Using $this when not in object context </code></pre></div><p>在这个匿名函数中，我们使用了 \\$this-&gt;name 来获取当前作用域下的 $name 属性，可是，这个 $this 是谁呢？我们并没有定义它，所以这里会直接报错。错误信息是：使用了 $this 但是没有对象上下文，也就是说没有指定 $this 引用的作用域。</p><h2>bindTo() 方法绑定 $this</h2><p>好吧，那么我们就给它一个作用域，和 JS 一样，使用一个 bindTo() 方法即可。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$func1 = $func-&gt;bindTo($lily, \'Lily\');\n// $func1 = $func-&gt;bindTo($lily, Lily::class);\n// $func1 = $func-&gt;bindTo($lily, $lily);\n$func1(\'cool\');</code></pre></div><p>这回就可以正常输出了。 bindTo() 方法是复制一个当前的闭包对象，然后给它绑定 $this 作用域和类作用域。其中， $lily 参数是一个 object $newthis 参数，也就是给这个复制出来的匿名函数指定 $this 。而第二个参数 \'Lily\' 则是绑定一个新的 类作用域 ，它代表一个类型、决定在这个匿名函数中能够调用哪些 私有 和 受保护 的方法，上例中给出的三种方式都可以用来定义这个参数。如果不给这个参数，那么我们就不能访问这个 private 的 $name 属性了：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$func2 = $func-&gt;bindTo($lily);\n$func2(\'cool2\'); // Fatal error: Uncaught Error: Cannot access private property Lily::$name</code></pre></div><h2>call() 方法绑定 $this</h2><p>在PHP7以后，PHP新增加了 call() 方法来进行匿名函数的 $this 绑定，我们来看看它和 bindTo() 方法有哪些区别。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$func-&gt;call($lily, \'well\'); // Lily：well</code></pre></div><p>额......</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>是不是感觉方便好多。首先，它直接执行了，不需要再赋值给一个变量，也就是说，它不是去复制那个闭包函数的而是直接执行了；其次，没有 类作用域 这个概念了，第一个参数还是指定新的 $this 的指向，而后面的参数就是原来闭包函数的参数。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>虽然很方便，但是它也带来了另一个问题，因为没有 类作用域 的限制，所以会破坏封装。你好不容易做好的面向对象的设计，封装了一堆属性，然后使用这个 call() 就让对象的所有 私有 和 受保护 内容都暴露了出来。当然，这也是看我们自己的业务情况了，毕竟两种形式我们在写代码的时候都是可以自由选择的。</p><h2>总结</h2><p>其实包括闭包函数在内，这些特性都非常像JS。这也是语言融合的一种趋势，不管是学习了JS来看PHP的这些特性还是先学了PHP再去看JS，都会让我们更容易理解它们的作用与能力，这就是语言特性融合带来的好处。不管怎么样，学就是了，继续加油吧！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E5%9C%A8PHP%E4%B8%AD%E5%A6%82%E4%BD%95%E4%B8%BA%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E6%8C%87%E5%AE%9Athis%EF%BC%9F.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E5%9C%A8PHP%E4%B8%AD%E5%A6%82%E4%BD%95%E4%B8%BA%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E6%8C%87%E5%AE%9Athis%EF%BC%9F.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/functions.anonymous.php\">https://www.php.net/manual/zh/functions.anonymous.php</a></p><p><a href=\"https://www.php.net/manual/zh/closure.bindto.php\">https://www.php.net/manual/zh/closure.bindto.php</a></p><p><a href=\"https://www.php.net/manual/en/closure.call.php\">https://www.php.net/manual/en/closure.call.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-01-16 09:10:27', 1);
INSERT INTO `zy_articles_xs_test` VALUES (68, '学习PHP生成器的使用', '<h1>学习PHP生成器的使用</h1><h2>什么是生成器？</h2><p>听着高大上的名字，感觉像是创造什么东西的一个功能，实际上，生成器是一个用于迭代的迭代器。它提供了一种更容易的方式来实现简单的对象迭代，相比较定义类实现Iterator接口的方式，性能开销和复杂性大大降低。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>说了半天不如直接看看代码更直观。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function test1()\n{\n    for ($i = 0; $i &lt; 3; $i++) {\n        yield $i + 1;\n    }\n    yield 1000;\n    yield 1001;\n}\n\nforeach (test1() as $t) {\n    echo $t, PHP_EOL;\n}\n\n// 1\n// 2\n// 3\n// 1000\n// 1001</code></pre></div><p>就是这么简单的一段代码。首先，生成器必须在方法中并使用 yield 关键字；其次，每一个 yield 可以看作是一次 return ；最后，外部循环时，一次循环取一个 yield 的返回值。在这个例子，循环三次返回了1、2、3这三个数字。然后在循环外部又写了两行 yield 分别输出了1000和1001。因此，外部的 foreach 一共循环输出了五次。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>很神奇吧，明明是一个方法，为什么能够循环它而且还是很奇怪的一种返回循环体的格式。我们直接打印这个 test() 方法看看打印的是什么：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 是一个生成器对象\nvar_dump(test1());\n\n// Generator Object\n// (\n// )</code></pre></div><p>当使用了 yield 进行内容返回后，返回的是一个 Generator 对象。这个对象就叫作生成器对象，它不能直接被 new 实例化，只能通过生成器函数这种方式返回。这个类包含 current() 、 key() 等方法，而且最主要的这个类实现了 Iterator 接口，所以，它就是一个特殊的迭代器类。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">Generator implements Iterator {\n    /* 方法 */\n    public current ( void ) : mixed\n    public key ( void ) : mixed\n    public next ( void ) : void\n    public rewind ( void ) : void\n    public send ( mixed $value ) : mixed\n    public throw ( Exception $exception ) : void\n    public valid ( void ) : bool\n    public __wakeup ( void ) : void\n}</code></pre></div><h2>生成器有什么用？</h2><p>搞了半天不就是个迭代器嘛？搞这么麻烦干嘛，直接用迭代器或者在方法中直接返回一个数组不就好了吗？没错，正常情况下真的没有这么麻烦，但是如果是在数据量特别大的情况下，这个生成器就能发挥它的强大威力了。生成器最最强大的部分就在于，它不需要一个数组或者任何的数据结构来保存这一系列数据。每次迭代都是代码执行到 yield 时动态返回的。因此，生成器能够极大的节约内存。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 内存占用测试\n$start_time = microtime(true);\nfunction test2($clear = false)\n{\n    $arr = [];\n    if($clear){\n        $arr = null;\n        return;\n    }\n    for ($i = 0; $i &lt; 1000000; $i++) {\n        $arr[] = $i + 1;\n    }\n    return $arr;\n}\n$array = test2();\nforeach ($array as $val) {\n}\n$end_time = microtime(true);\n\necho \"time: \", bcsub($end_time, $start_time, 4), PHP_EOL;\necho \"memory (byte): \", memory_get_usage(true), PHP_EOL;\n\n// time: 0.0513\n// memory (byte): 35655680\n\n$start_time = microtime(true);\nfunction test3()\n{\n    for ($i = 0; $i &lt; 1000000; $i++) {\n        yield $i + 1;\n    }\n}\n$array = test3();\nforeach ($array as $val) {\n\n}\n$end_time = microtime(true);\n\necho \"time: \", bcsub($end_time, $start_time, 4), PHP_EOL;\necho \"memory (byte): \", memory_get_usage(true), PHP_EOL;\n\n// time: 0.0517\n// memory (byte): 2097152</code></pre></div><p>上述代码只是简单的进行 1000000 个循环后获取结果，不过也可以直观地看出。使用生成器的版本仅仅消耗了 2M 的内存，而未使用生成器的版本则消耗了 35M 的内存，直接已经10多倍的差距了，而且越大的量差距超明显。因此，有大神将生成器说成是PHP中最被低估了的一个特性。</p><h2>生成器的应用</h2><p>接下来我们来看看生成器的一些基本的应用方式。</p><h3>返回空值以及中断</h3><p>生成器当然也可以返回空值，直接 yield; 不带任何值就可以返回一个空值了。而在方法中直接使用 return; 也可以用来中断生成器的继续执行。下面的代码我们在 \\$i = 4; 的时候返回的是个空值，也就是不会输出 5 （因为我们返回的是 $i + 1 ）。然后在 $i == 7 的时候使用 return; 中断生成器的继续执行，也就是循环最多只会输出到 7 就结束了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 返回空值以及中断\nfunction test4()\n{\n    for ($i = 0; $i &lt; 10; $i++) {\n        if ($i == 4) {\n            yield; // 返回null值\n        }\n        if ($i == 7) {\n            return; // 中断生成器执行\n        }\n        yield $i + 1;\n    }\n}\n\nforeach (test4() as $t) {\n    echo $t, PHP_EOL;\n}\n\n\n// 1\n// 2\n// 3\n// 4\n\n// 5\n// 6\n// 7</code></pre></div><h3>返回键值对形式</h3><p>不要惊讶，生成器真的是可以返回键值对形式的可遍历对象供 foreach 使用的，而且语法非常好记： yield key =&gt; value; 是不是和数组项的定义形式一模一样，非常直观好理解。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function test5()\n{\n    for ($i = 0; $i &lt; 10; $i++) {\n        yield \'key.\' . $i =&gt; $i + 1;\n    }\n}\n\nforeach (test5() as $k=&gt;$t) {\n    echo $k . \':\' . $t, PHP_EOL;\n}\n\n// key.0:1\n// key.1:2\n// key.2:3\n// key.3:4\n// key.4:5\n// key.5:6\n// key.6:7\n// key.7:8\n// key.8:9\n// key.9:10</code></pre></div><h3>外部传递数据</h3><p>我们可以通过 Generator::send 方法来向生成器中传入一个值。传入的这个值将会被当做生成器当前 yield 的返回值。然后我们根据这个值可以做一些判断，比如根据外部条件中断生成器的执行。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function test6()\n{\n    for ($i = 0; $i &lt; 10; $i++) {\n        // 正常获取循环值，当外部send过来值后，yield获取到的就是外部传来的值了\n        $data = (yield $i + 1);\n        if($data == \'stop\'){\n            return;\n        }\n    }\n}\n$t6 = test6();\nforeach($t6 as $t){\n    if($t == 3){\n        $t6-&gt;send(\'stop\');\n    }\n    echo $t, PHP_EOL;\n}\n\n// 1\n// 2\n// 3</code></pre></div><p>上述代码理解起来可能比较绕，但是注意记住注释的那行话就行了（正常获取循环值，当外部send过来值后，yield获取到的就是外部传来的值了）。另外，变量获取 yield 的值，必须要用括号括起来。</p><h3>yield from 语法</h3><p>yield from 语法其实就是指的从另一个可迭代对象中一个一个的获取数据并形成生成器返回。直接看代码。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function test7()\n{\n    yield from [1, 2, 3, 4];\n    yield from new ArrayIterator([5, 6]);\n    yield from test1();\n}\nforeach (test7() as $t) {\n    echo \'test7：\', $t, PHP_EOL;\n}\n\n// test7：1\n// test7：2\n// test7：3\n// test7：4\n// test7：5\n// test7：6\n// test7：1\n// test7：2\n// test7：3\n// test7：1000</code></pre></div><p>在 test7() 方法中，我们使用 yield from 分别从普通数组、迭代器对象、另一个生成器中获取数据并做为当前生成器的内容进行返回。</p><h2>小惊喜</h2><h3>生成器可以用count获取数量吗？</h3><p>抱歉，生成器是不能用count来获取它的数量的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$c = count(test1()); // Warning: count(): Parameter must be an array or an object that implements Countable\n// echo $c, PHP_EOL;</code></pre></div><p>使用 count 来获取生成器的数量将直接报 Warning 警告。直接输出将会一直显示是 1 ，因为 count 的特性（强制转换成数组都会显示 1 ）。</p><h3>使用生产器来获取斐波那契数列</h3><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 利用生成器生成斐波那契数列\nfunction fibonacci($item)\n{\n    $a = 0;\n    $b = 1;\n    for ($i = 0; $i &lt; $item; $i++) {\n        yield $a;\n        $a = $b - $a;\n        $b = $a + $b;\n    }\n}\n\n$fibo = fibonacci(10);\nforeach ($fibo as $value) {\n    echo \"$value\\n\";\n}</code></pre></div><p>这段代码就不多解释了，非常直观的一段代码了。</p><h2>总结</h2><p>生成器绝对是PHP中的一个隐藏的宝藏，不仅是对于内存节约来说，而且语法其实也非常的简洁明了。我们不需要在方法内部再多定义一个数组去存储返回值，直接 yield 一项一项的返回就可以了。在实际的项目中完全值得尝试一把，但是尝试完了别忘了和小伙伴们分享，大部分人可能真的没有接触过这个特性哦！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E5%AD%A6%E4%B9%A0PHP%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E5%AD%A6%E4%B9%A0PHP%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.generators.overview.php\">https://www.php.net/manual/zh/language.generators.overview.php</a></p><p><a href=\"https://www.php.net/manual/zh/class.generator.php\">https://www.php.net/manual/zh/class.generator.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-01-09 23:10:55', 1);
INSERT INTO `zy_articles_xs_test` VALUES (69, '彻底搞明白PHP的中引用的概念', '<h1>彻底搞明白PHP的中引用的概念</h1><p>之前我们其实已经有过几篇文章讲过引用方面的问题，这次我们来全面的梳理一下引用在PHP到底是怎么回事，它和C中的指针有什么不同，在使用的时候要注意些什么。</p><h2>什么是引用？</h2><p><strong>在 PHP 中引用意味着用不同的名字访问同一个变量内容。它不是C的指针，保存的并不是内存地址，无法进行指针运算。引用只是符号表的别名。就像 Unix 系统中的硬链接， Windows 系统中的快捷方式。</strong></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上面是官方手册中的原文，怎么说呢，引用其实和我们印象中的C里面的指针并不是相同的概念。指针是针对真实内存的操作，引用是针对指向这个内存的符号表的操作。还是从操作系统的快捷方式来说，快捷方式是可以删的，这就是PHP的引用。而C不仅删了快捷方式，还把原文件也给删了，这就是C的指针操作。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 引用不是指针\n$a = 1;\n$b = &amp;$a;\necho $a, \'===\', $b, PHP_EOL;\nunset($b);\necho $a, \'===\', $b, PHP_EOL;</code></pre></div><p>上面的代码是在PHP中，我们把$b变量指向$a，作为$a的引用变量。然后删除$b，对$a没有任何影响。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n    // C 中的指针和引用\n    int a = 1;\n    int* b = &amp;a;\n    printf(\"%i\\n\", a); // 1\n    free(b); // free b\n    printf(\"%i\\n\", a); //get error: *** error for object 0x7fff6350da08: pointer being freed was not allocated\n    return 0;\n}</code></pre></div><p>而C中的引用指针就不行了，我们把b变量删掉后，再打印a变量就直接报错了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>虽然说PHP的底层也是C写得，但我们都知道C中的指针是出了名的变态，没有一定的功底非常容易出错。所以PHP的开发者没有暴露C的原始指针能力，而是采用了和Java之类的类似的引用能力。这也是现代语言的特性，不需要我们过多的关注过于底层的能力，而将更多的时间放在业务实现上。</p><h2>引用在数组和对象中的使用</h2><p><strong>如果具有引用的数组被拷贝，其值不会解除引用。对于数组传值给函数也是如此。</strong></p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$arr1 = [\"a\", \"b\"];\n$t1 = &amp;$arr1[1];\n$arr2 = $arr1;\n$arr2[1] = \"c\";\nvar_dump($arr1);\n\n// array(2) {\n//     [0]=&gt;\n//     string(1) \"a\"\n//     [1]=&gt;\n//     &amp;string(1) \"c\"\n// }\n\n$arr1 = [\"a\", \"b\"];\n$t1 = &amp;$arr1[1];\nunset($t1); // unset 掉引用\n$arr2 = $arr1;\n$arr2[1] = \"c\";\nvar_dump($arr1);\n\n// array(2) {\n//     [0]=&gt;\n//     string(1) \"a\"\n//     [1]=&gt;\n//     string(1) \"b\"\n// }</code></pre></div><p>这个其实挺有意思的，我们对比这两个例子可以看出一个问题，$t变量指向$arr[1]的引用。$arr2直接=这个$arr1，没有使用引用，然后$arr2修改了$arr2[1]的内容，$arr1相应的内容也发生了改变，如果unset掉$t变量，则$arr1相应的内容就不会发生改变。对此，我在文档中找到了下面的解释：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><strong>由于PHP内部工作的特殊性，如果对数组的单个元素进行引用，然后复制数组，无论是通过赋值还是通过函数调用中的值传递，都会将引用复制为数组的一部分。这意味着对任一数组中任何此类元素的更改都将在另一个数组（和其他引用中）中重复，即使数组具有不同的作用域（例如，一个是函数内部的参数，另一个是全局的）！在复制时没有引用的元素，以及在复制数组后分配给其他元素的引用，将正常工作（即独立于其他数组）。</strong></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>不仅仅是数组，对象的引用也会有一些好玩的问题。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$o1 = new stdClass();\n$o1-&gt;a = \'a\';\nvar_dump($o1);\n// object(stdClass)#1 (1) {\n//   [\"a\"]=&gt;\n//   string(1) \"a\"\n// }\n\n$o2 = &amp;$o1;\n$o3 = $o1;\n\n$o2-&gt;a = \'aa\';\n\nvar_dump($o1);\n// object(stdClass)#1 (1) {\n//   [\"a\"]=&gt;\n//   string(2) \"aa\"\n// }\n\nvar_dump($o3); // $o2修改了$a为\'aa\'，$o3也变成了\'aa\'\n// object(stdClass)#1 (1) {\n//   [\"a\"]=&gt;\n//   string(2) \"aa\"\n// }\n\n$o1-&gt;a = \'aaa\';\n$o1 = null;\nvar_dump($o2); // $o2引用变成了null\n// NULL\n\nvar_dump($o3); // $o3不仅引用还存在，并且$a变成了\'aaa\'\n// object(stdClass)#1 (1) {\n//   [\"a\"]=&gt;\n//   string(3) \"aaa\"\n// }</code></pre></div><p>上面例子中有三个对象，$o1、$o2、$o3，其中，$o2是对$o1的引用，$o3是直接赋值为$o1。对$o2属性的操作不仅会反映在$o1中，也会反映到$o3中。其实我们之前专门有一篇文章就讲的这个问题，首先对象默认赋值就是引用，其次这个例子很好地证明了引用就是一个符号表的绑定。删除了快捷方式对原始对象和其他快捷方式没有任何影响。大家可以参考：<a href=\"https://mp.weixin.qq.com/s/wKIU83A7u1ENQF32jX5FSQ\">对象赋值在PHP中到底是不是引用？</a></p><h2>引用的传递</h2><p>关于引用在方法参数上的传递，最重要的是记住两点：一是方法内部修改了变量外部也会变，这是引用的特性嘛；二是只能传递变量、New 语句、从函数中返回的引用三种类型。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">error_reporting(E_ALL);\nfunction foo(&amp;$var)\n{\n    $var++;\n    echo \'foo：\', $var;\n}\nfunction bar() // Note the missing &amp;\n{\n    $a = 5;\n    return $a;\n}\nfoo(bar()); // 自 PHP 5.0.5 起导致致命错误，自 PHP 5.1.1 起导致严格模式错误\n            // 自 PHP 7.0 起导致 notice 信息,Notice: Only variables should be passed by reference\nfoo($a = 5); // 表达式，不是变量, Notice: Only variables should be passed by reference\n// foo(5); // 导致致命错误 !5是个常量!\n\n///////////////////////////////\n// 正确的传递类型\n$a = 5;\nfoo($a); // 变量\n\nfunction &amp;baz()\n{\n    $a = 5;\n    return $a;\n}\nfoo(baz()); // 从函数中返回的引用\n\nfunction foo1(&amp;$var)\n{\n    print_r($var);\n}\nfoo1(new stdClass()); // new 表达式</code></pre></div><h2>引用的返回</h2><p>引用的返回并不是经常使用的一个能力。文档中的原文是：<strong>不要用返回引用来增加性能，引擎足够聪明来自己进行优化。仅在有合理的技术原因时才返回引用！</strong></p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$a = 1;\nfunction &amp;test(){\n    global $a;\n    return $a;\n}\n\n$b = &amp;test($a);\n$b = 2;\necho $a, PHP_EOL;</code></pre></div><p>当你想要返回一个引用变量的时候，一定要给方法定义和方法调用的时候都使用&amp;符号。这个是需要注意的点。当其他地方修改原本的变量值或者返回的变量值经过修改后，都会影响到所有调用这个值的地方。所以说，引用的返回是比较危险的，因为你不清楚什么时候在什么地方这个值可能发生了修改，对于bug的排查会非常困难。</p><h2>引用的取消</h2><p>取消引用其实就是直接unset掉变量就可以了。但是一定要记住，PHP中的引用是指向的符号表，对原始真实的值是不起作用的，所以即使unset掉了最原始的那个变量，对其它引用赋值的变量也不会有影响！！</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$a = 1;\n$b = &amp;$a;\n$c = &amp;$b;\n$b = 2;\necho \'定义引用后：\', $a, \'===\', $b, \'===\', $c, PHP_EOL;\n\nunset($b);\n$b = 3;\necho \'取消$b的引用，不影响$a、$c：\', $a, \'===\', $b, \'===\', $c, PHP_EOL;\n\n$b = &amp;$a;\nunset($a);\necho \'取消$a，不影响$b、$c：\', $a, \'===\', $b, \'===\', $c, PHP_EOL;\n\n// 定义引用后：2===2===2\n// 取消$b的引用：2===3===2\n// 取消$a，不影响$c：===3===2\n\n\n$a = 1;\n$b = &amp; $a;\n$c = &amp; $b; // $a, $b, $c reference the same content \'1\'\n\n$a = NULL; // All variables $a, $b or $c are unset\necho \'所有引用成空：\', $a, \'===\', $b, \'===\', $c, PHP_EOL;</code></pre></div><h2>总结</h2><p>这一次算是比较彻底的把引用说了个透。关于PHP的引用只要记住了它的定义就非常好理解了，最直观的就是当成是操作系统的快捷方式就好了，并没有我们想象中的那么难，和C的指针相比真的只是娃娃级别，多多练习多多复习自然就能很好地掌握使用啦！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%98%8E%E7%99%BDPHP%E7%9A%84%E4%B8%AD%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202002/source/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%98%8E%E7%99%BDPHP%E7%9A%84%E4%B8%AD%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/language.references.whatare.php\">https://www.php.net/manual/zh/language.references.whatare.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.references.whatdo.php\">https://www.php.net/manual/zh/language.references.whatdo.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.references.arent.php\">https://www.php.net/manual/zh/language.references.arent.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.references.pass.php\">https://www.php.net/manual/zh/language.references.pass.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.references.return.php\">https://www.php.net/manual/zh/language.references.return.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.references.unset.php\">https://www.php.net/manual/zh/language.references.unset.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.references.spot.php\">https://www.php.net/manual/zh/language.references.spot.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-10-19 05:28:27', 1);
INSERT INTO `zy_articles_xs_test` VALUES (70, 'PHP大文件读取操作', '<h1>PHP大文件读取操作</h1><p>简单的文件读取，一般我们会使用 file_get_contents() 这类方式来直接获取文件的内容。不过这种函数有个严重的问题是它会把文件一次性地加载到内存中，也就是说，它会受到内存的限制。因此，加载大文件的时候是绝对不能使用这种方式的。我们还是先看看这种方式加载的例子。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 普通的文件读取 一个2.4G的SQL导出文件\n$fileName= \'./2020-02-23.sql\';\n\n// file_get_contents\n$fileInfo = file_get_contents($fileName);\n// Fatal error: Allowed memory size of 134217728 bytes exhausted\n\n// file\n$fileInfo = file($fileName);\n// Fatal error: Allowed memory size of 134217728 bytes exhausted\n\n// fopen + fread\n$fileHandle = fopen($fileName, \'r\');\n$fileInfo = fread($fileHandle, filesize($fileName));\n// Fatal error: Allowed memory size of 134217728 bytes exhausted</code></pre></div><p>上述三种形式的文件加载读取方式都是不能加载这么大的文件的，当然，你也可以修改 php.ini 中的相关配置让他们能够加载成功，但我们并不推荐这样使用，毕竟内存资源相比硬盘资源还是要宝贵的多。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>以下的方式是可以直接读取这种大文件的：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// readfile 只能直接输出\necho readfile($fileName);\n\n// fopen + fgetc 如果单\n$fileHandle = fopen($fileName, \'r\');\n// 输出单字符直到 end-of-file\nwhile(!feof($fileHandle)) {\n    echo fgetc($fileHandle);\n}\nfclose($fileHandle);\n\n// SplFileObject\n$fileObject = new SplFileObject($fileName, \'r\');\nwhile(!$fileObject-&gt;eof()){\n    echo $fileObject-&gt;fgetc();\n}</code></pre></div><p>第一个 readfile() ，读取文件后就直接打印了，不能进行其他操作，适用于直接显示大文件内容时使用。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>第二个 fopen() 配合 fgetc() 或 fgets() 是读取这种大文件的标配。fopen() 获取文件句柄，fgetc() 按字符读取，fgets() 按行读取。像这个 mysqldump 出来的文件，一行也可能非常的大，所以我们就只能直接按字符读取。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>第三个是SPL扩展库为我们提供的面向对象式的 fopen() 操作，建议新的开发中如果有读取大文件的需求最好使用这种形式的写法，毕竟SPL函数库已经是PHP的标准函数库了，而且面向对象的操作形式也更加的主流。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上面三种读取方式都有一个要注意的点是，我们将大文件读取后不应该再保存到变量中，应该直接打印显示、入库或者写到其他文件中。因为直接读取到一个变量中就和前面的直接读取到内存的方式一样了，那还不如直接去修改下 php.ini 的配置然后使用最上方的方式直接读取到内存方便。还是那句话，内存留给真正需要它的地方，这种大文件，最好还是进行硬盘的IO操作。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/PHP%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/PHP%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p>《PHP7编程实战》</p>', 'PHP', 'PHP基础,文件操作', '2022-07-23 18:06:29', '2020-01-11 00:53:33', 1);
INSERT INTO `zy_articles_xs_test` VALUES (71, 'PHP操作用户提交内容时需要注意的危险函数', '<h1>PHP操作用户提交内容时需要注意的危险函数</h1><p>对于我们的程序开发来说，用户的输入是解决安全性问题的第一大入口。为什么这么说呢？不管是SQL注入、XSS还是文件上传漏洞，全部都和用户提交的输入参数有关。今天我们不讲这些问题，我们主要探讨下面对用户的输入，有一些危险的函数在未经验证的情况下是不能直接使用这些函数来进行操作的，比如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">include($g);</code></pre></div><p>假设这个 $g 是用户提交的内容，我们在未经验证的情况下直接使用这个参数来包含文件，我们传递的参数为 ?g=/etc/passwd ，那么服务器上所有的用户帐号信息就很可能就直接泄露了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另外，一些执行 shell 命令的函数还是极度危险的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">echo system($g);</code></pre></div><p>当我们传递的参数是 ?g=ls -la / 时，同样的服务器目录也展示了出来，这还仅仅是显示目录结构，如果使用其它更恐怖的命令后果将不堪设想。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>同理，我们经常会根据一些id或指定的文件名来操作文件，特别是在删除文件的时候，如果未加判断，那么也可能直接去删除某些非常重要的文件。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">unlink(\'./\' . $g);</code></pre></div><p>我们继续将 $g 构造为 ?g=../../../xxxx ，如果在权限允许的情况下，就可以删除各种系统文件。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>对这些内容，其实在 PHP 的官方手册中就已经给出了一些很好的建议，我们不妨来直接看看 PHP 手册中是如何说的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>很多 PHP 程序所存在的重大弱点并不是 PHP 语言本身的问题，而是编程者的安全意识不高而导致的。因此，必须时时注意每一段代码可能存在的问题，去发现非正确数据提交时可能造成的影响。</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>必须时常留意你的代码，以确保每一个从客户端提交的变量都经过适当的检查，然后问自己以下一些问题：</em></p><ul><li><p><em>此脚本是否只能影响所预期的文件？</em></p></li><li><p><em>非正常的数据被提交后能否产生作用？</em></p></li><li><p><em>此脚本能用于计划外的用途吗？</em></p></li><li><p><em>此脚本能否和其它脚本结合起来做坏事？</em></p></li><li><p><em>是否所有的事务都被充分记录了？</em></p></li></ul><p><em>还可以考虑关闭 register_globals，magic_quotes 或者其它使编程更方便但会使某个变量的合法性，来源和其值被搞乱的设置。在开发时，可以使用 error_reporting(E_ALL) 模式帮助检查变量使用前是否有被检查或被初始化，这样就可以防止某些非正常的数据的挠乱了。</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>其实，只要能遵守这些建议，大部分的安全问题都能得到解决。还是那句话，不能相信用户的任何输出，在测试的时候请做好各种验证，包括但不限于边界值、特殊符号、特殊命令、越界值、目录权限等。在非必要的情况下不要使用用户的输入作为包含文件、执行脚本及文件操作的直接参数，如果一定要用的话千万要进行各种形式的过滤验证。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p>[https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/PHP%E6%93%8D%E4%BD%9C%E7%94%A8%E6%88%B7%E6%8F%90%E4%BA%A4%E5%86%85%E5%AE%B9%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0.php]https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/PHP%E6%93%8D%E4%BD%9C%E7%94%A8%E6%88%B7%E6%8F%90%E4%BA%A4%E5%86%85%E5%AE%B9%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0.php()</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/security.variables.php\">https://www.php.net/manual/zh/security.variables.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-03-28 01:15:27', 1);
INSERT INTO `zy_articles_xs_test` VALUES (72, 'PHP的HTTP验证', '<h1>PHP的HTTP验证</h1><p>在日常开发中，我们进行用户登录的时候，大部分情况下都会使用 session 来保存用户登录信息，并以此为依据判断用户是否已登录。但其实 HTTP 也提供了这种登录验证机制，我们今天就来学习关于 HTTP 验证相关的知识。</p><h2>HTTP Basic</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">if (!isset($_SERVER[\'PHP_AUTH_USER\'])) {\n    header(\'WWW-Authenticate: Basic realm=\"My Realm\"\');\n    header(\'HTTP/1.0 401 Unauthorized\');\n    echo \'Text to send if user hits Cancel button\';\n    exit;\n} else {\n    echo \"&lt;p&gt;Hello {$_SERVER[\'PHP_AUTH_USER\']}.&lt;/p&gt;\";\n    echo \"&lt;p&gt;You entered {$_SERVER[\'PHP_AUTH_PW\']} as your password.&lt;/p&gt;\";\n}\n// Authorization: Basic YWFhOmFhYQ==\necho base64_decode(\'YWFhOmFhYQ==\');\n// aaa:aaa 等于明文</code></pre></div><p>还是直接就从代码入手，上面的代码就是最简单的一种 HTTP 认证方式，如果 $_SERVER[\'PHP_AUTH_USER\'] 不存在，那么我们就向浏览器发送一个 401 响应头，就是告诉浏览器我们需要登录验证。当浏览器收到这个响应头时，就会弹出一个浏览器自带的验证框并要求输入用户名和密码。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>当我们填写了用户名和密码后，浏览器会在请求头中带上 Authorization 字段，并且将 base64 之后的用户名和密码发送过来。同时，PHP将会分别把用户名和密码解析到 \\$_SERVER[\'PHP_AUTH_USER\'] 和 $_SERVER[\'PHP_AUTH_PW\'] 中。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>上述这种认证方式就是最简单的 HTTP Basic 认证，可以看出，这种方式进行验证的用户名和密码其实是相当于明文传输的，因为 base64 很容易就可以反向解析出来。所以这种方式是非常不安全的。那么有没有更复杂一些的方式呢？</p><h2>HTTP Digest</h2><p>既然这么写了，那肯定是有更好的方式啦，那就是 HTTP Digest 方式的 HTTP 认证。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$realm = \'Restricted area\';\n\n//user =&gt; password\n$users = array(\'admin\' =&gt; \'mypass\', \'guest\' =&gt; \'guest\');\n\n// 指定 Digest 验证方式\nif (empty($_SERVER[\'PHP_AUTH_DIGEST\']) || !$_COOKIE[\'login\']) {\n    setcookie(\'login\', 1);  // 退出登录条件判断\n    header(\'HTTP/1.1 401 Unauthorized\');\n    header(\'WWW-Authenticate: Digest realm=\"\' . $realm .\n        \'\",qop=\"auth\",nonce=\"\' . uniqid() . \'\",opaque=\"\' . md5($realm) . \'\"\');\n    \n    // 如果用户不输入密码点了取消\n    die(\'您点了取消，无法登录\');\n    \n}\n\n// 验证用户登录信息\nif (!($data = http_digest_parse($_SERVER[\'PHP_AUTH_DIGEST\'])) ||\n    !isset($users[$data[\'username\']])) {\n    die(\'Wrong Credentials!\');\n}\n\n// 验证登录信息\n$A1 = md5($data[\'username\'] . \':\' . $realm . \':\' . $users[$data[\'username\']]);\n$A2 = md5($_SERVER[\'REQUEST_METHOD\'] . \':\' . $data[\'uri\']);\n$valid_response = md5($A1 . \':\' . $data[\'nonce\'] . \':\' . $data[\'nc\'] . \':\' . $data[\'cnonce\'] . \':\' . $data[\'qop\'] . \':\' . $A2);\n// $data[\'response\'] 是浏览器客户端的加密内容\nif ($data[\'response\'] != $valid_response) {\n    die(\'Wrong Credentials!\');\n}\n\n// 用户名密码验证成功\necho \'您的登录用户为: \' . $data[\'username\'];\nsetcookie(\"login\", 2);\n\n// Authorization: Digest username=\"guest\", realm=\"Restricted area\", nonce=\"5e815bcbb4eba\", uri=\"/\", response=\"9286ea8d0fac79d3a95fff3e442d6d79\", opaque=\"cdce8a5c95a1427d74df7acbf41c9ce0\", qop=auth, nc=00000002, cnonce=\"a42e137359673851\"\n// 服务器回复报文中的nonce值，加上username，password, http method, http uri利用MD5（或者服务器指定的其他算法）计算出request-digest，作为repsonse头域的值\n\n\n// 获取登录信息\nfunction http_digest_parse($txt)\n{\n    // echo $txt;\n    // protect against missing data\n    $needed_parts = array(\'nonce\' =&gt; 1, \'nc\' =&gt; 1, \'cnonce\' =&gt; 1, \'qop\' =&gt; 1, \'username\' =&gt; 1, \'uri\' =&gt; 1, \'response\' =&gt; 1);\n    $data = array();\n    $keys = implode(\'|\', array_keys($needed_parts));\n\n    preg_match_all(\'@(\' . $keys . \')=(?:([\\\'\"])([^\\2]+?)\\2|([^\\s,]+))@\', $txt, $matches, PREG_SET_ORDER);\n\n    foreach ($matches as $m) {\n        $data[$m[1]] = $m[3] ? $m[3] : $m[4];\n        unset($needed_parts[$m[1]]);\n    }\n\n    return $needed_parts ? false : $data;\n}\n\nif($_GET[\'logout\']){\n\n    setcookie(\"login\", 0);\n    header(\"Location: /\");\n}\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>从代码量就可以看出这种方式复杂了很多。首先是我们一样需要在未登录的情况下返回 401 响应头，告诉浏览器我们要进行 Digest 认证。这里 header 信息就有不一样的地方了，格式是 Digest ，内容也比 Basic 多了许多，这些多出来的内容都是我们在验证认证内容的时候需要用到的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接着，浏览器一样是会弹出输入用户名和密码的弹窗。然后将加密后的用户名和密码信息提交上来。我们可以看到返回值里有明文的 username ，但是没有明文的密码了。其实密码是通过 username 、 密码 、 nonce 、 nc 、 cnoce 、cop 、$_SERVER[\'REQUEST_METHOD\'] 、 uri 等这些内容进行 md5 加密后生成的，放在了 response 字段中提交了上来。我们也需要按照同样的规则获得加密后的密码进行比对就可以判定用户名和密码正确从而让用户完成正常的登录流程。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在这段代码中，我们加入了一个 cookie ，是为了做退出登录的判断使用的。因为 HTTP 认证这种形式的过期时间是以浏览器为基准的。也就是如果客户端关闭了浏览器，则客户端浏览器内存中保存的用户名和密码才会消失。这种情况下我们只能通过 cookie 来进行退出登录的操作，如果用户退出登录了就改变这个 cookie 的内容并重新发送 401 响应头给浏览要求重新登录。</p><h2>总结</h2><p>HTTP 验证的这种操作一般不会做为我们日常开发中的正常登录功能，大部分情况下，我们会给后台或者一些特殊的管理工具加上一层这种 HTTP 认证来实现双重的认证，也就是为了保障后台的数据安全。比如，我会在我的 phpMyAdmin 上增加一层这个认证。另外，HTTP 认证也可以直接在 Nginx 或 Apache 中直接配置，不需要走到 PHP 这一层来，这个我们将来学习 Nginx 的时候会再做说明。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/PHP%E7%9A%84HTTP%E9%AA%8C%E8%AF%81.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/PHP%E7%9A%84HTTP%E9%AA%8C%E8%AF%81.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/features.http-auth.php\">https://www.php.net/manual/zh/features.http-auth.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-06-20 12:04:02', 1);
INSERT INTO `zy_articles_xs_test` VALUES (73, 'PHP获取目录中的全部内容RecursiveDirectoryIterator', '<h1>PHP获取目录中的全部内容RecursiveDirectoryIterator</h1><p>这次我们来介绍一个SPL库中的目录迭代器，它的作用其实非常简单，从名字就可以看出来，就是获取指定目录下的所有内容。之前我们要遍历目录获取目录及目录下的所有文件一般是需要进行递归遍历的，自己写这个代码说实话还是挺麻烦的，所以PHP为我们准备好了这一套内置API，当输入指定的目录后，直接返回该目录下所有子目录及文件内容。当然，并不是树型的，顺序并不一定，想要组织成树型还需要我们自己再进行处理。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>话不多说，直接看代码：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$path = $argv[1];\n\n// 获取目录下所有内容\n$dirs = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($path), RecursiveIteratorIterator::SELF_FIRST);\n\nforeach($dirs as $k=&gt;$d){\n    echo \'key:\'. $k, PHP_EOL;\n    if($d-&gt;isDir()){\n        echo $d-&gt;getPathname(), PHP_EOL;\n    }else{\n        echo $d-&gt;getFilename(), PHP_EOL;\n    }\n}\n\n//执行 php PHP获取目录中的全部内容RecursiveDirectoryIterator.php ../\n\n// key:../.\n// ../.\n// key:../..\n// ../..\n// key:../source\n// ../source\n// key:../source/.\n// ../source/.\n// key:../source/..\n// ../source/..\n// key:../source/PHP获取目录中的全部内容RecursiveDirectoryIterator.php\n// PHP获取目录中的全部内容RecursiveDirectoryIterator.php\n// key:../source/PHP大文件读取操作.php\n// PHP大文件读取操作.php\n// key:../PHP大文件读取操作.md\n// PHP大文件读取操作.md\n// key:../PHP获取目录中的全部内容RecursiveDirectoryIterator.md\n// PHP获取目录中的全部内容RecursiveDirectoryIterator.md\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>其实就一行代码，然后直接循环输出这个迭代器。从结果中我们可以看出，先进入 source 目录遍历完成后再遍历外部的文件内容，按照目录、文件名的顺序依次获取了目录下的所有内容。是不是比我们自己写递归函数要方便很多。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>如果我们想获取目录下的所有PHP文件，并且计算他们的文件总大小呢？使用这一套迭代器操作也可以非常简单的完成，我们只需要增加一个正则迭代器对前面的迭代器内容进行一下过滤就好了：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 获取所有php文件\n$regIts = new RegexIterator($dirs, \'/^.+\\.php$/i\');\n$fileSize = 0;\nforeach($regIts as $k=&gt;$p){\n    echo $p-&gt;getSize() . \' \' .  $k, PHP_EOL;\n    $fileSize += $p-&gt;getSize();\n}\necho \'Total \', $fileSize, PHP_EOL;\n\n// 622 ../source/PHP获取目录中的全部内容RecursiveDirectoryIterator.php\n// 869 ../source/PHP大文件读取操作.php\n// Total 1491</code></pre></div><p>感觉就和 ls -l 一样，可以方便的让我们能够进行目录下的相关操作。这个类的使用就简单的介绍到这里，关于SPL库中还有许多值得我们探索的能力，慢慢学习慢慢实践，不断提升我们面向优雅编程的能力。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/PHP%E8%8E%B7%E5%8F%96%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E5%85%A8%E9%83%A8%E5%86%85%E5%AE%B9RecursiveDirectoryIterator.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/PHP%E8%8E%B7%E5%8F%96%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E5%85%A8%E9%83%A8%E5%86%85%E5%AE%B9RecursiveDirectoryIterator.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p>《PHP7编程实战》</p><p><a href=\"https://www.php.net/manual/en/class.recursivedirectoryiterator.php\">https://www.php.net/manual/en/class.recursivedirectoryiterator.php</a></p><p><a href=\"https://www.php.net/manual/en/class.splfileinfo.php\">https://www.php.net/manual/en/class.splfileinfo.php</a></p>', 'PHP', 'PHP基础,文件操作,PHP SPL', '2022-07-23 18:06:29', '2021-01-19 15:40:47', 1);
INSERT INTO `zy_articles_xs_test` VALUES (74, '不使用正则进行英文数字等相关字符的规则校验', '<h1>不使用正则进行英文数字等相关字符的规则校验</h1><p>在一些场景中，比如说注册登录的时候，我们会对用户名做一些限制，比如只能是数字和字母的组合。一般情况下，我们会使用正则表达式来完成这样的功能，不过，PHP其实已经帮我们准备发了几个函数来处理这样的情况。</p><h2>ctype_ 相关函数</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 数字和字母，不包含浮点数， [A-Za-z0-9]\nif(ctype_alnum($input)){\n    echo $input, \'是英文数字的组合字符！\', PHP_EOL;\n}\n\n// 英文字母， [A-Za-z]\nif(ctype_alpha($input)){\n    echo $input, \'是英文字母！\', PHP_EOL;\n}\n\n// 数字字符，不包含浮点数、负数（无符号正整数）\nif(ctype_digit($input)){\n    echo $input, \'是数字字符！\', PHP_EOL;\n}</code></pre></div><p>上面三个函数分别分就的就是数字+字母、纯字母、纯数字的三种字符类型的判断。没错，关于这种判断我们使用的正是 ctype_ 开头的这些函数。在这其中，唯一需要注意的是 ctype_digit() 进行数字判断时，返回 true 的情况只能是无符号、无小数点的正整数，也就是说负数和小数也是无法通过这个函数的判断的。我们在文章的最后还会看一下 ctype_digit() 和 is_numeric() 有什么区别。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>当然，ctype_ 相关的函数不止这三个，还有很多，我们再来看一组。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 小写字母\nif(ctype_lower($input)){\n    echo $input, \'是小写字母字符！\', PHP_EOL;\n}\n\n// 大写字母\nif(ctype_upper($input)){\n    echo $input, \'是大写字母字符！\', PHP_EOL;\n}\n\n// 所有可打印字符\nif(ctype_print($input)){\n    echo $input, \'是可打印字符！\', PHP_EOL;\n}\n\n// 所有字符都是可见的，除了空格或者格式控制这些不可见的\nif(ctype_graph($input)){\n    echo $input, \'是可打印字符，除空白字符！\', PHP_EOL;\n}\n\n// 不包含空白、字母、数字的可打印字符 英文标点符号类\nif(ctype_punct($input)){\n    echo $input, \'是不包含空白、字母、数字的可打印字符！\', PHP_EOL;\n}</code></pre></div><p>ctype_lower() 和 ctype_upper() 是判断字符串中的内容是否全都为小写或大写。记住，满足条件的情况是字符串中所有的内容都必须为大写或小写，有一个字母不是的话那就无法返回 true 。当然，这两个判断里面也都必须是英文字母，不能有数字、空格之类的内容。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>ctype_print() 是判断是否是可打印内容。什么是可打印内容呢？就是 echo 、 print 之类的能够输出并且你能在屏幕上看到的内容。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>ctype_graph() 是除了空白字符之外的可打印字符。什么叫空白字符呢？\\n、\\t这一类的制表符号，还有我们正常的空格都是空白字符。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>ctype_punct() 可以简单的理解为就是标点符号，整个字符串都是标点符号组成的，并且不包含空白内容。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// \\n \\t \\r 之类\nif(ctype_cntrl($input)){\n    echo $input, \'是格式控制字符！\', PHP_EOL;\n}\n\n// 空格\nif(ctype_space($input)){\n    echo $input, \'是空格字符！\', PHP_EOL;\n}\n\n// 16进制 AB10BC99\nif(ctype_xdigit($input)){\n    echo $input, \'是十六进制字符！\', PHP_EOL;\n}</code></pre></div><p>貌似制表符不是很受欢迎呀，不用怕，ctype_cntrl() 就是专门判断整个字符是不是由这些制表符组成的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>ctype_space() 从名字就可以看出，是不是由空格组成的字符串。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>ctype_xdigit() 是我们最后一个 ctype_ 函数，从名字其实也能够看出来，它是判断是否是16进制字符串的。</p><h2>ctype_digit() 与 is_numeric() 的区别</h2><p>这两个函数都是判断参数是否为数字的，但是它们有一个很大的区别就是 ctype_digit() 仅针对字符串。也就是说它是用来判断字符串中的内容是否是数字的，如果直接给它一个普通的数字类型，那么它还是会返回 false 的，它会认为这个数字类型的内容不是一个“字符串”类型的数字。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// ctype_digit 与 is_numeric 的区别\n$numeric_string = \'42\';\n$integer        = 42;\n\necho ctype_digit($numeric_string), PHP_EOL;  // true\necho ctype_digit($integer), PHP_EOL;         // false (ASCII 42 is the * character)\n\necho is_numeric($numeric_string), PHP_EOL;   // true\necho is_numeric($integer), PHP_EOL;          // true</code></pre></div><h2>总结</h2><p>是不是一组很方便的函数。不过其实现在使用正则也很方便，而且正则的组合形式更加多样，我们的可控制范围更大，所以正则还是在这种情况下的首选。当然，越灵活也越有可能出错，正则中如果漏写一点内容又没有详尽的测试的话，也有可能造成严重的后果。因此，在日常工作中，具体的取舍还是要看我们自身，这里也只是为大家作个科普介绍，使用何种方式的决定权还是掌握在我们自己手上。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另外需要说明的是，这一组 ctype_ 函数，是不支持中文的，它们仅支持英文、数字、英文符号这一类的判断。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%BF%9B%E8%A1%8C%E8%8B%B1%E6%96%87%E6%95%B0%E5%AD%97%E7%AD%89%E7%9B%B8%E5%85%B3%E5%AD%97%E7%AC%A6%E7%9A%84%E8%A7%84%E5%88%99%E6%A0%A1%E9%AA%8C.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%BF%9B%E8%A1%8C%E8%8B%B1%E6%96%87%E6%95%B0%E5%AD%97%E7%AD%89%E7%9B%B8%E5%85%B3%E5%AD%97%E7%AC%A6%E7%9A%84%E8%A7%84%E5%88%99%E6%A0%A1%E9%AA%8C.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/ref.ctype.php\">https://www.php.net/manual/zh/ref.ctype.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-09-13 11:53:06', 1);
INSERT INTO `zy_articles_xs_test` VALUES (75, '什么叫给密码“加盐”？如何安全的为你的用户密码“加盐”？', '<h1>什么叫给密码“加盐”？如何安全的为你的用户密码“加盐”？</h1><p>在面对这个网络世界的时候，密码安全总是各个公司和用户都非常关心的一个内容，毕竟现在大家不管是休闲娱乐还是学习购物都是通过网上的帐号来进行消费的，所以我们通常会给用户的密码进行加密。在加密的时候，经常会听到“加盐”这个词，这是什么意思呢？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们通常会将用户的密码进行 Hash 加密，如果不加盐，即使是两层的 md5 都有可能通过彩虹表的方式进行破译。彩虹表就是在网上搜集的各种字符组合的 Hash 加密结果。而加盐，就是人为的通过一组随机字符与用户原密码的组合形成一个新的字符，从而增加破译的难度。就像做饭一样，加点盐味道会更好。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来，我们通过代码来演示一种比较安全的加盐方式。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>首先，我们建一个简单的用户表。这个表里只有四个字段，在这里仅作为测试使用。</p><div data-language=\"sql\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"sql\">CREATE TABLE `zyblog_test_user` (\n    `id` int(11) NOT NULL AUTO_INCREMENT,\n    `username` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL COMMENT \'用户名\',\n    `password` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL COMMENT \'密码\',\n    `salt` char(4) COLLATE utf8mb4_bin DEFAULT NULL COMMENT \'盐\',\n    PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;</code></pre></div><p>然后定义两个方式，一个用来生成盐，一个用来生成加盐后的 Hash 密码。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">/**\n * 随机生成四位字符串的salt\n * 也可以根据实际情况使用6位或更长的salt\n */\nfunction generateSalt()\n{\n    // 使用随机方式生成一个四位字符\n    $chars = array_merge(range(\'A\', \'Z\'), range(\'a\', \'z\'), range(\'0\', \'9\'));\n    for ($i = 0; $i &lt; 4; $i++) {\n        $str .= $chars[mt_rand(0, count($chars) - 1)];\n    }\n    return $str;\n}\n\n/**\n * 密码生成\n * 使用两层hash，将salt加在第二层\n * sha1后再加salt然后再md5\n */\nfunction generateHashPassword($password, $salt)\n{\n    return md5(sha1($password) . $salt);\n}</code></pre></div><p>generateSalt() 方法很简单，就是生成一个随机的四位字符的字符串，我们使用大小写加数字的形式生成这个字符串。这就是传说中的“盐”。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来我们就可以使用 generateHashPassword() 方法为用户的原密码加盐。在这里我们第一层先使用 sha1() 对原密码进行一次 Hash ，然后使用这个 Hash 值拼接盐字符串后再进行 md5() 加密。最后加密出来的 Hash 值就很难在彩虹表中找到了。即使找到，也只是上层 sha1() 拼接盐字符串的内容，用户的原文密码毕竟还有一层加密。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>剩下的就是我们进行出入库的注册登录测试了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$pdo = new PDO(\'mysql:host=localhost;dbname=blog_test;charset=utf8mb4\', \'root\', \'\');\n\n$username = \'ZyBlog1\';\n$password = \'123456\';\n\n// 注册\nfunction register($username, $password)\n{\n    global $pdo;\n\n    // 首先判断用户是否已注册\n    $pre = $pdo-&gt;prepare(\"SELECT COUNT(id) FROM zyblog_test_user WHERE username = :username\");\n    $pre-&gt;bindParam(\':username\', $username);\n    $pre-&gt;execute();\n    $result = $pre-&gt;fetchColumn();\n\n    // 如果用户名存在，则无法注册\n    if ($result &gt; 0) {\n        echo \'用户名已注册！\', PHP_EOL;\n        return 0;\n    }\n\n    // 生成salt\n    $salt = generateSalt();\n    // 密码进行加盐hash处理\n    $password = generateHashPassword($password, $salt);\n\n    // 插入新用户\n    $pre = $pdo-&gt;prepare(\"insert into zyblog_test_user(username, password, salt) values(?, ?, ?)\");\n\n    $pre-&gt;bindValue(1, $username);\n    $pre-&gt;bindValue(2, $password);\n    $pre-&gt;bindValue(3, $salt);\n\n    $pre-&gt;execute();\n\n    return $pdo-&gt;lastInsertId();\n}\n\n$userId = register($username, $password);\nif ($userId &gt; 0) {\n    echo \'注册成功！用户ID为：\' . $userId, PHP_EOL;\n}\n\n// 注册成功！用户ID为：1\n\n// 查询数据库中的数据\n$sth = $pdo-&gt;prepare(\"SELECT * FROM zyblog_test_user\");\n$sth-&gt;execute();\n\n$result = $sth-&gt;fetchAll(PDO::FETCH_ASSOC);\nprint_r($result);\n\n// Array\n// (\n//     [0] =&gt; Array\n//         (\n//             [id] =&gt; 1\n//             [username] =&gt; ZyBlog1\n//             [password] =&gt; bbff8283d0f90625015256b742b0e694\n//             [salt] =&gt; xOkb\n//         )\n\n// )\n\n// 登录时验证\nfunction login($username, $password)\n{\n    global $pdo;\n    // 先根据用户名查表\n    $pre = $pdo-&gt;prepare(\"SELECT * FROM zyblog_test_user WHERE username = :username\");\n    $pre-&gt;bindParam(\':username\', $username);\n    $pre-&gt;execute();\n    $result = $pre-&gt;fetch(PDO::FETCH_ASSOC);\n\n    // 用户名存在并获得用户信息后\n    if ($result) {\n        // 根据用户表中的salt字段生成hash密码\n        $password = generateHashPassword($password, $result[\'salt\']);\n\n        // 比对hash密码确认登录是否成功\n        if ($password == $result[\'password\']) {\n            return true;\n        }\n    }\n    return false;\n}\n\n$isLogin = login($username, $password);\nif ($isLogin) {\n    echo \'登录成功！\', PHP_EOL;\n} else {\n    echo \'登录失败，用户名或密码错误！\', PHP_EOL;\n}\n\n// 登录成功！</code></pre></div><p>代码还是比较简单的，在注册的时候，我们直接对用户密码进行加密后入库。主要关注的地方是在登录时，我们先根据用户名查找出对应的用户信息。然后将用户登录提交上来的原文密码进行加密，与数据库中的原文密码进行对比验证，密码验证成功即可判断用户登录成功。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另外还需要注意的是，我们的盐字符串也是要存到数据库中的。毕竟在登录的时候我们还是需要将用户的原文密码与这个盐字符串进行组合加密之后才能进行密码的匹配。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这样加密后的代码其实想通过彩虹表来破解基本上是很难了。在几年前 CSDN 的帐号泄露事件中，大家发现作为中文程序员世界最大的网站竟然是明文存储的密码，这就为攻击者提供了一大堆用户的明文常用密码。因为大家都喜欢用同一个用户名和密码注册不同的网站，所以不管其他怎么加盐都是没用的，毕竟原文密码是对的，拿到这样一个网站的数据库中的用户明文密码后，就可以通过这些密码去尝试这些用户在其他网站是不是用了相同的帐号名和密码注册了帐号。所以在日常生活中，我们重要的一些网站帐号、密码尽量还是使用不同的内容，如果记不住的话，可以使用一些带加密能力的记事本软件进行保存，这样会更加安全。而我们程序员，则应该始终都将用户的密码及重要信息进行加密处理，这是一种基本的职业规范。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E4%BB%80%E4%B9%88%E5%8F%AB%E7%BB%99%E5%AF%86%E7%A0%81%E2%80%9C%E5%8A%A0%E7%9B%90%E2%80%9D%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BA%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E2%80%9C%E5%8A%A0%E7%9B%90%E2%80%9D%EF%BC%9F.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E4%BB%80%E4%B9%88%E5%8F%AB%E7%BB%99%E5%AF%86%E7%A0%81%E2%80%9C%E5%8A%A0%E7%9B%90%E2%80%9D%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%BA%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E2%80%9C%E5%8A%A0%E7%9B%90%E2%80%9D%EF%BC%9F.php</a></p>', 'PHP', 'PHP基础,加解密', '2022-07-23 18:06:29', '2022-08-17 19:34:10', 1);
INSERT INTO `zy_articles_xs_test` VALUES (76, '使用Serializable接口来自定义PHP中类的序列化', '<h1>使用Serializable接口来自定义PHP中类的序列化</h1><p>关于PHP中的对象序列化这件事儿，之前我们在很早前的文章中已经提到过 __sleep() 和 __weakup() 这两个魔术方法。今天我们介绍的则是另外一个可以控制序列化内容的方式，那就是使用 Serializable 接口。它的使用和上述两个魔术方法很类似，但又稍有不同。</p><h2>Serializable接口</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class A implements Serializable {\n    private $data;\n    public function __construct(){\n        echo \'__construct\', PHP_EOL;\n        $this-&gt;data = \"This is Class A\";\n    }\n\n    public function serialize(){\n        echo \'serialize\', PHP_EOL;\n        return serialize($this-&gt;data);\n    }\n\n    public function unserialize($data){\n        echo \'unserialize\', PHP_EOL;\n        $this-&gt;data = unserialize($data);\n    }\n\n    public function __destruct(){\n        echo \'__destruct\', PHP_EOL;\n    }\n\n    public function __weakup(){\n        echo \'__weakup\', PHP_EOL;\n    }\n\n    public function __sleep(){\n        echo \'__destruct\', PHP_EOL;\n    }\n    \n}\n\n$a = new A();\n$aSerialize = serialize($a);\n\nvar_dump($aSerialize);\n// \"C:1:\"A\":23:{s:15:\"This is Class A\";}\"\n$a1 = unserialize($aSerialize);\nvar_dump($a1);</code></pre></div><p>这段代码就是使用 Serializable 接口来进行序列化处理的，注意一点哦，实现了 Serializable 接口的类中的 __sleep() 和 __weakup() 魔术方法就无效了哦，序列化的时候不会进入它们。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>Serializable 这个接口需要实现的是两个方法，serialize() 方法和 unserialize() 方法，是不是和那两个魔术方法完全一样。当然，使用的方式也是一样的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在这里，我们多普及一点序列化的知识。对象序列化只能序列化它们的属性，不能序列化他们方法。如果当前能够找到对应的类模板，那么可以还原出这个类的方法来，如果没有定义过这个类的模板，那么还原出来的类是没有方法只有属性的。我们通过这段代码中的序列化字符串来分析：</p><ul><li><p>\"C:\"，指的是当前数据的类型，这个我面后面还会讲，实现 Serializable 接口的对象序列化的结果是 C: ，而没有实现这个接口的对象序列化的结果是 O:</p></li><li><p>\"A:\"，很明显对应的是类名，也就是类的::class</p></li><li><p>\"{xxx}\"，对象结构和JSON一样，也是用的花括号</p></li></ul><h2>各种类型的数据进行序列化的结果</h2><p>下面我们再来看下不同类型序列化的结果。要知道，在PHP中，我们除了句柄类型的数据外，其他标量类型或者是数组、对象都是可以序列化的，它们在序列化字符串中是如何表示的呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$int = 110;\n$string = \'110\';\n$bool = FALSE;\n$null = NULL;\n$array = [1,2,3];\n\nvar_dump(serialize($int)); // \"i:110;\"\nvar_dump(serialize($string)); // \"s:3:\"110\";\"\nvar_dump(serialize($bool)); // \"b:0;\"\nvar_dump(serialize($null)); // \"N;\"\nvar_dump(serialize($array)); // \"a:3:{i:0;i:1;i:1;i:2;i:2;i:3;}\"</code></pre></div><p>上面的内容还是比较好理解的吧。不过我们还是一一说明一下：</p><ul><li><p>数字类型：i:&lt;值&gt;</p></li><li><p>字符串类型：s:&lt;长度&gt;:&lt;值&gt;</p></li><li><p>布尔类型：b:&lt;值:0或1&gt;</p></li><li><p>NULL类型：N;</p></li><li><p>数组：a:&lt;长度&gt;:&lt;内容&gt;</p></li></ul><h2>对象在使用Serializable接口序列化时要注意的地方</h2><p>接下来，我们重点讲讲对象类型，上面已经提到过，实现 Serializable 接口的对象序列化后的标识是有特殊情况的。上方序列化后的字符串开头类型标识为 \"C:\"，那么我们看看不实现 Serializable 接口的对象序列化后是什么情况。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 正常对象类型序列化的结果\nclass B {\n    private $data = \"This is Class B\";\n\n}\n$b = new B();\n$bSerialize = serialize($b);\n\nvar_dump ($bSerialize); // \"O:1:\"B\":1:{s:7:\"Bdata\";s:15:\"This is Class B\";}\"\nvar_dump($bSerialize);\nvar_dump(unserialize(\"O:1:\\\"B\\\":1:{s:7:\\\"\\0B\\0data\\\";s:15:\\\"This is Class B\\\";}\"));\n\n// object(B)#4 (1) {\n//     [\"data\":\"B\":private]=&gt;string(15) \"This is Class B\"\n// }</code></pre></div><p>果然，它开头的类型标识是 \"O:\"。那么我们可以看出，\"C:\" 很大的概率指的是当前序列化的内容是一个类类型，不是一个对象类型。它们之间其实并没有显著的差异，包括官方文档上也没有找到特别具体的说明。如果有过这方面的研究或者有相关资料的同学可以评论留言一起讨论哈。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>此外，如果我们手动将一个对象的 \"O:\" 转成 \"C:\" 会怎么样呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 把O:替换成C:\nvar_dump(unserialize(str_replace(\'O:\', \'C:\', $bSerialize))); // false</code></pre></div><p>抱歉，无法还原了。那么我们反过来，将上面 A 类也就是实现了 Serializable 接口的序列化字符串中的 \"C:\" 转成 \"O:\" 呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// Warning: Erroneous data format for unserializing \'A\'\nvar_dump(unserialize(str_replace(\'C:\', \'O:\', $aSerialize))); // false</code></pre></div><p>嗯，会提示一个警告，然后同样也无法还原了。这样看来，我们的反序列化还是非常智能的，有一点点的不同都无法进行还原操作。</p><h2>未定义类的反序列化操作</h2><p>最后，我们来看看未定义类的情况下，直接反序列化一个对象。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 模拟一个未定义的D类\nvar_dump(unserialize(\"O:1:\\\"D\\\":2:{s:7:\\\"\\0D\\0data\\\";s:15:\\\"This is Class D\\\";s:3:\\\"int\\\";i:220;}\"));\n\n// object(__PHP_Incomplete_Class)#4 (3) {\n//     [\"__PHP_Incomplete_Class_Name\"]=&gt;string(1) \"D\"\n//     [\"data\":\"D\":private]=&gt;string(15) \"This is Class D\"\n//     [\"int\"]=&gt;int(220)\n// }\n\n// 把未定义类的O:替换成C:\nvar_dump(unserialize(str_replace(\'O:\', \'C:\', \"O:1:\\\"D\\\":2:{s:7:\\\"\\0D\\0data\\\";s:15:\\\"This is Class D\\\";s:3:\\\"int\\\";i:220;}\"))); // false</code></pre></div><p>从代码中，我们可以看出，\"C:\" 类型的字符串依然无法反序列化成功。划重点哦，<em>如果是C:开头的序列化字符串，一定需要是定义过的且实现了 Serializable 接口的类</em> 才能反序列化成功。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另外，我们可以发现，当序列化字符串中的模板不存在时，反序列化出来的类的类名是 __PHP_Incomplete_Class_Name 类，不像有类模板的反序列化成功直接就是正常的类名。</p><h2>总结</h2><p>其实从以上各种来看，个人感觉如果要保存数据或者传递数据的话，序列化并不是最好的选择。毕竟包含了类型以及长度后将使得格式更为严格，而且反序列化回来的内容如果没有对应的类模板定义也并不是特别好用的，还不如直接使用 JSON 来得方便易读。当然，具体情况具体分析，我们还是要结合场景来选择合适的使用方式。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E4%BD%BF%E7%94%A8Serializable%E6%8E%A5%E5%8F%A3%E6%9D%A5%E8%87%AA%E5%AE%9A%E4%B9%89PHP%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E4%BD%BF%E7%94%A8Serializable%E6%8E%A5%E5%8F%A3%E6%9D%A5%E8%87%AA%E5%AE%9A%E4%B9%89PHP%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/class.serializable.php\">https://www.php.net/manual/zh/class.serializable.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-03-13 03:42:14', 1);
INSERT INTO `zy_articles_xs_test` VALUES (77, '关于PHP中的请求上下文的相关知识', '<h1>关于PHP中的请求上下文的相关知识</h1><p>我们首先来了解下什么是上下文。在我们写文章，写句子时，都会考虑一个观点或者内容的前后逻辑，转承启合，而在这个观点前后的内容就可以看成是它的上下文内容。它包含了语境的意味在里面，其实代码世界中的上下文也是一样的意思，本身 Context 这个单词就是环境、背景的意思。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来，我们来说说请求上下文又是什么呢？比如说我们要使用PHP来请求一个链接地址，通常我们会使用 curl 来进行请求，但是 curl 的配置其实是比较复杂的，所以我们在简单使用的情况下会使用 file_get_contents() 这种函数来快捷地请求链接。不过，可能很多人并不知道或者说没怎么使用过它的上下文参数。其实，使用了上下文参数之后，file_get_contents() 不仅可以提交 POST 请求，还可以定义各种请求头内容。这些东西，就是一个请求的上下文，也就是它的执行环境和背景。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>首先，我们定义一个服务端，在这里只是输出 \\$_GET 和 $_POST 里面的内容。同时，我们还打印了 $_SERVER 来看看请求头是否获取到了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">print_r($_SERVER);\n\necho \'GET INFO\', PHP_EOL;\nforeach ($_GET as $k =&gt; $v) {\n    echo $k, \': \', $v, PHP_EOL;\n}\n\necho PHP_EOL,PHP_EOL;\necho \'POST INFO\', PHP_EOL;\nforeach ($_POST as $k =&gt; $v) {\n    echo $k, \': \', $v, PHP_EOL;\n}</code></pre></div><p>接下来，在我们的测试代码中，使用 file_get_contents() 来进行 POST 提交。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$postdata = http_build_query(\n    [\n        \'var1\' =&gt; \'some content\',\n        \'var2\' =&gt; \'doh\',\n    ]\n);\n\n$opts = [\n    \'http\' =&gt; [\n        \'method\' =&gt; \'POST\',\n        \'header\' =&gt; \'Content-type: application/x-www-form-urlencoded\',\n        \'content\' =&gt; $postdata,\n    ],\n];\n\n$context = stream_context_create($opts);\n$result = file_get_contents(\'http://localhost:8088/?a=1\', false, $context);\nprint_r($result);\nvar_dump($http_response_header);</code></pre></div><p>在这里，我们只是用到了 stream_context_create() ，就能够轻松地创建一个请求的上下文环境了。stream_context_create() 是创建上下文环境的函数，它接收的参数是一个选项数组，里面用于定义当前请求的相关选项。注意，我们这里其实定义的是 http/https 相关的选项，它还可以定义 ftp 、 socket 等相关的请求协议选项。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在使用 file_get_contents() 函数请求远程地址后，我们可以在 $http_response_header 变量内获取到请求返回的响应头信息。而且这个变量是会定义在当前的局部作用域下，不用担心全局作用域污染的问题。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>非常简单的方式就可以实现 POST 请求了吧，另外我们还可以使用 fopen() 函数来实现类似的效果，不过获取 body 和响应应信息时的方式就不同了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$url = \"http://localhost:8088/?a=1\";\n\n$opts = [\n    \'http\' =&gt; [\n        \'method\' =&gt; \'GET\',\n        \'max_redirects\' =&gt; \'0\',\n        \'ignore_errors\' =&gt; \'1\',\n    ],\n];\n\n$context = stream_context_create($opts);\n$stream = fopen($url, \'r\', false, $context);\n\n// 返回响应头\nvar_dump(stream_get_meta_data($stream));\n\n// 返回内容\nvar_dump(stream_get_contents($stream));\nfclose($stream);</code></pre></div><p>在这段代码中，我们使用 stream_get_meta_data() 函数来获得响应头，使用 stream_get_contents() 来获得响应的内容（body）。这样其实就真的和 curl 的效果差不多了，而且最主要的是，当前这种写法更简单方便。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从上面的代码中我们可以看出，这种上下文相关的函数都是 Stream 类型的函数，也就是流函数。它们是专门用来处理各种数据的，包括但不限于文件中的、网络上的、压缩文件以及其他一些操作的数据。在将来的学习中，我们还会接触到其它的内容。今天的学习，其实是流的网络数据处理中的一小部分内容，大家先消化消化吧！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E5%85%B3%E4%BA%8EPHP%E4%B8%AD%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E5%85%B3%E4%BA%8EPHP%E4%B8%AD%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/context.php\">https://www.php.net/manual/zh/context.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-04-09 12:54:39', 1);
INSERT INTO `zy_articles_xs_test` VALUES (78, '关于PHP流不得不说的那些事', '<h1>关于PHP流不得不说的那些事</h1><p>相信不少PHP开发者或多或少都见过类似于 \"php://input\" 或者 \"php://output\" 这样的内容，很多人都知道这两个的作用一个是接收的 POST 请求中的原始 body 内容，另一个其实和 echo 之类的输出一样是进行输出的。当然，我们的文章内容不会如此的简单，其实类似这样的 php:// 开头的协议还有好几种，它们共同称为 PHPIO流协议（PHP输入/输出流协议） 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这种协议有什么用呢？我们知道计算机中正常的协议有 http:// ，这是我们做web开发最熟悉的。还有 file:// 表示文件，ftp:// 表示ftp协议，当然，还有一些不太常用的 zlib:// 、 data:// 、 rar:// ，等等，这些协议PHP都是支持的，而且这些协议都是约定俗成的并且有相应的文件或流类型支持的协议。通过这些协议我们的程序可以读取、解析这些协议所对应的相关内容。比如说http协议，服务器、客户端浏览器都是因为支持了相同的http协议规范，所以才能够通过这个协议来进行传输，而传输的内容是什么呢？正是我们看到的网页或接口文本。而今天我们的主角 php:// 协议，其实也有另一个别名是 PHP伪协议 。伪协议的原因其实就是这种协议只是PHP自身所支持的并定义的一种协议，而且也仅仅只是 IO 相关操作的一种协议规范。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>好了，废话就说到这里，我们来一个一个的看看 php:// 相关的内容都有哪些。</p><h2>stdin 输入流</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">while ($line = fopen(\'php://stdin\', \'r\')) {\n    $info = fgets($line);\n    echo $info;\n    if ($info == \"exit\\n\") {\n        break;\n    }\n}\n\nwhile ($info = fgets(STDIN)) {\n    echo $info;\n    if ($info == \"exit\\n\") {\n        break;\n    }\n}</code></pre></div><p>上述代码有什么用呢？相信做过 C 或者 Java 开发的人会更有感觉，stdin 是获取PHP进程脚本的输入，也就是我们在使用命令行 php xxx.php 运行PHP脚本文件时，获取命令行输入内容的。上述代码就是使用 while 循环一直监听命令行的输入，当你输入内容后进行打印，如果输入的是 exit 就退出循环也就是结束脚本的运行。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这里除了正常的用 fopen() 获取 php://stdin 句柄外，还使用了另一种方式，也就是第二个循环所展示的 STDIN 常量来方便快捷地直接获取输入内容。这也是PHP所推荐的方式。同时，下面讲的 php://stdout 和 php://stderr ，也有相应的 STDOUT 和 STDERR 常量。</p><h2>stdout 、 stderr 和 output 输出流</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$stdout = fopen(\'php://stdout\', \'w\');\nfputs($stdout, \'fopen:stdout\');\necho PHP_EOL;\nfile_put_contents(\"php://stdout\", \"file_put_contents:stdout\");\necho PHP_EOL;\n\nfile_put_contents(\"php://stderr\", \"file_put_contents:stderr\");\necho PHP_EOL;\n\n$output = fopen(\'php://output\', \'w\');\nfputs($output, \'fopen:output\');\necho PHP_EOL;\nfile_put_contents(\"php://output\", \"file_put_contents:output\");\necho PHP_EOL;</code></pre></div><p>这三种都是输出流，其实就和 echo 、 print 一样，就是将内容打印输出的。不过不同的地方在于，stdin 和 stdout 是针对PHP命令行的输出。也就是说，如果我们是通过浏览器查看这个脚本的话，这两个输出的内容是不会打印到浏览器上的。小伙伴们可以试试用 php -S localhost:8081 &lt;测试文件&gt; 来测试下上述代码，访问 http://localhost:8081 的话，浏览器上会输出 output 打印的内容，而命令行这边则会打印 stdin 和 stdout 所输出的内容。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另外需要注意的，这三个输出流都是只写的，而 stdin 是只读的。也就是说 file_get_contents() 对这三个输出流是没什么用的，而 file_put_contents() 对 stdin 流也是没效果的。</p><h2>input 访问请求的原始数据的只读流</h2><p>这个相信做过接口开发的大多数人都会接触过。当前端或客户端使用 body raw 方式发送数据时，就使用这个协议来接收POST中的原始 body 内容。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">echo file_get_contents(\"php://input\");</code></pre></div><p>非常简单，这里我们直接使用 postman 来模拟这种请求，可以看我们是能够正常接收到 body raw 里面的内容的。见下图：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/20220724/d399cc30c21658c0d2ee107809d8987c.png\" alt=\"//img1.zyblog.com.cn/20220724/d399cc30c21658c0d2ee107809d8987c.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><h2>memory 、 temp 内存及临时文件流</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$mem = fopen(\'php://memory\', \'r+\');\nfor ($i = 0; $i &lt; 10; $i++) {\n    fwrite($mem, \'fopen:memory\');\n}\nrewind($mem);\nwhile ($info = fgets($mem)) {\n    echo $info, PHP_EOL;\n}\nfclose($mem);</code></pre></div><p>这两个流协议是输入、输出都支持的，它们都是在内存中读写数据。不同的是， php://temp 会在数据超过一定容量时将数据写到临时文件中。这里我们就不演示 temp 的操作了，它和 memory 的操作代码是非常像的。另外需要注意的，它们两个操作都是一次性的，也就是说，如果我们在写入(fwrite)后直接关闭(fclose)了句柄，那么后面再读取的话(fgets)，是无法获取到内容的。</p><h2>filter 用于数据打开时的筛选过滤</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">readfile(\"php://filter/read=string.toupper/resource=http://www.baidu.com\");\necho file_get_contents(\"php://filter/read=convert.base64-encode/resource=http://www.baidu.com\");</code></pre></div><p>这个自己试试就知道它的好处了，第一行我们是获取百度页面的内容，并把内容中所有的字母替换成大写字母了。第二个过滤器则是直接将百度首页的内容转成base64编码的内容了，是不是非常强大，我觉得这个功能可以是我们好好开发的一个能力。</p><h2>总结</h2><p>其实说实话，笔者本人平常也就是用过 php://input 这一个协议而已，偶尔或者说基本一年难得用上几次 stdin 来进行脚本调试，但是，这并不妨碍我们了解学习这些流协议的使用。最主要的是，通过学习后我们更进一步的了解了它们的作用及适用的场景，这样就可以在将来需要的时候灵活使用。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E5%85%B3%E4%BA%8EPHP%E6%B5%81%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E5%85%B3%E4%BA%8EPHP%E6%B5%81%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/wrappers.php.php\">https://www.php.net/manual/zh/wrappers.php.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/filters.php\">https://www.php.net/manual/zh/filters.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-07-31 09:37:14', 1);
INSERT INTO `zy_articles_xs_test` VALUES (79, '再次学习方法参数类型声明', '<h1>再次学习方法参数类型声明</h1><p>不管从事什么行业，现在都是活到老学到老的趋势，特别是我们这堆码农。这回也不用说新技术用不上，光光是PHP文档的学习都会发现非常多的知识点其实自己并没有真正的掌握，比如说这个方法参数的类型声明。上次文章中，<a href=\"https://mp.weixin.qq.com/s/bZSNAOB23p4ClTJkBCPleA\">关于PHP的方法参数类型约束</a>，我们说过方法参数的类型约束仅限于类、接口、数组或者callable回调函数，其实这是不严谨的，PHP中也有一个严格模式的定义，如果指定了严格模式的话，普通的为方法参数类型指定普通的标量类型也是有效果的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>严格模式的定义：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">declare (strict_types = 1);</code></pre></div><h2>int 类型</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function testInt(int $a)\n{\n    echo $a, PHP_EOL;\n}\n\ntestInt(1);\n// testInt(1.1); // Fatal error: Uncaught TypeError: Argument 1 passed to testInt() must be of the type int\n// testInt(\'52AABB\'); // Fatal error: Uncaught TypeError: Argument 1 passed to testInt() must be of the type int\n// testInt(true); // Fatal error: Uncaught TypeError: Argument 1 passed to testInt() must be of the type int</code></pre></div><p>在严格模式下，很明显地看出现在这个方法的参数只能接收 int 类型的值了，其他的类型都无法接收，当然也不会像之前文章说过的那样会发生强制转换。</p><h2>float 类型</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function testFloat(float $a)\n{\n    echo $a, PHP_EOL;\n}\n\ntestFloat(1);\ntestFloat(1.1);\n// testFloat(\'52AABB\'); // Fatal error: Uncaught TypeError: Argument 1 passed to testInt() must be of the type int\n// testInt(true); // Fatal error: Uncaught TypeError: Argument 1 passed to testInt() must be of the type int</code></pre></div><p>这里需要注意的是，PHP只有 int 和 float，而且 float 是 int 的超集，所以这里是可以传整数过来的，不过上面的 testInt(int $a) 则不能接收 1.1 这样的 float 值。这就涉及到了上下转换的问题，向超集转换是OK的，但是超集向子集转换是就不OK了。</p><h2>string 类型</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function testString(string $a)\n{\n    echo $a, PHP_EOL;\n}\n\n// testString(1);  // Fatal error: Uncaught TypeError: Argument 1 passed to testString() must be of the type string\n// testString(1.1);  // Fatal error: Uncaught TypeError: Argument 1 passed to testString() must be of the type string\ntestString(\'52AABB\');\n// testString(true); // Fatal error: Uncaught TypeError: Argument 1 passed to testString() must be of the type string</code></pre></div><p>这个就不用过多解释了，在非严格模式下我们如果定义 string 类型的接收参数的话，其实是任何类型都可以接收过来做为 string 类型的，这里的类型转换就不多说了，可以说在非严格模式下定义 string 类型的效果跟没有任何定义是一样的。但是严格模式下就不同了，真的是只能接收双引或者单引号之内的字符串内容。</p><h2>bool 类型</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function testBool(bool $a)\n{\n    var_dump($a);\n}\ntestBool(true);\ntestBool(false);\n// testBool(\'52AABB\'); // Fatal error: Uncaught TypeError: Argument 1 passed to testBool() must be of the type bool\n// testBool(1); // Fatal error: Uncaught TypeError: Argument 1 passed to testBool() must be of the type bool</code></pre></div><p>布尔值也是同理的，这里我们也只能接收 true 和 false 关键字的值。</p><h2>新学习一个 iterable 类型</h2><p>最后来介绍个新家伙，除了普通模式下的类、数组、回调函数，严格模式下的各种标量类型声明外，还有一个 iterable 类型的声明，相信大家通过这个单词也能看出来了，可迭代的类型。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function testIterable(iterable $iterator)\n{\n    echo gettype($iterator), \':\', PHP_EOL;\n    foreach ($iterator as $it) {\n        echo $it, PHP_EOL;\n    }\n}\n\ntestIterable([1, 2, 3]);\ntestIterable(new ArrayIterator([1, 2, 3]));\n// Generator对象\ntestIterable((function () {\n    yield 1;\n    yield 2;\n    yield 3;\n})());\n// testIterable(1); // Fatal error: Uncaught TypeError: Argument 1 passed to testIterable() must be iterable</code></pre></div><p>没错，它包含了数组、实现迭代器接口的类以及生成器相关的内容。也就是所有可用 foreach 迭代的内容都可以传递过来。生成器本身会是一个 Generator 对象，而在<a href=\"https://mp.weixin.qq.com/s/92b626NWJSFjeQ0ad7tY7Q\">学习PHP生成器的使用</a>这篇文章中，我们已经看过这个 Generator 对象的内容，它本身也是实现了 Iterator 接口。</p><h2>总结</h2><p>就像开头说过的，原来在严格模式下我们的语法还会有这么大的差异，这回真的是长见识了。我们的学习之路还很长，也希望各位能够持续关注一起加油！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E5%86%8D%E6%AC%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E5%86%8D%E6%AC%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>《PHP7编程实战》</p><p><a href=\"https://wiki.php.net/rfc/scalar_type_hints_v5\">https://wiki.php.net/rfc/scalar_type_hints_v5</a></p><p><a href=\"https://www.php.net/manual/zh/class.generator.php\">https://www.php.net/manual/zh/class.generator.php</a></p><p><a href=\"https://wiki.php.net/rfc/iterable\">https://wiki.php.net/rfc/iterable</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-01-02 01:32:44', 1);
INSERT INTO `zy_articles_xs_test` VALUES (80, '在PHP中检测一个类是否可以被foreach遍历', '<h1>在PHP中检测一个类是否可以被foreach遍历</h1><p>在PHP中，我们可以非常简单的判断一个变量是什么类型，也可以非常方便的确定一个数组的长度从而决定这个数组是否可以遍历。那么类呢？我们要如何知道这个类是否可以通过 foreach 来进行遍历呢？其实，PHP已经为我们提供了一个现成的接口。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class Obj1\n{\n    public $v = \'V:Obj1\';\n    private $prv = \'prv:Obj1\';\n}\n\n$obj1 = new Obj1();\necho $obj1 instanceof Traversable ? \'yes\' : \'no\', PHP_EOL; // no\n\nclass Obj2 implements IteratorAggregate\n{\n    public $v = \'V:Obj2\';\n    private $prv = \'prv:Obj2\';\n    public function getIterator()\n    {\n        return new ArrayIterator([\n            \'v\' =&gt; $this-&gt;v,\n            \'prv\' =&gt; $this-&gt;prv,\n        ]);\n    }\n}\n\n$obj2 = new Obj2();\necho $obj2 instanceof Traversable ? \'yes\' : \'no\', PHP_EOL; // yes</code></pre></div><p>从上面的例子中可以看出，每一个 \\$obj1 无法通过 Traversable 判断，所以它是不能被遍历的。而第二个 $obj2 则是实现了迭代器接口，这个对象是可以通过 Traversable 判断的。在PHP手册中，Traversable 接口正是用于检测一个类是否可以被 foreach 遍历的接口。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这个接口有几个特点：</p><ol><li><p>实现此接口的内建类可以使用 foreach 进行遍历而无需实现 IteratorAggregate 或 Iterator 接口。</p></li><li><p>这是一个无法在 PHP 脚本中实现的内部引擎接口。IteratorAggregate 或 Iterator 接口可以用来代替它。</p></li></ol><p>也就是说这个接口不需要我们去手工实现，只需要我们的类实现迭代器相关的接口就可以通过这个接口的验证的判断。如果单独去实现这个接口的话，将会报错并提示我们应该去实现 IteratorAggregate 或 Iterator 接口。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// Fatal error: Class ImplTraversable must implement interface Traversable as part of either Iterator or IteratorAggregate in Unknown \nclass ImplTraversable implements Traversable{\n\n}</code></pre></div><p>其实之前的文章中，我们已经验证过，对象是可以被遍历的，而且并不需要实现什么迭代器接口就可以被 foreach 遍历。它会输出 所有 public 的属性。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// foreach\nforeach ($obj1 as $o1) {\n    echo $o1, PHP_EOL;\n}\n\nforeach ($obj2 as $o2) {\n    echo $o2, PHP_EOL;\n}\n\n// V:Obj1\n// V:Obj2\n// prv:Obj2</code></pre></div><p>也就是说这个 Traversable 接口的作用在实际使用中并不明显。相信我们决大部分人也并没有使用过这个接口来判断过类是否可以被遍历。但是从上面的例子中我们可以看出，迭代器能够自定义我们需要输出的内容。相对来说比直接的对象遍历更加的灵活可控。另外，如果是数组强转对象的情况，Traversable 接口同样无法进行判断。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$arr = [1, 2, 3, 4];\n$obj3 = (object) $arr;\necho $obj3 instanceof Traversable ? \'yes\' : \'no\', PHP_EOL; // no\n\nforeach ($obj3 as $o3) {\n    echo $o3, PHP_EOL;\n}</code></pre></div><p>其实，数组本身就是天然的可迭代对象。这里虽然进行了类型强转，但其实应该将数组强转的对象视为默认实现了迭代的器的对象更合适。当然，这类接口更大的意义还是在于代码规范及强制检查方面。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E5%9C%A8PHP%E4%B8%AD%E6%A3%80%E6%B5%8B%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%ABforeach%E9%81%8D%E5%8E%86.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202003/source/%E5%9C%A8PHP%E4%B8%AD%E6%A3%80%E6%B5%8B%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%ABforeach%E9%81%8D%E5%8E%86.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/class.traversable.php\">https://www.php.net/manual/zh/class.traversable.php</a></p><p><a href=\"https://www.php.net/manual/zh/control-structures.foreach.php\">https://www.php.net/manual/zh/control-structures.foreach.php</a></p><p><a href=\"https://www.php.net/manual/zh/language.oop5.iterations.php\">https://www.php.net/manual/zh/language.oop5.iterations.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-04-07 03:53:41', 1);
INSERT INTO `zy_articles_xs_test` VALUES (81, 'PHP中的数据库连接持久化', '<h1>PHP中的数据库连接持久化</h1><p>数据库的优化是我们做web开发的重中之重，甚至很多情况下其实我们是在面向数据库编程。当然，用户的一切操作、行为都是以数据的形式保存下来的。在这其中，数据库的连接创建过程有没有什么可以优化的内容呢？答案当然是有的，Java等语言中有连接池的设定，而PHP在普通开发中并没有连接池这种东西，在牵涉到多线程的情况下往往才会使用连接池的技术，所以PHP每次运行都会创建新的连接，那么这种情况下，我们如何来优化数据连接呢？</p><h2>什么是数据库连接持久化</h2><p>我们先来看下数据库连接持久化的定义。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>持久的数据库连接是指在脚本结束运行时不关闭的连接。当收到一个持久连接的请求时。PHP 将检查是否已经存在一个（前面已经开启的）相同的持久连接。如果存在，将直接使用这个连接；如果不存在，则建立一个新的连接。所谓“相同”的连接是指用相同的用户名和密码到相同主机的连接。</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>对 web 服务器的工作和分布负载没有完全理解的读者可能会错误地理解持久连接的作用。特别的，持久连接不会在相同的连接上提供建立“用户会话”的能力，也不提供有效建立事务的能力。实际上，从严格意义上来讲，持久连接不会提供任何非持久连接无法提供的特殊功能。</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这就是PHP中的连接持久化，不过它也指出了，持久连接不会提供任何非持久连接无法提供的特殊功能。这就很让人疑惑了，不是说好了这个方案可以带来性能的提升吗？</p><h2>连接持久化有什么用？</h2><p>没错，从上述定义中指出的特殊功能来看，持久化连接确实没有带来新的或者更高级的功能，但是它最大的用处正是提升了效率，也就是性能会带来提升。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>当Web Server创建到SQL服务器的连接耗费(Overhead)较高（如耗时较久，消耗临时内存较多）时，持久连接将更加高效。</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>也就是说连接耗费高的时候，创建数据库连接的成本开销也会越大，时间当然也越长。使用持久化连接之后，<em>使得每个子进程在其生命周期中只做一次连接操作，而非每次在处理一个页面时都要向SQL 服务器提出连接请求。这也就是说，每个子进程将对服务器建立各自独立的持久连接。</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>例如，如果有 20 个不同的子进程运行某脚本建立了持久的 SQL 服务器持久连接，那么实际上向该 SQL 服务器建立了 20 个不同的持久连接，每个进程占有一个。</p><h2>效率对比</h2><p>话不多说，我们直接通过代码来对比。首先，我们定义好一个统计函数，用来返回当前的毫秒时间。另外，我们还要准备好数据的连接参数。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function getmicrotime()\n{\n    list($usec, $sec) = explode(\" \", microtime());\n    return ((float) $usec + (float) $sec);\n}\n\n$db = [\n    \'server\' =&gt; \'localhost:3306\',\n    \'user\' =&gt; \'root\',\n    \'password\' =&gt; \'\',\n    \'database\' =&gt; \'blog_test\',\n];</code></pre></div><p>接下来，我们先使用普通的 mysqli 进行测试。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$startTime = getmicrotime();\nfor ($i = 0; $i &lt; 1000; $i++) {\n    $mysqli = new mysqli($db[\"server\"], $db[\"user\"], $db[\"password\"], $db[\"database\"]); //持久连接\n    $mysqli-&gt;close();\n}\necho bcsub(getmicrotime(), $startTime, 10), PHP_EOL;\n// 6.5814000000</code></pre></div><p>在 1000 次的循环创建数据库的连接过程中，我们消耗了6秒多的时间。接下来我们使用持久化连接的方式进行这 1000 次的数据库连接创建。只需要在 mysqli 的 $host 参数前加上一个 p: 即可。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$startTime = getmicrotime();\nfor ($i = 0; $i &lt; 1000; $i++) {\n    $mysqli = new mysqli(\'p:\' . $db[\"server\"], $db[\"user\"], $db[\"password\"], $db[\"database\"]); //持久连接\n    $mysqli-&gt;close();\n}\necho bcsub(getmicrotime(), $startTime, 10), PHP_EOL;\n// 0.0965000000</code></pre></div><p>从 mysqli 的连接上来看，效率提升非常明显。当然，PDO 方式的数据库连接也提供了建立持久连接的属性。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$startTime = getmicrotime();\nfor ($i = 0; $i &lt; 1000; $i++) {\n    $pdo = new PDO(\"mysql:dbname={$db[\'database\']};host={$db[\'server\']}\", $db[\'user\'], $db[\'password\']);\n}\necho bcsub(getmicrotime(), $startTime, 10), PHP_EOL;\n// 6.6171000000\n\n$startTime = getmicrotime();\nfor ($i = 0; $i &lt; 1000; $i++) {\n    $pdo = new PDO(\"mysql:dbname={$db[\'database\']};host={$db[\'server\']}\", $db[\'user\'], $db[\'password\'], [PDO::ATTR_PERSISTENT =&gt; true]); //持久连接\n}\necho bcsub(getmicrotime(), $startTime, 10), PHP_EOL;\n// 0.0398000000</code></pre></div><p>PDO 方式连接时，需要给一个 PDO::ATTR_PERSISTENT 参数并设置为 true 。这样就让 PDO 建立的连接也成为了持久化的连接。</p><h2>注意</h2><p>既然数据库的持久化连接这么强大，为什么不默认就是这种持久化的连接形式，而需要我们手动增加参数来实现呢？PHP 的开发者们当然还是有顾虑的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>如果持久连接的子进程数目超过了设定的数据库连接数限制，系统将会产生一些问题。如果数据库的同时连接数限制为 16，而在繁忙会话的情况下，有 17 个线程试图连接，那么有一个线程将无法连接。如果这个时候，在脚本中出现了使得连接无法关闭的错误（例如无限循环），则该数据库的 16 个连接将迅速地受到影响。</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>同时，表锁和事务也有需要注意的地方。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>在持久连接中使用数据表锁时，如果脚本不管什么原因无法释放该数据表锁，其随后使用相同连接的脚本将会被持久的阻塞，使得需要重新启动 httpd 服务或者数据库服务</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><em>在使用事务处理时，如果脚本在事务阻塞产生前结束，则该阻塞也会影响到使用相同连接的下一个脚本</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>所以，在使用表锁及事务的情况下，最好还是不要使用持久化的数据库连接。不过好在持久连接和普通连接是可以在任何时候互换的，我们定义两种连接形式，在不同的情况下使用不同的连接即可解决类似的问题。</p><h2>总结</h2><p>事物总有两面性，持久连接一方面带来了效率的提升，但另一方面也可能带来一些业务逻辑上的问题，而且这种问题如果在不了解持久连接的机制的情况下会非常难排查。因此，在日常开发中我们一定要在了解相关功能特性的情况下再选择适合的方式来完成所需要的功能开发。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/PHP%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%8C%81%E4%B9%85%E5%8C%96.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/PHP%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%8C%81%E4%B9%85%E5%8C%96.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/features.persistent-connections.php\">https://www.php.net/manual/zh/features.persistent-connections.php</a></p>', 'PHP', 'PHP基础,PHP数据库,PDO,MySQLi', '2022-07-23 18:06:29', '2022-10-04 15:12:48', 1);
INSERT INTO `zy_articles_xs_test` VALUES (82, 'PHP垃圾回收机制的一些浅薄理解', '<h1>PHP垃圾回收机制的一些浅薄理解</h1><p>相信只要入门学习过一点开发的同学都知道，不管任何编程语言，一个变量都会保存在内存中。其实，我们这些开发者就是在来回不停地操纵内存，相应地，我们如果一直增加新的变量，内存就会一直增加，如果没有一个好的机制，那么内存就会无限制地增加最终撑满所有的内存。这就造成了内存泄露。但在日常开发中，除非一次加载一个很大的文件，我们几乎见不到内存超限的错误，这就是垃圾回收机制的作用。</p><h2>垃圾回收是什么东西？</h2><p>在使用 C 语言的时候，我们都要手动使用 free 来释放内存，在 C 之后的大部分编程语言都会自带一个垃圾回收之类的处理能力，也就是我们今天要说的垃圾回收机制，也称为 GC 。在有 GC 能力的开发语言中，我们不需要去关心什么时候释放内存，甚至我们完全不需要去了解这一块的内容，因为这些语言在底层已经帮我们处理好了关于内存释放的问题。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>当然这方面的内容最出名的就是 Java 中的垃圾回收机制，其实 PHP 也有相应的处理机制，当然，很多 PHPer 可能从来没接触过，今天我们就来探讨一下这方面的内容。</p><h2>PHP 的垃圾回收算法</h2><p>在之前的文章中，我们有介绍过引用计数的概念  。在 PHP5.3 之前，PHP 的垃圾回收机制非常简单，就是把 refcount 为0的全部清理回收掉，在底层也就是 free 掉了。但是这种方式会带来一个问题，也就是我们在引用计数这篇文章中说过的循环引用，这种引用问题通过普通的判断 refcount 的方式是无法回收的。所以在 PHP5.3 之前，循环引用是会造成内存泄露的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>之所以强调版本，那是因为在 5.3 之后，PHP 改进了垃圾回收的算法，使这种循环引用得到了解决。（当然，我们在日常开发中尽量要避免这种循环引用的问题）。具体算法我们引用官方的图片：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/old/9f46ae1caf7720cc29654c7e40ed6c92.png\" alt=\"//img1.zyblog.com.cn/old/9f46ae1caf7720cc29654c7e40ed6c92.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在官方文档中有详尽的解释，不过还是会看得很懵逼。我们就用简单的语言（说人话）来描述这个过程。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>首先，我们有个根缓冲区的概念，就是图中的 root 。在底层通过一系列看不懂搞不明白的算法我们能找到每个变量的一个可能根。PHP 会将变量的可能根放入根缓冲区。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>当根缓冲区满了的时候，一般这个默认值是10000，需要修改源码重新编译才能修改这个值。PHP 就会启动垃圾回收机制，从根缓冲区中按照深度遍历的算法来查找所有的和这个可能根相关的变量，并将某一个可能根找到的变量的 refcount 减1，并做一个标记当前这个“已减”。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>然后再次深度遍历，如果 refcount 不是0的，就加1，如果是0的就保持不变。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接着清除根缓冲区中的所有可能根，清除而不是删除。然后清理释放所有的 refcount 为0的变量内容。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>是不是已经懵逼了？其实我也很懵逼，都不知道这段是怎么写下来的....</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>记住几个要点就可以对付面试并秒杀大部分人了。</p><ul><li><p>PHP5.3 后并不是直接看每个变量的 refcount 是否为0了</p></li><li><p>使用的算法是深度遍历，有个根缓冲区，根据它来清理，具体算法需要比较扎实的 C 和算法基础，学源码的时候再好好研究吧</p></li><li><p>5.3 之后和算法解决了循环引用的问题</p></li><li><p>内存泄露值会保持在某一个范围，不会出现立即大范围崩溃的情况</p></li></ul><h2>垃圾回收对性能的影响</h2><p>前文说过，垃圾回收在根缓冲区满了之后会马上执行。其中也会进行两次的深度遍历，这就不可避免的带来了性能的消耗。毕竟算法的执行都是需要耗时的。不过相对于内存溢出这种毁灭性的错误来说，垃圾回收带来的性能损耗基本上是可以忽略不计的。</p><h2>总结</h2><p>垃圾回收的内容其实我们只需要记住几个关键点就可以了，具体的核心算法和内容是需要在更深入的研究源码后才能完全了解的，当然，这也是我们学习的目标，之后也一定会涉猎源码底层的相关内容，就让我们拭目以待吧！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/features.gc.collecting-cycles.php\">https://www.php.net/manual/zh/features.gc.collecting-cycles.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/features.gc.performance-considerations.php\">https://www.php.net/manual/zh/features.gc.performance-considerations.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.cnblogs.com/lishanlei/p/9852274.html\">https://www.cnblogs.com/lishanlei/p/9852274.html</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.cnblogs.com/lovehappying/p/3679356.html\">https://www.cnblogs.com/lovehappying/p/3679356.html</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-08-07 02:56:12', 1);
INSERT INTO `zy_articles_xs_test` VALUES (83, 'PHP多文件上传格式化', '<h1>PHP多文件上传格式化</h1><p>文件上传是所有web应用中最常见的功能，而PHP实现这一功能也非常的简单，只需要前端设置表单的 enctype 值为 multipart/form-data 之后，我们就可以通过 $_FILES 获得表单中的 file 控件中的内容。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>同时，我们还可以将 file 控件的名称写成带 [] 的数组形式，这样我们就可以接收到多个上传的文件。比如下面这个测试用的表单：</p><div data-language=\"html\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;form action=\"\" enctype=\"multipart/form-data\" method=\"post\"&gt;\n\n    myfile1：&lt;input type=\"file\" name=\"myfile[]\"/&gt;&lt;br/&gt;\n    myfile2：&lt;input type=\"file\" name=\"myfile[a][]\"/&gt;&lt;br/&gt;\n    myfile3：&lt;input type=\"file\" name=\"myfile[a][b][]\"/&gt;&lt;br/&gt;\n    myfile4：&lt;input type=\"file\" name=\"myfile[c][]\"/&gt;&lt;br/&gt;\n    myfile5：&lt;input type=\"file\" name=\"myfile[]\"/&gt;&lt;br/&gt;\n    myfile6：&lt;input type=\"file\" name=\"myfile[][]\"/&gt;&lt;br/&gt;\n    &lt;br/&gt;\n    newfile1：&lt;input type=\"file\" name=\"newfile[][]\"/&gt;&lt;br/&gt;\n    newfile2：&lt;input type=\"file\" name=\"newfile[s]\"/&gt;&lt;br/&gt;\n\n    singlefile: &lt;input type=\"file\" name=\"singlefile\"/&gt;&lt;br/&gt;\n        &lt;input type=\"submit\" value=\"submit\"/&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre></div><p>一共有9个 file 控件，其中 myfile 和 newfile 都是数组类型的表单名，而 singlefile 则是一个单独的。先简单的看一下 $_FILES 所获得的内容。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nprint_r($_FILES);\n\nArray\n(\n    [myfile] =&gt; Array\n        (\n            [name] =&gt; Array\n                (\n                    [0] =&gt; 2591d8b3eee018a0a84f671933ab6c74.png\n                    [a] =&gt; Array\n                        (\n                            [0] =&gt; 12711584942474_.pic_hd 1.jpg\n                            [b] =&gt; Array\n                                (\n                                    [0] =&gt; 12721584942474_.pic_hd 1.jpg\n                                )\n\n                        )\n\n                    [c] =&gt; Array\n                        (\n                            [0] =&gt; 12731584942474_.pic_hd.jpg\n                        )\n\n                    [1] =&gt; background1.jpg\n                    [2] =&gt; Array\n                        (\n                            [0] =&gt; adliu_pip_data.xlsx\n                        )\n\n                )\n\n            [type] =&gt; Array\n                (\n                    [0] =&gt; image/png\n                    [a] =&gt; Array\n                        (\n                            [0] =&gt; image/jpeg\n                            [b] =&gt; Array\n                                (\n                                    [0] =&gt; image/jpeg\n                                )\n\n                        )\n\n                    [c] =&gt; Array\n                        (\n                            [0] =&gt; image/jpeg\n                        )\n\n                    [1] =&gt; image/jpeg\n                    [2] =&gt; Array\n                        (\n                            [0] =&gt; application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n                        )\n\n                )\n\n            [tmp_name] =&gt; Array\n                (\n                    [0] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phphD88ZY\n                    [a] =&gt; Array\n                        (\n                            [0] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phpNY8MzY\n                            [b] =&gt; Array\n                                (\n                                    [0] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/php3MX5tk\n                                )\n\n                        )\n\n                    [c] =&gt; Array\n                        (\n                            [0] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phpjgrHMj\n                        )\n\n                    [1] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phppXRtnc\n                    [2] =&gt; Array\n                        (\n                            [0] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phpekSY1M\n                        )\n\n                )\n\n            [error] =&gt; Array\n                (\n                    [0] =&gt; 0\n                    [a] =&gt; Array\n                        (\n                            [0] =&gt; 0\n                            [b] =&gt; Array\n                                (\n                                    [0] =&gt; 0\n                                )\n\n                        )\n\n                    [c] =&gt; Array\n                        (\n                            [0] =&gt; 0\n                        )\n\n                    [1] =&gt; 0\n                    [2] =&gt; Array\n                        (\n                            [0] =&gt; 0\n                        )\n\n                )\n\n            [size] =&gt; Array\n                (\n                    [0] =&gt; 4973\n                    [a] =&gt; Array\n                        (\n                            [0] =&gt; 3007\n                            [b] =&gt; Array\n                                (\n                                    [0] =&gt; 1156\n                                )\n\n                        )\n\n                    [c] =&gt; Array\n                        (\n                            [0] =&gt; 6068\n                        )\n\n                    [1] =&gt; 393194\n                    [2] =&gt; Array\n                        (\n                            [0] =&gt; 36714\n                        )\n\n                )\n\n        )\n\n    [newfile] =&gt; Array\n        (\n            [name] =&gt; Array\n                (\n                    [0] =&gt; Array\n                        (\n                            [0] =&gt; 数据列表 (2).xlsx\n                        )\n\n                    [s] =&gt; background1.jpg\n                )\n\n            [type] =&gt; Array\n                (\n                    [0] =&gt; Array\n                        (\n                            [0] =&gt; application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n                        )\n\n                    [s] =&gt; image/jpeg\n                )\n\n            [tmp_name] =&gt; Array\n                (\n                    [0] =&gt; Array\n                        (\n                            [0] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phplSsRfM\n                        )\n\n                    [s] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phpuQAvRb\n                )\n\n            [error] =&gt; Array\n                (\n                    [0] =&gt; Array\n                        (\n                            [0] =&gt; 0\n                        )\n\n                    [s] =&gt; 0\n                )\n\n            [size] =&gt; Array\n                (\n                    [0] =&gt; Array\n                        (\n                            [0] =&gt; 77032\n                        )\n\n                    [s] =&gt; 393194\n                )\n\n        )\n\n    [singlefile] =&gt; Array\n        (\n            [name] =&gt; timg (8).jpeg\n            [type] =&gt; image/jpeg\n            [tmp_name] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phpxtSQ4J\n            [error] =&gt; 0\n            [size] =&gt; 10273\n        )\n\n)\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>看出有什么问题了吗？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$_FILE[\'singlefile\'][\'name\'];\n$_FILE[\'singlefile\'][\'type\'];\n$_FILE[\'singlefile\'][\'tmp_name\'];\n$_FILE[\'singlefile\'][\'error\'];\n$_FILE[\'singlefile\'][\'error\'];\n\n$_FILE[\'myfile\'][\'name\'][\'a\'][\'b\'][0];\n$_FILE[\'myfile\'][\'type\'][\'a\'][\'b\'][0];\n$_FILE[\'myfile\'][\'tmp_name\'][\'a\'][\'b\'][0];\n$_FILE[\'myfile\'][\'error\'][\'a\'][\'b\'][0];\n$_FILE[\'myfile\'][\'error\'][\'a\'][\'b\'][0];</code></pre></div><p>单个表单是一个 singlefile 为键名的数组，里面是对应的 name 、 type 等属性。这个非常简单也清晰明了，但是数组形式上传的内容就比较坑了，每一个属性下面都有多个值，而且这些值还有可能是嵌套的数组。就比如说我们要获得 myfile[a][b][] 的上传文件内容，我们就要通过 \\$_FILE[\'myfile\'][\'name\'][\'a\'][\'b\'][0] 、 $_FILE[\'myfile\'][\'type\'][\'a\'][\'b\'][0] 这样的形式获得相关的内容。这个可真的不是很友好，那么我们今天的主题就来了，我们把这种内容进行一下格式化，让他变成和 singlefile 类似的结构，也就是一个文件的相关内容都在一个键名结构下，比如 myfile[a][b][] 的内容就全部都在 $_FILE[\'myfile\'][a][b][0]下面。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$files = [];\n// 开始数据格式化\nforeach ($_FILES as $uploadKey =&gt; $uploadFiles) {\n    // 需要将 $_FILES 中的五个字段都拿出来\n    $files[$uploadKey] = formatUploadFiles($uploadFiles[\'name\'], $uploadFiles[\'type\'], $uploadFiles[\'tmp_name\'], $uploadFiles[\'error\'], $uploadFiles[\'size\']);\n}\n\n// 格式化上传文件数组\nfunction formatUploadFiles($fileNamesArray, $type, $tmp_name, $error, $size)\n{\n    $tmpFiles = [];\n    // 文件名是否是数组，如果不是数组，就是单个文件上传\n    if (is_array($fileNamesArray)) {\n        // 数组形式上传\n        foreach ($fileNamesArray as $idx =&gt; $fileName) {\n            // 如果还是嵌套的数组，递归遍历接下来的内容\n            if (is_array($fileName)) {\n                $tmpFiles[$idx] = formatUploadFiles($fileName, $type[$idx] ?? [], $tmp_name[$idx] ?? [], $error[$idx] ?? [], $size[$idx] ?? []);\n            } else {\n                // 组合多维的格式化内容\n                $tmpFiles[$idx] = [\n                    \'name\' =&gt; $fileName,\n                    \'type\' =&gt; $type[$idx] ?? \'\',\n                    \'tmp_name\' =&gt; $tmp_name[$idx] ?? \'\',\n                    \'error\' =&gt; $error[$idx] ?? \'\',\n                    \'size\' =&gt; $size[$idx] ?? \'\',\n                ];\n            }\n        }\n    } else {\n        // 组合单个的内容\n        $tmpFiles = [\n            \'name\' =&gt; $fileName,\n            \'type\' =&gt; $type ?? \'\',\n            \'tmp_name\' =&gt; $tmp_name ?? \'\',\n            \'error\' =&gt; $error ?? \'\',\n            \'size\' =&gt; $size ?? \'\',\n        ];\n    }\n\n    return $tmpFiles;\n}\n\nprint_r($files);</code></pre></div><p>代码还是非常好理解的，就是通过一段递归来遍历整个 $_FILES 目录树，相当于一个深度遍历。当然，这样也会带来性能的下降，毕竟是需要进行循环+递归的遍历。不过好在大部分情况下我们上传的文件并不会那么的多。不过反过来说，如果不事先进行格式化，当你想获得所有的上传内容时，一样还是需要进行多层或者递归遍历的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来我们看看格式化之后的输出：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">Array\n(\n    [myfile] =&gt; Array\n        (\n            [0] =&gt; Array\n                (\n                    [name] =&gt; 2591d8b3eee018a0a84f671933ab6c74.png\n                    [type] =&gt; image/png\n                    [tmp_name] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phpV7A2yC\n                    [error] =&gt; 0\n                    [size] =&gt; 4973\n                )\n\n            [a] =&gt; Array\n                (\n                    [0] =&gt; Array\n                        (\n                            [name] =&gt; 12711584942474_.pic_hd 1.jpg\n                            [type] =&gt; image/jpeg\n                            [tmp_name] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/php5q2d1Z\n                            [error] =&gt; 0\n                            [size] =&gt; 3007\n                        )\n\n                    [b] =&gt; Array\n                        (\n                            [0] =&gt; Array\n                                (\n                                    [name] =&gt; 12721584942474_.pic_hd 1.jpg\n                                    [type] =&gt; image/jpeg\n                                    [tmp_name] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phpdvv8No\n                                    [error] =&gt; 0\n                                    [size] =&gt; 1156\n                                )\n\n                        )\n\n                )\n\n            [c] =&gt; Array\n                (\n                    [0] =&gt; Array\n                        (\n                            [name] =&gt; 12731584942474_.pic_hd.jpg\n                            [type] =&gt; image/jpeg\n                            [tmp_name] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/php9tfGmp\n                            [error] =&gt; 0\n                            [size] =&gt; 6068\n                        )\n\n                )\n\n            [1] =&gt; Array\n                (\n                    [name] =&gt; background1.jpg\n                    [type] =&gt; image/jpeg\n                    [tmp_name] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phplUVpzA\n                    [error] =&gt; 0\n                    [size] =&gt; 393194\n                )\n\n            [2] =&gt; Array\n                (\n                    [0] =&gt; Array\n                        (\n                            [name] =&gt; adliu_pip_data.xlsx\n                            [type] =&gt; application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n                            [tmp_name] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phpNRtiaC\n                            [error] =&gt; 0\n                            [size] =&gt; 36714\n                        )\n\n                )\n\n        )\n\n    [newfile] =&gt; Array\n        (\n            [0] =&gt; Array\n                (\n                    [0] =&gt; Array\n                        (\n                            [name] =&gt; 数据列表 (2).xlsx\n                            [type] =&gt; application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n                            [tmp_name] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phpBLG7aG\n                            [error] =&gt; 0\n                            [size] =&gt; 77032\n                        )\n\n                )\n\n            [s] =&gt; Array\n                (\n                    [name] =&gt; background1.jpg\n                    [type] =&gt; image/jpeg\n                    [tmp_name] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phpjyqCFY\n                    [error] =&gt; 0\n                    [size] =&gt; 393194\n                )\n\n        )\n\n    [singlefile] =&gt; Array\n        (\n            [name] =&gt;\n            [type] =&gt; image/jpeg\n            [tmp_name] =&gt; /private/var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/phpuYJXiE\n            [error] =&gt; 0\n            [size] =&gt; 10273\n        )\n\n)</code></pre></div><p>和上面原始的 $_FILES 相比是不是清晰明了的很多？这回我们如果需要 myfile[a][b][] 里面全部的内容时，就可以使用下面的方式方便的获取了：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$files[\'myfile\'][\'a\'][\'b\'][0][\'name\'];\n$files[\'myfile\'][\'a\'][\'b\'][0][\'type\'];\n$files[\'myfile\'][\'a\'][\'b\'][0][\'tmp_name\'];\n$files[\'myfile\'][\'a\'][\'b\'][0][\'error\'];\n$files[\'myfile\'][\'a\'][\'b\'][0][\'size\'];</code></pre></div><p>当然，这种需求在我们的日常工作中并不多见，这里也只是提供一个思路，将数据提前转化成我们需要的格式是一种非常好的习惯，能够让我们的后续操作变得非常简单。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/PHP%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%A0%BC%E5%BC%8F%E5%8C%96.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/PHP%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%A0%BC%E5%BC%8F%E5%8C%96.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/features.file-upload.php\">https://www.php.net/manual/zh/features.file-upload.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-10-17 20:15:41', 1);
INSERT INTO `zy_articles_xs_test` VALUES (84, 'PHP打印跟踪调试信息', '<h1>PHP打印跟踪调试信息</h1><p>对于大部分编译型语言来说，比如 C 、 Java 、 C# ，我们都能很方便地进行断点调试，但是 PHP 则必须安装 XDebug 并且在编辑器中进行复杂的配置才能实现断点调试的能力。不过，如果只是简单的调试并且查看堆栈回溯的话，其实 PHP 已经为我们准备好了两个函数，能够让我们非常方便的看到程序运行时的调用情况。</p><h2>debug_backtrace()</h2><p>从这个方法的字面意思上就可以看出，它的意思就是调试回溯，返回的也正是一段回溯信息的数组。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function a_test($str)\n{\n    echo \"Hi: $str\", PHP_EOL;\n    var_dump(debug_backtrace());\n}\n\nvar_dump(debug_backtrace());\n\na_test(\"A\");\n\n// Hi: A/Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/PHP打印跟踪调试信息.php:7:\n// array(1) {\n//   [0] =&gt;\n//   array(4) {\n//     \'file\' =&gt;\n//     string(93) \"/Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/PHP打印跟踪调试信息.php\"\n//     \'line\' =&gt;\n//     int(12)\n//     \'function\' =&gt;\n//     string(6) \"a_test\"\n//     \'args\' =&gt;\n//     array(1) {\n//       [0] =&gt;\n//       string(1) \"A\"\n//     }\n//   }\n// }</code></pre></div><p>这个方法必须在函数中调用，在函数方法外部使用是不会有内容的。从内容中看，它输出了关于这个函数的 __FILE__ 、 __LINE__ 、 __FUNCTION__ 、$argv 等信息。其实就是关于当前打印这行所在函数的相关内容。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们当然也可以多嵌套几层函数来看一下打印出的内容是什么。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function b_test(){\n    c_test();\n}\n\nfunction c_test(){\n    a_test(\"b -&gt; c -&gt; a\");\n}\n\nb_test();\n\n// Hi: b -&gt; c -&gt; a\n// /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/PHP打印跟踪调试信息.php:7:\n// array(3) {\n//   [0] =&gt;\n//   array(4) {\n//     \'file\' =&gt;\n//     string(93) \"/Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/PHP打印跟踪调试信息.php\"\n//     \'line\' =&gt;\n//     int(37)\n//     \'function\' =&gt;\n//     string(6) \"a_test\"\n//     \'args\' =&gt;\n//     array(1) {\n//       [0] =&gt;\n//       string(11) \"b -&gt; c -&gt; a\"\n//     }\n//   }\n//   [1] =&gt;\n//   array(4) {\n//     \'file\' =&gt;\n//     string(93) \"/Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/PHP打印跟踪调试信息.php\"\n//     \'line\' =&gt;\n//     int(33)\n//     \'function\' =&gt;\n//     string(6) \"c_test\"\n//     \'args\' =&gt;\n//     array(0) {\n//     }\n//   }\n//   [2] =&gt;\n//   array(4) {\n//     \'file\' =&gt;\n//     string(93) \"/Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/PHP打印跟踪调试信息.php\"\n//     \'line\' =&gt;\n//     int(40)\n//     \'function\' =&gt;\n//     string(6) \"b_test\"\n//     \'args\' =&gt;\n//     array(0) {\n//     }\n//   }\n// }</code></pre></div><p>没错，数组的输出顺序就是一个栈的执行顺序，b_test() 最先调用，所以它在栈底，对应的输出也就是数组中的最后一个元素。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在类中也是类似的使用方法。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class A{\n    function test_a(){\n        $this-&gt;test_b();\n    }\n    function test_b(){\n        var_dump(debug_backtrace());\n    }\n}\n\n$a = new A();\n$a-&gt;test_a();\n\n// /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/PHP打印跟踪调试信息.php:90:\n// array(2) {\n//   [0] =&gt;\n//   array(7) {\n//     \'file\' =&gt;\n//     string(93) \"/Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/PHP打印跟踪调试信息.php\"\n//     \'line\' =&gt;\n//     int(87)\n//     \'function\' =&gt;\n//     string(6) \"test_b\"\n//     \'class\' =&gt;\n//     string(1) \"A\"\n//     \'object\' =&gt;\n//     class A#1 (0) {\n//     }\n//     \'type\' =&gt;\n//     string(2) \"-&gt;\"\n//     \'args\' =&gt;\n//     array(0) {\n//     }\n//   }\n//   [1] =&gt;\n//   array(7) {\n//     \'file\' =&gt;\n//     string(93) \"/Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/PHP打印跟踪调试信息.php\"\n//     \'line\' =&gt;\n//     int(95)\n//     \'function\' =&gt;\n//     string(6) \"test_a\"\n//     \'class\' =&gt;\n//     string(1) \"A\"\n//     \'object\' =&gt;\n//     class A#1 (0) {\n//     }\n//     \'type\' =&gt;\n//     string(2) \"-&gt;\"\n//     \'args\' =&gt;\n//     array(0) {\n//     }\n//   }\n// }</code></pre></div><p>在类中使用的时候，在数组项中会多出一个 object 字段，显示的是这个方法所在类的信息。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>debug_backtrace() 的函数声明是：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">debug_backtrace ([ int $options = DEBUG_BACKTRACE_PROVIDE_OBJECT [, int $limit = 0 ]] ) : array</code></pre></div><p>其中 \\$options 是有两个常量可以定义，DEBUG_BACKTRACE_PROVIDE_OBJECT 表明是否填充 \"object\" 的索引；DEBUG_BACKTRACE_IGNORE_ARGS 是否忽略 \"args\" 的索引，包括所有的 function/method 的参数，能够节省内存开销。 $limits 可用于限制返回堆栈帧的数量，默认为0返回所有的堆栈。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>debug_backtrace() 以及下面要介绍的 debug_print_backtrace() 方法都是支持 require/include 文件以及 eval() 中的代码的，在嵌入文件时，会输出嵌入文件的路径，这个大家可以自行尝试。</p><h2>debug_print_backtrace()</h2><p>这个方法从名称也可以看出，它会直接打印回溯内容，它的函数声明和 debug_backtrace() 是一样的，不过 $options 默认是 DEBUG_BACKTRACE_IGNORE_ARGS ，也就是说，它只打印调用所在文件及行数。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">function a() {\n    b();\n}\n\nfunction b() {\n    c();\n}\n\nfunction c(){\n    debug_print_backtrace();\n}\n\na();\n\n#0  c() called at [/Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/PHP打印跟踪调试信息.php:144]\n#1  b() called at [/Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/PHP打印跟踪调试信息.php:140]\n#2  a() called at [/Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/PHP打印跟踪调试信息.php:151]</code></pre></div><p>另外就是这个函数不需要使用 var_dump() 或 print_r() 进行输出，直接使用这个函数就会进行输出。能够非常快捷方便的让我们进行调试，比如在 laravel 这类大型框架中，我们在控制器需要查看堆栈信息时，就可以使用 debug_print_backtrace() 快速地查看当前的堆栈调用情况。而 debug_backtrace() 如果没有指定 $options 的话，则会占用非常大的内存容量或者无法完整显示。</p><h2>总结</h2><p>今天介绍的这两个函数能够灵活地帮助我们调试代码或者了解一个框架的调用情况。当然，在正式的情况下还是推荐使用 Xdebug 加上编辑器的支持来进行断点调试，因为使用 debug_backtrace() 这两个方法我们无法看到变量的变化情况。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/PHP%E6%89%93%E5%8D%B0%E8%B7%9F%E8%B8%AA%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/PHP%E6%89%93%E5%8D%B0%E8%B7%9F%E8%B8%AA%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/function.debug-backtrace.php\">https://www.php.net/manual/zh/function.debug-backtrace.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.debug-print-backtrace.php\">https://www.php.net/manual/zh/function.debug-print-backtrace.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-10-05 03:14:27', 1);
INSERT INTO `zy_articles_xs_test` VALUES (85, 'PHP的CLI命令行运行模式浅析', '<h1>PHP的CLI命令行运行模式浅析</h1><p>在做开发的时候，我们不仅仅只是做各种网站或者接口，也经常需要写一些命令行脚本用来处理一些后端的事务。比如对数据进行处理统计等。当然也是为了效率着想，当一个事务有可能会有较长的耗时时，往往会交由服务器的定时器来固定时间调用脚本进行处理，从而让客户端能够有更好的用户体验。我们今天就来了解下 PHP 的命令行运行模式，也就是 PHP CLI 。</p><h2>CLI 与 CGI</h2><p>首先来看一下 CLI 和 CGI 的区别。我们都知道，Nginx 使用的是 FastCgi 来调用 PHP 的服务。 CGI 是通用编程接口，也就是给调用者提供的一种使用本程序的接口。 Nginx 这种类型的服务器并不是直接运行 PHP 程序的，而是通过 FastCgi 来执行 PHP 程序并获得返回结果。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>CLI 则是 Command Line Interface，即命令行接口。主要用作 PHP 的开发外壳应用。也就是用 PHP 来进行 shell 脚本的开发。相比 linux 原生的 shell 来说，当然是方便了许多。在命令行状态下，直接使用 php 命令就可以运行某段 PHP 代码或某个 PHP 文件了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另外，我们在命令行也可以直接使用 phpcgi 来运行一段 PHP 代码或者某个 PHP 文件，它和直接使用 php 命令来运行有什么区别呢？</p><ul><li><p>CLI 的输出没有任何头信息</p></li><li><p>CLI 在运行时，不会把工作目录改为脚本的当前目录</p></li><li><p>CLI 出错时输出纯文本的错误信息（非 HTML 格式）</p></li><li><p>强制覆盖了 php.ini 中的某些设置，因为这些设置在外壳环境下是没有意义的</p></li></ul><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// PHP的CLI命令行运行模式浅析.php\necho getcwd();\n\n//  php-cgi dev-blog/php/202004/source/PHP的CLI命令行运行模式浅析.php\n// ...../MyDoc/博客文章/dev-blog/php/202004/source\n\n// php dev-blog/php/202004/source/PHP的CLI命令行运行模式浅析.php\n// ...../MyDoc/博客文章</code></pre></div><p>我们选取最典型的一个例子，我们运行的这个文件中，使用 getcwd() 输出当前脚本运行的目录，可以看出两种运行方式输出的结果明显不同。php-cgi 是以文件所在目录为基准输出，而 php 则是以当前运行这个命令的目录为基准输出。</p><h2>直接运行 PHP 代码</h2><p>在做一些简单的调试的时候，我们可以直接通过 CLI 来运行一段代码。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// php -r \"echo 121;\"\n// 121</code></pre></div><p>也就是简单的加个 -r 参数，后面跟上一段代码，这段代码必须用引号括起来。而且这个引号更推荐使用单引号，后面的例子会展示为什么用单引号更好。</p><h2>CLI 获取参数</h2><p>命令行模式下也是可以给脚本传递参数的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// PHP的CLI命令行运行模式浅析.php\nprint_r($argv);\n// php-cgi dev-blog/php/202004/source/PHP的CLI命令行运行模式浅析.php 1 2 3\n// X-Powered-By: PHP/7.3.0\n// Content-type: text/html; charset=UTF-8\n\n// php dev-blog/php/202004/source/PHP的CLI命令行运行模式浅析.php 1 2 3\n// Array\n// (\n//     [0] =&gt; dev-blog/php/202004/source/PHP的CLI命令行运行模式浅析.php\n//     [1] =&gt; 1\n//     [2] =&gt; 2\n//     [3] =&gt; 3\n// )</code></pre></div><p>在测试文件中，我们打印了 \\$argv 变量。PHP 脚本运行的时候，会将命令行的所有参数保存在 $argv 变量中，并且还有一个 $argc 变量会保存参数的个数。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们依然是使用 php-cgi 和 php ，两种模式来测试，从这里我们能发现 php-cgi 模式中 $argv 打印的内容竟然是头信息，而不是具体的参数信息。这也没错，毕竟 CGI 模式本来就是为 Web 服务器提供的接口，所以它接收的是 post 、 get 这类的参数而不是命令行的参数。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>CLI 模式下我们正常获得了参数内容，并且 $argv[0] 始终保存的是当前运行文件及路径。</p><h2>CLI 命令行实用选项</h2><p>最后，我们再介绍一些命令行中常用的选项。</p><h3>-r 直接运行代码时的参数传递</h3><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// php -r \"var_dump($argv);\" app \n// Warning: var_dump() expects at least 1 parameter, 0 given in Command line code on line 1\n// 双引号 \"，sh/bash 实行了参数替换\n\n// php -r \'var_dump($argv);\' app\n// array(2) {\n//     [0]=&gt;string(19) \"Standard input code\"\n//     [1]=&gt;string(3) \"app\"\n// }\n\n// php -r \'var_dump($argv);\' -- -h\n// array(2) {\n//     [0]=&gt;string(19) \"Standard input code\"\n//     [1]=&gt;string(2) \"-h\"\n// }</code></pre></div><p>第一段代码在对双引号运行的 CLI 代码进行参数传递的时候，会直接报警告。其实很好理解，双引号里面的$会让系统的 sh/bash 以为这是个变量从而进行变量参数替换。所以更推荐使用单引号进行日常的简单测试。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>第二段代码能够正常打印传递进来的参数内容。第三行代码则是需要传递带 - 符号的内容时，需要先给一个 -- 参数列表分隔符。这是因为 -xxx 的内容会让 php 命令认为这是一个命令选项而不是参数，所以我们添加一个分隔符就可以让分隔符之后的参数内容原样传递进代码中。</p><h3>交互式地运行 PHP</h3><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// php -a\n// php &gt; $a = 1;\n// php &gt; echo $a;\n// php &gt; 1</code></pre></div><p>添加一个 -a 选项，PHP 就会以交互式地形式运行，我们可以直接在交互状态下写代码或运行任何内容。</p><h3>查看 phpinfo() 及已经安装的模块</h3><p>这两个应该是大家经常会使用的两个选项。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 输出 phpinfo()\n// php -i\n\n// 输出 PHP 中加载的模块\n// php -m\n\n// 查看模块详细信息\n// php --ri swoole </code></pre></div><p>另外我们还可以通过 --ri 模块名 这个命令来查看具体某个扩展模块的详细信息。比如这里我们可以查看到 swoole 扩展的版本及相关的配置信息。</p><h3>查看某个文件</h3><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 显示去除了注释和多余空白的源代码\n// php -w dev-blog/php/202004/source/PHP的CLI命令行运行模式浅析.php\n// &lt;?php\n//  echo getcwd(); print_r($argv);\n\n// 通过 linux 管道读取输入\n// cat dev-blog/php/202004/source/PHP的CLI命令行运行模式浅析.php | php -r \"print file_get_contents(\'php://stdin\');\"\n// ......这个文件里面所有的内容</code></pre></div><p>最后两个小技巧，一个是通过 -w 选项，我们可以打印这个 php 文件中所有非注释和换行的内容。可以看成是像前端的代码压缩一样的能力。我们这个测试文件中有非常多的注释，通过这个命令后我们打印出来的内容是去除掉所有注释和空白行的结果。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另一个是我们可以用 linux 管道的方式向 PHP CLI 发送数据。这里我们通过 cat 查看我们的测试文件然后通过管道发送给 PHP CLI，在脚本中使用 STDIN 来读取管道发送过来的内容完成了整个文件内容的打印。这里我们没进行任何过滤，所以打印的是整个文件里面的内容，大家可以运行这个命令来测试。</p><h2>总结</h2><p>其实命令行模式运行的时候还有很多的选项，这里我们只是选取了一部分非常有用的内容进行展示。当然，大部分框架都提供了用于命令行的脚本框架，比如 laravel 中可以通过 php artisan make:command 来创建命令行脚本，然后使用 php artisan 来运行框架中的脚本。这些内容将来我们在学习框架方面知识的内容将会进行详细的讲解。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>命令行 CLI 模式的应用非常广泛，几乎任何项目中都会使用到，所以，深入的学习掌握它将会使我们大受裨益。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/PHP%E7%9A%84CLI%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%E6%B5%85%E6%9E%90.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/PHP%E7%9A%84CLI%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%E6%B5%85%E6%9E%90.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/features.commandline.php\">https://www.php.net/manual/zh/features.commandline.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-03-06 03:30:34', 1);
INSERT INTO `zy_articles_xs_test` VALUES (86, 'PHP的内置WEB服务器', '<h1>PHP的内置WEB服务器</h1><p>在很多时候，我们需要简单的运行一个小 demo 来验证一些代码或者轮子是否可用，是否可以运行起来，但是去配 nginx 或者 apache 都很麻烦，其实，PHP CLI 已经提供了一个简单的测试服务器，我们直接就可以运行起来进行简单的一些测试工作。</p><h2>直接启动一个内置服务器</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">php -S localhost:8081</code></pre></div><p>直接使用 -S 命令选项，然后指定地址及端口号，我们就可以运行起来一个 PHP 内置的简易WEB服务器。默认情况下，这个地址会找当前目录下的 index.php 或 index.html 文件。当我们在浏览器输入指定的文件时，就是访问指定的文件，如果都没有找到会正常的返回404错误。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>而控制台会输出当前服务器的访问情况，如下图所示：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/20220724/3cab6ca86e52be093629a36fc369657f.png\" alt=\"//img1.zyblog.com.cn/20220724/3cab6ca86e52be093629a36fc369657f.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这个内置服务器和用 nginx 等服务器搭起来的应用服务器本质上没有太大的区别，包括 $_SERVER 之类的内容都可以正常获取到，也可以正常使用 include 等功能加载其他文件，也就是说这个内置WEB服务器运行一些框架也是没有问题的。它是可以完全满足我们的测试要求的。但是需要注意的是，这个内置WEB服务器不能用于生产环境。毕竟它的功能还是太简单，不是一个生产配备的高规格服务器应用。</p><h2>指定内置服务器的运行目录</h2><p>我们也可以在任何目录去运行指定目录的php代码，只需要再增加一个 -t 选项来指明要运行起服务器的根目录即可。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">php -S localhost:8081 -t dev-blog/php/202004/source</code></pre></div><p>这样我们就可以运行起来一个以 dev-blog/php/202004/source 目录为根目录的测试环境服务器。</p><h2>使用路由脚本</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">php -S localhost:8081 PHP的内置WEB服务器.php</code></pre></div><p>如果我们给当前服务器直接指定了一个PHP文件，那么直接打开链接就会访问的是这个文件的内容，而不是去找 index.php 之类的文件。即使我们继续给 URL 后台增加其他路径或者其他文件名，它依然会打开的是这个文件，也就是说，我们启动了一个单文件入口的应用服务器程序。就像各种框架的 index.php 文件一样，比如我们利用这个文件做一个简单的路由分发测试：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$routePages = [\n    \'/testRoute2.php\',\n    \'/route/testRoute1.php\'\n];\n\nif(in_array($_SERVER[\'REQUEST_URI\'], $routePages)){\n    include __DIR__ . $_SERVER[\'REQUEST_URI\'];\n}else{\n    print_r($_SERVER);\n}</code></pre></div><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// route/testRoute1.php\necho \"Hello Route1!\";\n\n// testRoute2.php\necho \"Hello Route2!\";</code></pre></div><p>两个测试文件只是简单的输出了一段文字用于区别分别加载了两个文件。上述代码的意思是我们访问定义好的两个路由路径时，就会加载对应的文件，访问其他路径则会打印当前服务器的 $_SERVER 信息。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/PHP%E7%9A%84%E5%86%85%E7%BD%AEWEB%E6%9C%8D%E5%8A%A1%E5%99%A8.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/PHP%E7%9A%84%E5%86%85%E7%BD%AEWEB%E6%9C%8D%E5%8A%A1%E5%99%A8.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/features.commandline.webserver.php\">https://www.php.net/manual/zh/features.commandline.webserver.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-07-02 21:25:22', 1);
INSERT INTO `zy_articles_xs_test` VALUES (87, 'PHP的引用计数是什么意思？', '<h1>PHP的引用计数是什么意思？</h1><h2>什么是引用计数</h2><p>在PHP的数据结构中，引用计数就是指每一个变量，除了保存了它们的类型和值之外，还额外保存了两个内容，一个是当前这个变量是否被引用，另一个是引用的次数。为什么要多保存这样两个内容呢？当然是为了垃圾回收（GC）。也就是说，当引用次数为0的时候，这个变量就没有再被使用了，就可以通过 GC 来进行回收，释放占用的内存资源。任何程序都不能无限制的一直占用着内存资源，过大的内存占用往往会带来一个严重的问题，那就是内存泄露，而 GC 就是PHP底层自动帮我们完成了内存的销毁，而不用像 C 一样必须去手动地 free 。</p><h2>怎么查看引用计数？</h2><p>我们需要安装 xdebug 扩展，然后使用 xdebug_debug_zval() 函数就可以看到指定内存的详细信息了，比如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$a = \"I am a String\";\nxdebug_debug_zval(\'a\');\n// a: (refcount=1, is_ref=0)=\'I am a String\'</code></pre></div><p>从上述内容中可以看出，这个 $a 变量的内容是 I am a String 这样一个字符串。而括号中的 refcount 就是引用次数，is_ref 则是说明这个变量是否被引用。我们通过变量赋值来看看这个两个参数是如何变化的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$b = $a;\nxdebug_debug_zval(\'a\');\n// a: (refcount=1, is_ref=0)=\'I am a String\'\n\n$b = &amp;$a;\nxdebug_debug_zval(\'a\');\n// a: (refcount=2, is_ref=1)=\'I am a String\'</code></pre></div><p>当我们进行普通赋值后，refcount 和 is_ref 没有任何变化，但当我们进行引用赋值后，可以看到 refcount 变成了2，is_ref 变成了1。这也就是说明当前的 \\$a 变量被引用赋值了，它的内存符号表服务于 $a 和 $b 两个变量。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$c = &amp;$a;\nxdebug_debug_zval(\'a\');\n// a: (refcount=3, is_ref=1)=\'I am a String\'\n\nunset($c, $b);\nxdebug_debug_zval(\'a\');\n// a: (refcount=1, is_ref=1)=\'I am a String\'\n\n$b = &amp;$a;\n$c = &amp;$a;\n$b = \"I am a String new\";\nxdebug_debug_zval(\'a\');\n// a: (refcount=3, is_ref=1)=\'I am a String new\'\n\nunset($a);\nxdebug_debug_zval(\'a\');\n// a: no such symbol</code></pre></div><p>继续增加一个 $c 的引用赋值，可以看到 refcount 会继续增加。然后 unset 掉 $b 和 $c 之后，refcount 恢复到了1，不过这时需要注意的是，is_ref 依然还是1，也就是说，这个变量被引用过，这个 is_ref 就会变成1，即使引用的变量都已经 unset 掉了这个值依然不变。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>最后我们 unset 掉 $a ，显示的就是 no such symbol 了。当前变量已经被销毁不是一个可以用的符号引用了。（注意，PHP中的变量对应的是内存的符号表，并不是真正的内存地址）</p><h2>对象的引用计数</h2><p>和普通类型的变量一样，对象变量也是使用同样的计数规则。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 对象引用计数\nclass A{\n\n}\n$objA = new A();\nxdebug_debug_zval(\'objA\');\n// objA: (refcount=1, is_ref=0)=class A {  }\n\n$objB = $objA;\nxdebug_debug_zval(\'objA\');\n// objA: (refcount=2, is_ref=0)=class A {  }\n\n$objC = $objA;\nxdebug_debug_zval(\'objA\');\n// objA: (refcount=3, is_ref=0)=class A {  }\n\nunset($objB);\nclass C{\n\n}\n$objC = new C;\nxdebug_debug_zval(\'objA\');\n// objA: (refcount=1, is_ref=0)=class A {  }</code></pre></div><p>不过这里需要注意的是，对象的符号表是建立的连接，也就是说，对 $objC 进行重新实例化或者修改为 NULL ，并不会影响 $objA 的内容，这方面的知识我们在之前的 <a href=\"https://mp.weixin.qq.com/s/wKIU83A7u1ENQF32jX5FSQ\">对象赋值在PHP中到底是不是引用？</a> 文章中已经有过说明。对象进行普通赋值操作也是引用类型的符号表赋值，所以我们不需要加 &amp; 符号。</p><h2>数组的引用计数</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 数组引用计数\n$arrA = [\n    \'a\'=&gt;1,\n    \'b\'=&gt;2,\n];\nxdebug_debug_zval(\'arrA\');\n// arrA: (refcount=2, is_ref=0)=array (\n//     \'a\' =&gt; (refcount=0, is_ref=0)=1, \n//     \'b\' =&gt; (refcount=0, is_ref=0)=2\n// )\n\n$arrB = $arrA;\n$arrC = $arrA;\nxdebug_debug_zval(\'arrA\');\n// arrA: (refcount=4, is_ref=0)=array (\n//     \'a\' =&gt; (refcount=0, is_ref=0)=1, \n//     \'b\' =&gt; (refcount=0, is_ref=0)=2\n// )\n\nunset($arrB);\n$arrC = [\'c\'=&gt;3];\nxdebug_debug_zval(\'arrA\');\n// arrA: (refcount=2, is_ref=0)=array (\n//     \'a\' =&gt; (refcount=0, is_ref=0)=1, \n//     \'b\' =&gt; (refcount=0, is_ref=0)=2\n// )\n\n// 添加一个已经存在的元素\n$arrA[\'c\'] = &amp;$arrA[\'a\'];\nxdebug_debug_zval(\'arrA\');\n// arrA: (refcount=1, is_ref=0)=array (\n//     \'a\' =&gt; (refcount=2, is_ref=1)=1, \n//     \'b\' =&gt; (refcount=0, is_ref=0)=2, \n//     \'c\' =&gt; (refcount=2, is_ref=1)=1\n// )</code></pre></div><p>调试数组的时候，我们会发现两个比较有意思的事情。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>一是数组内部的每个元素又有单独的自己的引用计数。这也比较好理解，每一个数组元素都可以看做是一个单独的变量，但数组就是这堆变量的一个哈希集合。如果在对象中有成员变量的话，也是一样的效果。当数组中的某一个元素被 &amp; 引用赋值给其他变量之后，这个元素的 refcount 会增加，不会影响整个数组的 refcount 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>二是数组默认上来的 refcount 是2。其实这是 PHP7 之后的一种新的特性，当数组定义并初始化后，会将这个数组转变成一个不可变数组（immutable array）。为了和普通数组区分开，这种数组的 refcount 是从2开始起步的。当我们修改一下这个数组中的任何元素后，这个数组就会变回普通数组，也就是 refcount 会变回1。这个大家可以自己尝试下，关于为什么要这样做的问题，官方的解释是为了效率，具体的原理可能还是需要深挖 PHP7 的源码才能知晓。</p><h2>关于内存泄露需要注意的地方</h2><p>其实 PHP 在底层已经帮我们做好了 GC 机制就不需要太关心变量的销毁释放问题，但是，千万要注意的是对象或数组中的元素是可以赋值为自身的，也就是说，给某个元素赋值一个自身的引用就变成了循环引用。那么这个对象就基本不太可能会被 GC 自动销毁了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 对象循环引用\nclass D{\n    public $d;\n}\n$d = new D;\n$d-&gt;d = $d;\nxdebug_debug_zval(\'d\');\n// d: (refcount=2, is_ref=0)=class D { \n//     public $d = (refcount=2, is_ref=0)=... \n// }\n\n// 数组循环引用\n$arrA[\'arrA\'] = &amp;$arrA;\nxdebug_debug_zval(\'arrA\');\n// arrA: (refcount=2, is_ref=1)=array (\n//     \'a\' =&gt; (refcount=0, is_ref=0)=1, \n//     \'b\' =&gt; (refcount=0, is_ref=0)=2, \n//     \'arrA\' =&gt; (refcount=2, is_ref=1)=...\n// )</code></pre></div><p>不管是对象还是数组，在打印调试时出现了 ... 这样的省略号，那么你的程序中就出现了循环引用。在之前的文章 <a href=\"https://mp.weixin.qq.com/s/OsxFg4llRLhey75DnNyl3A\">关于PHP中对象复制的那点事儿</a> 中我们也讲过这个循环引用的问题，所以这个问题应该是我们在日常开发中应该时刻关注的问题。</p><h2>总结</h2><p>引用计数是了解垃圾回收机制的前提条件，而且正是因为现代语言中都有一套类似的垃圾回收机制才让我们的编程变得更加容易且安全。那么有人说了，日常开发根本用不到这些呀？用不到不代表不应该去学习，就像循环引用这个问题一样，当代码中充斥着大量的类似代码时，系统崩溃只是迟早的事情，所以，这些知识是我们向更高级的程序进阶所不可或缺的内容。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/PHP%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/PHP%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/features.gc.refcounting-basics.php\">https://www.php.net/manual/zh/features.gc.refcounting-basics.php</a></p><p><a href=\"https://ask.csdn.net/questions/706390\">https://ask.csdn.net/questions/706390</a></p><p><a href=\"https://www.jianshu.com/p/52450a61354d\">https://www.jianshu.com/p/52450a61354d</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-10-22 07:48:42', 1);
INSERT INTO `zy_articles_xs_test` VALUES (88, '一些简单的错误处理函数（一）', '<h1>一些简单的错误处理函数（一）</h1><p>在之前的文章中，我们了解过了 PHP 中的异常和错误的区别，也简单地介绍了一些 PHP 中的错误处理函数。这次，我们再开两篇文章，详细的介绍一些 PHP 中错误处理相关的函数。想了解错误和异常相关内容的，请移步：</p><ul><li><p><a href=\"https://mp.weixin.qq.com/s/p5QV_TZDVuIP7QlhpckHkA\">一起搞懂PHP的错误和异常（一）</a></p></li><li><p><a href=\"https://mp.weixin.qq.com/s/nDeppr2JBFZoLdJS08rlaQ\">一起搞懂PHP的错误和异常（二）</a></p></li><li><p><a href=\"https://mp.weixin.qq.com/s/j-6uGQ8giTiljwz7zEXuHg\">一起搞懂PHP的错误和异常（三）</a></p></li></ul><h2>error_reporting()</h2><p>这个函数相必大家多少都会接触过，就是定义 PHP 在运行时的错误处理机制。就像我们在进行调试时，往往需要设置一个 E_ALL 来显示全部的错误信息。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">error_reporting(E_ALL);</code></pre></div><p>这个函数只能定义为 PHP 内部提供的那些错误处理的常量，包括：</p><ul><li><p>Fatal Error:致命错误（脚本终止运行）</p><ul><li><p>E_ERROR         // 致命的运行错误，错误无法恢复，暂停执行脚本</p></li><li><p>E_CORE_ERROR    // PHP启动时初始化过程中的致命错误</p></li><li><p>E_COMPILE_ERROR // 编译时致命性错，就像由Zend脚本引擎生成了一个E_ERROR</p></li><li><p>E_USER_ERROR    // 自定义错误消息。像用PHP函数trigger_error（错误类型设置为：E_USER_ERROR）</p></li></ul></li><li><p>Parse Error：编译时解析错误，语法错误（脚本终止运行）</p><ul><li><p>E_PARSE  //编译时的语法解析错误</p></li></ul></li><li><p>Warning Error：警告错误（仅给出提示信息，脚本不终止运行）</p><ul><li><p>E_WARNING         // 运行时警告 (非致命错误)。</p></li><li><p>E_CORE_WARNING    // PHP初始化启动过程中发生的警告 (非致命错误) 。</p></li><li><p>E_COMPILE_WARNING // 编译警告</p></li><li><p>E_USER_WARNING    // 用户产生的警告信息</p></li></ul></li><li><p>Notice Error：通知错误（仅给出通知信息，脚本不终止运行）</p><ul><li><p>E_NOTICE      // 运行时通知。表示脚本遇到可能会表现为错误的情况.</p></li><li><p>E_USER_NOTICE // 用户产生的通知信息。</p></li></ul></li></ul><p>当然，这个函数也是可以通过 php.ini 文件进行全局配置的，具体的配置方式这里不再赘述。包括 php.ini 文件的注释中也会有详细的说明。</p><h2>error_get_last()</h2><p>error_get_last() 函数则是指的返回我们最后一次的错误信息。它返回的是一个数组，里面会包含错误信息的\"type\"、\"message\"、\"file\"、\"line\"信息，方便我们查看错误的具体发生位置及内容。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">echo $a; // Notice: Undefined variable: a\nprint_r(error_get_last());\n// Array\n// (\n//     [type] =&gt; 8\n//     [message] =&gt; Undefined variable: a\n//     [file] =&gt; /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/一些简单的错误处理函数（一）.php\n//     [line] =&gt; 5\n// )\necho $b;\nprint_r(error_get_last()); // 不会打印$a的问题\n// Array\n// (\n//     [type] =&gt; 8\n//     [message] =&gt; Undefined variable: b\n//     [file] =&gt; /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202004/source/一些简单的错误处理函数（一）.php\n//     [line] =&gt; 17\n// )\n\necho $a;\necho $b;\nprint_r(error_get_last()); // 同样只会打印$b的问题</code></pre></div><p>需要注意的是，它只返回最后一个错误的信息。比如上面示例中最后一段中的 echo $a; 和 echo $b; 都会产生错误，但最终打印出来的只是 echo $b; 所产生的错误信息。</p><h2>error_clear_last</h2><p>从名字就可以看出，这个函数的作用是清除最后一次的错误信息。也就是说，如果在发生错误的代码之后调用了这个函数， error_get_last() 就不会打印任何内容了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">echo $a; // Notice: Undefined variable: a\nerror_clear_last();\nprint_r(error_get_last()); // 不会输出</code></pre></div><h2>error_log</h2><p>最后我们来看看错误日志记录的一个函数。它不仅可以将日志记录到日志文件中，还可以直接发邮件。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">error_log(\"Test Error One!\");\n// php.ini 中定义的 error_log 文件\n// [22-Apr-2020 09:04:34 Asia/Shanghai] Test Error One!\n\nerror_log(\"Test Error One!\", 1, \"423257356@qq.com\");\n\necho $a;\nerror_log(base64_encode(json_encode(error_get_last())), 1, \"423257356@qq.com\");</code></pre></div><p>第一段我们只有一个参数，所以错误信息将直接记录到 php.ini 文件中所定义的错误日志中。而后面两段则是将内容发送到一个邮箱中。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这个函数的声明形式是：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">error_log ( string $message [, int $message_type = 0 [, string $destination [, string $extra_headers ]]] ) : bool</code></pre></div><ul><li><p>$message，错误信息内容，文本形式</p></li><li><p>$message_type，错误发送到何处，默认0系统日志文件，1为发送到 $destination 定义的邮件地址，3发送到 $destination 定义的邮件地址并且 $message 不会被当作新的一行，4发送到SAPI的日志处理程序中</p></li><li><p>$destination，一般为邮件地址</p></li><li><p>$extra_headers，额外的邮件头，在 $message_type 为1时有用</p></li></ul><p>这个函数需要注意的一点是， $message 内容不能有 null 或者其他可能截断字符的符号。所以我们的测试代码中，发送 error_get_last() 内容时我们不仅给他转成了 json ，而且还加了一层 base64 编码，这样才能保证内容的正常发送。</p><h2>总结</h2><p>这篇文章主要就是介绍了这几个针对错误情况发生时的处理函数。比较有惊喜的是 error_log() 这个函数，它不需要过多的配置，直接就可能通过 PHP 自带的 mail 进行邮件发送。或许在我们的生产环境中可以尝试用来来进行一些错误的监听跟踪哦！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%80%EF%BC%89.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%80%EF%BC%89.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.error-reporting.php\">https://www.php.net/manual/zh/function.error-reporting.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.error-get-last.php\">https://www.php.net/manual/zh/function.error-get-last.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.error-clear-last.php\">https://www.php.net/manual/zh/function.error-clear-last.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.error-log.php\">https://www.php.net/manual/zh/function.error-log.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-07-04 09:17:54', 1);
INSERT INTO `zy_articles_xs_test` VALUES (89, '一些简单的错误处理函数（二）', '<h1>一些简单的错误处理函数（二）</h1><p>接下来，我们继续学习 PHP 中的错误处理函数。上次学习过的函数是错误信息的获取、设置、发送等功能，今天学习的内容主要是关于错误的捕获相关的函数。</p><h2>set_error_handler()</h2><p>首先是大家可能会接触过的一个函数，它可以用来捕获一些错误的信息。如果我们需要统一处理一些错误，比如规定日志格式或者将错误信息发送到邮件中，一般会在入口文件的开头在全局范围内定义一个这个函数进行统一的处理。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">echo $a; // Notice: Undefined variable: a ...\n//  E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING 不能处理\nset_error_handler(function($errno, $errstr, $errfile, $errline){\n    echo \"Has Error：\", $errno, \',\', $errstr, \',\', $errfile, \',\', $errline, PHP_EOL; \n}, E_ALL | E_STRICT);\n\necho $a; // Has Error：8,Undefined variable: a ...</code></pre></div><p>set_error_handler() 函数接收一个回调函数和一个错误接收的类型，它的函数签名是：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">set_error_handler ( callable $error_handler [, int $error_types = E_ALL | E_STRICT ] ) : mixed</code></pre></div><p>$error_handler是一个回调（匿名）函数，这个函数内部可以获取到错误的等级、信息、文件、行数等</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">handler ( int $errno , string $errstr [, string $errfile [, int $errline [, array $errcontext ]]] ) : bool</code></pre></div><p>其中，$errcontext 已经在 PHP7.2 之后取消了。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>$error_types，用于错误接收的类型，就像 error_reporting() 函数定义的错误类型一样，它用于控制 $error_handler 回调函数所能接收的错误的类型。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>需要注意的是，这个函数无法处理 E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING 这些类型的错误，也就是说，能够中断程序执行的错误它都无法捕获处理。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另外，在函数调用之前的错误是无法捕获到的，只有在函数调用之后的错误才能通过这个函数进行捕获处理。</p><h2>restore_error_handler()</h2><p>这个函数是用于还原之前的错误处理函数。比如我们在上面代码下添加这个函数，然后再次触发错误，错误将会使用回 PHP 的标准处理程序。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">restore_error_handler();\n\necho $a; // Notice: Undefined variable: a ...</code></pre></div><h2>set_exception_handler()</h2><p>学习了上面错误处理的函数后，从名称就可以看出，这个函数是用来处理异常的，它可以在全局范围内捕获异常。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">set_exception_handler(function($ex){\n    echo \"Has Exception: \" , $ex-&gt;getMessage(), PHP_EOL;\n});\n\nthrow new Exception(\'Init Error\');</code></pre></div><p>它的函数签名是：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">set_exception_handler ( callable $exception_handler ) : callable</code></pre></div><p>只接收一个回调函数，回调函数中只有一个参数，是一个 Exception 类型的参数内容，就和 try...catch 中的 catch 块的参数一样。在 PHP7 以后接收到的是一个 Throwable 类型的参数。也就是说，它可以捕获到所有的错误和异常。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>不过需要注意的是，在 PHP 中，所有的异常如果不进行处理，都会以中止脚本的错误形式返回报错信息。所以，在 set_exception_handler() 内处理完之后，脚本会中止运行。即使后面还有代码。所以，这个函数一般会用于全局捕获一些异常、错误后进行日志记录，它不具有 try...catch 的能力，让异常处理完成后还能继续进行其他操作。</p><h2>restore_exception_handler()</h2><p>同样的，异常捕获也是可以进行回退的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">set_exception_handler(function($ex){\n    echo \"Has Exception First: \" , $ex-&gt;getMessage(), PHP_EOL;\n});\nset_exception_handler(function($ex){\n    echo \"Has Exception Second: \" , $ex-&gt;getMessage(), PHP_EOL;\n});\n\nrestore_exception_handler();\n\nthrow new Exception(\'Init Error Next\'); // Has Exception First: Init Error Next\n<br class=\"ProseMirror-trailingBreak\"></code></pre></div><p>我们定义了两个 set_exception_handler() 函数，当使用 restore_exception_handler() 后，抛出的异常将会进入到第一个 set_exception_handler() 函数中进行处理。同理，restore_error_handler() 函数如果定义了多个错误处理，使用 restore_error_handler() 后也会一级一级回退，直到最终使用 PHP 的错误处理流程进行处理。</p><h2>trigger_error()</h2><p>最后，我们来看看如何手动抛出一个错误。就像上面例子中的 throw new Exception() 一样，PHP 也提供了一个用户自定义手动抛出错误的函数。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">trigger_error(\"I\'m Error One!\"); // Notice: I\'m Error One! </code></pre></div><p>它的函数签名是：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">trigger_error ( string $error_msg [, int $error_type = E_USER_NOTICE ] ) : bool</code></pre></div><p>$error_msg，也就是这个错误的具体信息，长度限制为 1024 个字节，如果超过了这个长度就会被截断。另外，如果这个信息中包含 HTML 实体标签的话，也不会直接转义，在网页显示时需要使用 htmlentities() 来进行处理。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>$error_type参数则是指定报错的级别，默认是 E_USER_NOTICE ，而且它只支持 E_USER... 相关的错误信息。也就是说，它的参数只能填三个 E_USER_NOTICE 、 E_USER_WARNING 、 E_USER_ERROR 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>当然，我们手动抛出的错误信息也是可以通过 set_error_handler() 进行捕获的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">set_error_handler(function($errno, $errstr, $errfile, $errline){\n    echo \"Has Error：\", $errno, \',\', $errstr, \',\', $errfile, \',\', $errline, PHP_EOL; \n}, E_ALL | E_STRICT);\ntrigger_error(\"I\'m Error One!\"); // Has Error：1024,I\'m Error One!,...\ntrigger_error(\"I\'m Error Two!\", E_USER_WARNING); // Has 512,I\'m Error One!,...\ntrigger_error(\"I\'m Error Three!\", E_USER_ERROR); // Has 256,I\'m Error One!,...\n\ntrigger_error(\"I\'m Error Four!\", E_WARNING); // Has Error：2,Invalid error type specified,...</code></pre></div><p>最后一个 trigger_error() 我们使用了 E_WARNING 类型，可以看出直接返回的内容是 指定的错误类型无效 ，而不是我们定义的内容。也就是说，这里是这个函数的参数类型错误的报错，不是我们手动想抛出的错误了。</p><h2>总结</h2><p>其实 PHP 的错误处理函数也就这些了，在 PHP7 下面，大部分错误都可以通过异常捕获了，也就是说，PHP 越向后发展越会通过面向对象的方式来处理这些错误信息。不过，我们依然还是要对他们有全面的了解，毕竟在 PHP 的版本更新中，短时间还不会完全的摒弃错误处理的场景，在之后我们学习详细的异常处理相关的知识时，说不定还会再次见到它们的身影。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%8C%EF%BC%89.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%8C%EF%BC%89.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.set-error-handler.php\">https://www.php.net/manual/zh/function.set-error-handler.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.set-exception-handler.php\">https://www.php.net/manual/zh/function.set-exception-handler.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.restore-error-handler.php\">https://www.php.net/manual/zh/function.restore-error-handler.php</a></p><p><a href=\"https://www.php.net/manual/zh/function.restore-exception-handler.php\">https://www.php.net/manual/zh/function.restore-exception-handler.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-08-01 22:53:16', 1);
INSERT INTO `zy_articles_xs_test` VALUES (90, '我们也有自带的缓存系统：PHP的APCu扩展', '<h1>我们也有自带的缓存系统：PHP的APCu扩展</h1><p>想必大家都使用过 memcached 或者 redis 这类的缓存系统来做日常的缓存，或者用来抗流量，或者用来保存一些常用的热点数据，其实在小项目中，PHP 也已经为我们准备好了一套简单的缓存系统，完全能够应付我们日常普通规模站点的开发。这一套扩展就是 APCu 扩展。</p><h2>APCu 扩展</h2><p>APCu 扩展是 APC 扩展的升级，APC 扩展已经不维护了。这两套扩展其实都是基于 opcode caching 。也就是 PHP 自身的 opcode 来实现的缓存能力。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>APCu 的安装就和普通的 PHP 扩展一样，非常简单，最主要的是这个扩展还非常的小。不管下载还是安装都是秒级可以完成的。所以说能够非常方便的应用于小规模的项目，而且是 PHP 原生支持的，不需要额外的端口之类的配置。</p><h2>方法说明</h2><p>缓存系统一般都会有的增加、删除、查询、自增等功能都在 APCu 扩展中有对应的实现。</p><ul><li><p>apcu_add — 创建一个新的缓存</p></li><li><p>apcu_cache_info — 查看 APCu 的全部缓存信息</p></li><li><p>apcu_cas — 更新一个缓存的值为新值</p></li><li><p>apcu_clear_cache — 清除全部的缓存</p></li><li><p>apcu_dec — 自减缓存值</p></li><li><p>apcu_delete — 删除一个缓存的内容</p></li><li><p>apcu_enabled — 当前环境下是否启用 APCu 缓存</p></li><li><p>apcu_entry — 原子地生成一个缓存实体</p></li><li><p>apcu_exists — 检查缓存是否存在</p></li><li><p>apcu_fetch — 查询缓存</p></li><li><p>apcu_inc — 自增缓存值</p></li><li><p>apcu_sma_info — 查询缓存的共享内存信息</p></li><li><p>apcu_store — 保存一个缓存</p></li></ul><h2>使用演示</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">apcu_add(\"int\", 1);\napcu_add(\"string\", \"I\'m String\");\napcu_add(\"arr\", [1,2,3]);\n\nclass A{\n    private $apc = 1;\n    function test(){\n        echo \"s\";\n    }\n}\n\napcu_add(\"obj\", new A);\n\nvar_dump(apcu_fetch(\"int\"));\nvar_dump(apcu_fetch(\"string\"));\nvar_dump(apcu_fetch(\"arr\"));\nvar_dump(apcu_fetch(\"obj\"));</code></pre></div><p>正常的使用都是比较简单的，我们添加各种类型的数据都可以正常存入缓存。不过需要注意的是，我们可以直接保存对象进入 APCu 缓存中，不需要将它序列化或者JSON成字符串，系统会自动帮我们序列化。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>apcu_add(string \\$key , mixed $var [, int $ttl = 0 ]) 方法就是普通的添加一个缓存，$ttl 可以设置过期时间，也是以秒为单位，如果不设置就是长期有效的。注意，APCu 的缓存时限在一次 CLI 中有效，再调用一次 CLI 取不到上次 CLI 中设置的缓存内容。而在 PHP-FPM 中，重启 PHP-FPM 或 FastCGI 之后缓存会失效。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来我们重点测试一下几个不太常见的方法。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">apcu_cas(\"int\", 1, 2);\nvar_dump(apcu_fetch(\"int\"));\n\n// Warning  apcu_cas() expects parameter 2 to be int\napcu_cas(\"string\", \"I\'m String\", \"I\'m  New String\");</code></pre></div><p>apcu_cas(string $key , int $old , int $new) 是将一个 $old 值修改为 $new 值，它只能修改数字类型的内容，如果是字符串的修改会报错。这个函数有什么优势呢？它最大的优势是原子性的，也就是不受高并发的影响。与之类似的是 apcu_store(string $key , mixed $var [, int $ttl = 0 ]) 方法，不过这个方法只是简单的修改一个缓存的内容，如果这个缓存的键不存在的话，就新建一个，它不受类型的限制，当然也不具有原子性。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">apcu_entry(\"entry\", function($key){\n    return \"This is \" . $key;\n});\nvar_dump(apcu_fetch(\"entry\"));</code></pre></div><p>apcu_entry(string $key , callable $generator [, int $ttl = 0 ]) 这个函数的作用是如果 $key 这个缓存不存在，则执行 $generator 这个匿名函数，并将 $key 做为键值传递进去，然后生成也就是 return 一个内容做为这个缓存的值。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">var_dump(apcu_cache_info());</code></pre></div><p>最后，如果我们想查看当前系统中的所有 APCu 缓存信息的时候，直接用这个 apcu_cache_info() 函数即可。</p><h2>总结</h2><p>当缓存中的数据非常多时，它还提供了一个 APCUIterator 迭代器方便我们进行缓存信息的循环查询及相关统计。总之，这一套系统是非常方便的一套小规模的缓存系统，在日常开发中完全可以尝试用到一些小功能上。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/%E6%88%91%E4%BB%AC%E4%B9%9F%E6%9C%89%E8%87%AA%E5%B8%A6%E7%9A%84%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%EF%BC%9APHP%E7%9A%84APCu%E6%89%A9%E5%B1%95.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/%E6%88%91%E4%BB%AC%E4%B9%9F%E6%9C%89%E8%87%AA%E5%B8%A6%E7%9A%84%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%EF%BC%9APHP%E7%9A%84APCu%E6%89%A9%E5%B1%95.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.apcu-entry.php\">https://www.php.net/manual/zh/function.apcu-entry.php</a></p>', 'PHP', 'PHP基础,缓存', '2022-07-23 18:06:29', '2021-03-13 22:57:09', 1);
INSERT INTO `zy_articles_xs_test` VALUES (91, '让PHP能够调用C的函数-FFI扩展', '<p>在大型公司中，一般会有很我编程语言的配合。比如说让 Java 来做微服务层，用 C++ 来进行底层运算，用 PHP 来做中间层，最后使用 JS 展现效果。这些语言间的配合大部分都是通过 RPC 来完成，或者直接将数据入库再使用不同的语言来取用。那么，我们 PHP 的代码能否直接调用这些语言呢？其实，PHP 还真为我们准备了一个可以直接调用 C 语言的扩展库，并且这个扩展库还是已经默认内置在 PHP 中了，它就是 FFI 扩展。</p><h2>什么是 FFI</h2><p>FFI ， Foreign Function Interface，外部函数接口。这个扩展允许我们加载一些公共库（.dll、.so），其实也就是可以调用一些 C 的数据结构及函数。它已经是随 PHP 源码发布的一个扩展了，在编译的时候可以加上 --with-ffi 来直接编译到 PHP 程序中。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>我们这里已经是编译好的 PHP ，所以我们直接找到这个扩展，进行简单的扩展安装步骤就可以安装完成。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">cd php-7.4.4/ext/ffi/\nphpize\n./configure\nmake &amp;&amp; make install</code></pre></div><p>安装完成后记得在 php.ini 文件中打开扩展。关于这个扩展需要注意的一点是，它有一个配置项为 ffi.enable ，默认情况下这个配置项的值是 \"preload\" ，仅在 CLI SAPI 环境下启用 FFI 的能力。当然，我们也可以修改为 \"true\" 或 \"false\" 来开启和关闭它。设定为 \"true\" 将使得这个扩展在任何环境下都启用。</p><h2>使用 FFI 调用 C 的函数</h2><p>接下来，简单地看一下它是如何调用 C 的函数的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 创建一个 FFI 对象，加载 libc 并且导入 printf 函数\n$ffi_printf = FFI::cdef(\n    \"int printf(const char *format, ...);\", // C 的定义规则\n    \"libc.so.6\"); // 指定 libc 库\n// 调用 C 的 printf 函数\n$ffi_printf-&gt;printf(\"Hello %s!\\n\", \"world\"); // Hello World\n\n// 加载 math 并且导入 pow 函数\n$ffi_pow = FFI::cdef(\n    \"double pow(double x, double y);\", \n    \"libboost_math_c99.so.1.66.0\");\n// 这里调用的是 C 的 pow 函数，不是 PHP 自己的\necho $ffi_pow-&gt;pow(2,3), PHP_EOL; // 8</code></pre></div><p>我们创建了两个对象，分别调用了 C 的 printf() 和 pow() 函数。FFI::cdef() 是用于创建一个 FFI 对象，它接收两个参数，一个是包含常规C语言（类型、结构、函数、变量等）声明序列的字符串。实际上，这个字符串可以从C头文件复制粘贴。而另一个参数则是要加载并定义链接的共享库文件的名称。也就是我们需要的 .dll 或 .so 文件，它与我们声明字符串是对应的，比如在 libc.so.6 中并没有 pow() 这类的计算函数，所以我们就要找到 math 相关的 C 语言计算函数库。</p><h2>定义变量和数组</h2><p>当然，FFI 也是可以定义变量和数组的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 创建一个 int 变量\n$x = FFI::new(\"int\");\nvar_dump($x-&gt;cdata); // int(0)\n\n// 为变量赋值\n$x-&gt;cdata = 5;\nvar_dump($x-&gt;cdata); // int(5)\n\n// 计算变量\n$x-&gt;cdata += 2;\nvar_dump($x-&gt;cdata); // int(7)\n\n\n// 结合上面的两个 FFI 对象操作\n\necho \"pow value:\", $ffi_pow-&gt;pow($x-&gt;cdata, 3), PHP_EOL;\n// pow value:343\n$ffi_printf-&gt;printf(\"Int Pow value is : %f\\n\", $ffi_pow-&gt;pow($x-&gt;cdata, 3));\n// Int Pow value is : 343.000000\n\n\n// 创建一个数组\n$a = FFI::new(\"long[1024]\");\n// 为数组赋值\nfor ($i = 0; $i &lt; count($a); $i++) {\n    $a[$i] = $i;\n}\nvar_dump($a[25]); // int(25)\n\n$sum = 0;\nforeach ($a as $n) {\n    $sum += $n;\n}\nvar_dump($sum); // int(523776)\n\nvar_dump(count($a)); // int(1024) 数组长度\nvar_dump(FFI::sizeof($a)); // int(8192)，内存大小</code></pre></div><p>使用 FFI::new() 函数来创建一个 C 的数据结构，也就是变量声明，这些变量的内容将保存在 cdata 属性中。而数组则直接就可以操作这个函数的返回值。当然，当我们要结束使用的时候，还是需要使用 FFI::free() 来释放变量的，就和 C 语言的开发一样。</p><h2>总结</h2><p>是不是感觉很高大上？但是请注意哦，FFI 调用的 C 函数并没有 PHP 本身去调用的效率高。比如这种 pow() 函数，使用 PHP 自身的效率更好。而且，FFI 扩展虽说已经是跟随 PHP 同步发布的扩展，但它还是处于实验性质的。也就是说，这个扩展是为未来可能用到的其它功能准备的，而且还有很多不确定性。所以在生产环境中如果需要合适类似的功能的话，那么还是要做更多的深入调研哦。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/%E8%AE%A9PHP%E8%83%BD%E5%A4%9F%E8%B0%83%E7%94%A8C%E7%9A%84%E5%87%BD%E6%95%B0-FFI%E6%89%A9%E5%B1%95.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202004/source/%E8%AE%A9PHP%E8%83%BD%E5%A4%9F%E8%B0%83%E7%94%A8C%E7%9A%84%E5%87%BD%E6%95%B0-FFI%E6%89%A9%E5%B1%95.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.php.net/manual/zh/intro.ffi.php\">https://www.php.net/manual/zh/intro.ffi.php</a></p><p><a href=\"https://www.php.net/manual/zh/ffi.examples-basic.php\">https://www.php.net/manual/zh/ffi.examples-basic.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-07-21 14:46:35', 1);
INSERT INTO `zy_articles_xs_test` VALUES (92, 'PHP中的垃圾回收相关函数', '<h1>PHP中的垃圾回收相关函数</h1><p>之前我们已经学习过 PHP 中的引用计数以及垃圾回收机制的概念。这些内容非常偏理论，也是非常常见的面试内容。而今天介绍的则是具体的关于垃圾回收的一些功能函数。关于之前的两篇介绍文章，大家可以到文章底部查看。</p><h2>再谈循环引用以及强制清理循环引用</h2><p>我们为什么要强调 “循环引用” 呢？其实，在默认情况下，我们直接 unset() 掉一个没有被其他变量引用的变量时，就会让这个变量的引用计数变为0。这时，PHP 默认的垃圾回收机制就会直接清除掉这个变量。比如：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$a = new stdClass;\n$b = new stdClass;\n$c = new stdClass;\necho memory_get_usage(), PHP_EOL; // 706528\n\nunset($a);\necho memory_get_usage(), PHP_EOL; // 706488\n\ngc_collect_cycles();\necho memory_get_usage(), PHP_EOL; // 706488</code></pre></div><p>从上面的代码中可以看出，我们 unset() 掉 $a 之后，内存直接就减少了。但是，如果是产生了循环引用的情况，那么简单的进行 unset() 就没有效果了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class D{\n    public $d;\n}\n$d = new D;\n$d-&gt;d = $d;\necho memory_get_usage(), PHP_EOL; // 706544\n\nunset($d);\necho memory_get_usage(), PHP_EOL; // 706544\n\ngc_collect_cycles();\necho memory_get_usage(), PHP_EOL; // 706488</code></pre></div><p>在这段代码中，我们对 \\$d 进行了一个简单的循环引用赋值。使用 unset() 后，内存没有发生变化，这时，只能使用 gc_collect_cycles() 函数来进行强制的循环引用清理，才能将 $d 里面的无效循环引用清除掉。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>没错，这一段的重点正是 gc_collect_cycles() 这个函数。它在正常情况下对普通的变量引用是不会产生什么清理效果的，当然，对于普通的变量我们直接 unset() 掉就可以了。它最主要的作用就是针对循环引用的清理。之前我们学习过，循环引用计数会存在一个 根缓冲区 ，一般默认情况下它能容纳 10000 个待清理的 可能根 。而 gc_collect_cycles() 的作用就是不用等这个 根缓冲区 满就直接进行清理（个人理解）。关于这个垃圾回收算法的内容请移步：<a href=\"https://mp.weixin.qq.com/s/69Zp_nCiqfxkT7R_L1LMVQ\">PHP垃圾回收机制的一些浅薄理解</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>其实，大部分情况下我们是不太需要关注 PHP 的垃圾回收问题的，也就是说，我们不是很需要手动地去调用这个 gc_collect_cycles() 函数。PHP-FPM 在每次调用完成后会直接整体的释放，简单的一次 CLI 脚本执行完也会全部释放。没错，正常情况下，PHP 一次执行完成之后就会销毁所有的内容，内存垃圾自然也就不存在了。但是，在执行长时间的守护脚本时，或者使用常驻进程的框架（Swoole）时，还是需要注意有没有循环引用的问题。因为这种程序一直运行，如果存在大量循环引用对象时，就有可能导致内存泄露。</p><h2>开启、关闭及查看循环引用垃圾回收状态</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">gc_disable();\necho gc_enabled(), PHP_EOL; //\ngc_enable();\necho gc_enabled(), PHP_EOL; // 1</code></pre></div><p>很简单的三个函数，gc_disable() 是 “停用循环引用收集器”，gc_enable() 是“开启循环引用收集器”，而 gc_enabled() 就是查看当前的循环引用收集器是否开启。</p><h2>强制回收Zend引擎内存管理器使用的内存</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">gc_mem_caches()</code></pre></div><p>官网及网络上并没有什么详细的介绍，不过从定义来看，它主要的作用就是回收 PHP 底层的 Zend 引擎内存管理器所使用过的内存。这个大家了解下就好，平常也从来没用过。</p><h2>获取垃圾收集器的信息</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$e = new stdClass;\nfor($i = 100;$i&gt;0;$i--){\n    $e-&gt;list[] = $e;\n}\n\nunset($e);\ngc_collect_cycles();\n\nvar_dump(gc_status());\n// array(4) {\n//     [\"runs\"]=&gt;int(1)\n//     [\"collected\"]=&gt;int(2)\n//     [\"threshold\"]=&gt;int(10001)\n//     [\"roots\"]=&gt;int(0)\n// }</code></pre></div><p>我们还是做了一个循环引用的对象，然后使用 gc_status() 来查看当前垃圾回收器中关于循环引用的状态。从返回的内容可以看出， runs 运行了 1 个，collected 收集了 2 个， threshold 阈值是 10001，roots 可能根没有了（已经被回收了）。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这个函数可以在测试环境中对代码的运行情况进行检查，查看我们代码中有没有不正常的循环引用情况，当然，上面的解释也只是个人的推测，因为关于这方面的资料确实非常少。所以也希望深入研究过这方面内容的大神能够留言指点迷津！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202005/source/PHP%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202005/source/PHP%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://mp.weixin.qq.com/s/WeZL4EzptDPQnkrFXxisgQ\">PHP的引用计数是什么意思？</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://mp.weixin.qq.com/s/69Zp_nCiqfxkT7R_L1LMVQ\">PHP垃圾回收机制的一些浅薄理解</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.gc-collect-cycles.php\">https://www.php.net/manual/zh/function.gc-collect-cycles.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.gc-disable.php\">https://www.php.net/manual/zh/function.gc-disable.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.gc-enable.php\">https://www.php.net/manual/zh/function.gc-enable.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.gc-enabled.php\">https://www.php.net/manual/zh/function.gc-enabled.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.gc-mem-caches.php\">https://www.php.net/manual/zh/function.gc-mem-caches.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.gc-status.php\">https://www.php.net/manual/zh/function.gc-status.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-06-12 02:50:48', 1);
INSERT INTO `zy_articles_xs_test` VALUES (93, 'PHP脚本设置及获取进程名', '<h1>PHP脚本设置及获取进程名</h1><p>今天来学习的是两个非常简单的函数，一个可以用来设置我们执行脚本时运行的进程名。而另一个就是简单的获取当前运行的进程名。这两个函数对于大量的脚本运行代码有很大的作用，比如我们需要 kill 掉某个进程时，可以直接使用我们自己定义的进程名来进行操作。</p><h2>设置进程名</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">cli_set_process_title(\"test\");</code></pre></div><p>非常简单吧，只有一个参数，那就是要定义的变量名称。在运行起来后，我们使用 sleep() 让程序挂载一段时间，然后再开一个终端来查看当前的进程信息。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">ps -ef | grep test\n# root     32172 31511  0 09:03 pts/0    00:00:00 test\n\ntop -p 32172 -c\n# 32198 root      20   0  113100  18052  13088 S   0.0   0.2   0:00.00 test</code></pre></div><p>可以看到，不管是使用 ps 还是使用 top ，都可以看到相应的进程名称为 test 的进程。这样，就完成了进程名称的自定义。</p><h2>获取进程名</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">echo \"Process title: \" . cli_get_process_title() . \"\\n\";\n// Process title: test</code></pre></div><p>同样的，获取当前进程名的函数也非常地简单，直接调用即可。它就会正常输出当前执行脚本的进程名称。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>如果我们没有自定义进程名称呢？这里就不会有任何的输出，大家可以自己尝试一下。</p><h2>注意事项</h2><p>最后来说说这两个函数的注意事项。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>一是如果使用的是 Mac OS 系统，会提示：</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// Warning: cli_set_process_title(): cli_set_process_title had an error: Not initialized correctly </code></pre></div><p>也就是说这两个函数在 Mac 下面是无法正常使用的，我的测试环境是 CentOS ，是可以正常使用的。Windows 环境没有进行测试，正常情况下也很少会有人在 Windows 环境下挂后台执行脚本，所以有兴趣的同学可以自己测试下。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>二是进程名可以是中文！！！是不是感觉很高大上。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>三是这两个函数仅针对 CLI 运行环境。也就是说，在 CGI 正常网页运行的状态下这两个函数是没有效果的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202005/source/PHP%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E5%8F%8A%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E5%90%8D.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202005/source/PHP%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E5%8F%8A%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E5%90%8D.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.cli-set-process-title.php\">https://www.php.net/manual/zh/function.cli-set-process-title.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.cli-get-process-title.php\">https://www.php.net/manual/zh/function.cli-get-process-title.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-05-10 03:26:58', 1);
INSERT INTO `zy_articles_xs_test` VALUES (94, '一些PHP选项参数相关的函数', '<h1>一些PHP选项参数相关的函数</h1><p>关于 PHP 的配置，我们大多数情况下都是去查看 php.ini 文件或者通过命令行来查询某些信息，其实，PHP 的一些内置函数也可以帮助我们去查看或操作这些配置参数。比如之前我们学习过的 <a href=\"https://mp.weixin.qq.com/s/htAk7a3GlmS956fxMVxZdQ\">关于php的ini文件相关操作函数浅析</a> 。修改方面的函数就只有 ini_set() ，其他大部分的函数其实都是帮助我们进行查询的，今天，我们就来一一讲解这些函数。</p><h2>get_defined_constants()</h2><p>返回所有常量的关联数组，键是常量名，值是常量值。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">define(\"MY_CONSTANT\", 1);\nprint_r(get_defined_constants(true));\n// array(\n//     ……\n//     [user] =&gt; array(\n//         [MY_CONSTANT] =&gt; 1\n//     )\n// )</code></pre></div><p>这个函数会输出所有的常量，因为返回的内容很多，所以用 ...... 表示有很多系统或扩展的定义常量，而我们在代码中自己定义的常量则会全部进入到 [user] 这个键名下。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这个函数有一个参数，当它为 true 时，让此函数返回一个多维数组，分类为第一维的键名，常量和它们的值位于第二维。而默认情况下是 false ，返回的是一个一维数组，就是常量名作为键名，它们的值作为键值。</p><h2>get_extension_funcs()</h2><p>这个函数返回的是扩展模块所包含的所有方法名称。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">print_r(get_extension_funcs(\"swoole\"));\n// Array\n// (\n//     [0] =&gt; swoole_version\n//     [1] =&gt; swoole_cpu_num\n//     [2] =&gt; swoole_last_error\n//     [3] =&gt; swoole_async_dns_lookup_coro\n//     [4] =&gt; swoole_async_set\n//     [5] =&gt; swoole_coroutine_create\n//     ……\n//     [35] =&gt; swoole_timer_clear\n//     [36] =&gt; swoole_timer_clear_all\n// )</code></pre></div><p>它的参数就是要查询的扩展名称，这里我们直接查看本机安装的 Swoole 里面都包含那些方法。可以看到，Swoole4.4 中一共包含有37个方法函数。</p><h2>get_loaded_extensions()</h2><p>这个函数是返回所有已加载的扩展模块列表。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">print_r(get_loaded_extensions());  // php -m\n// Array\n// (\n//     [0] =&gt; Core\n//     [1] =&gt; phpdbg_webhelper\n//     [2] =&gt; date\n//     [3] =&gt; libxml\n//     [4] =&gt; openssl\n//     [5] =&gt; pcre\n//     [6] =&gt; sqlite3\n//     ……\n//     [65] =&gt; imagick\n//     [66] =&gt; swoole\n//     [67] =&gt; vld\n//     [68] =&gt; Zend OPcache\n// )</code></pre></div><p>这个函数的作用是不是和我们在命令行使用 -m 来查看当前系统已安装的扩展一样。没错，它们就是相同的功能，都是返回的这样一个扩展安装情况的列表。在一些开源 cms 系统中，需要检查当前的安装环境是否符合要求时，就可以用这个函数进行检测。</p><h2>get_include_path() 和 get_included_files()</h2><p>这两个函数一个是返回当前 include_path 的配置信息，一个是返回已经被 include 或 require 进来的文件列表。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">echo get_include_path(), PHP_EOL; // .:/usr/local/Cellar/php/7.3.0/share/php/pear\necho ini_get(\'include_path\'), PHP_EOL; // .:/usr/local/Cellar/php/7.3.0/share/php/pear</code></pre></div><p>get_include_path() 很简单，它的效果其实就和 echo ini_get(\'include_path\') 是一样的，都是去读取 php.ini 文件中 include_path 的配置值。PHP 在 include 或 require 时，如果没有给定路径，那么它就会先在当前目录中查找，如果没有找到，则会进入这个 include_path 中进行查找。如果依然没有找到指定的文件，才会报错。这就是 include_path 目录的作用，当然，我们在日常开发中基本不会用到它，所以这里了解了解即可。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">include \"动态查看及加载PHP扩展.php\";\nprint_r(get_included_files());\n// Array\n// (\n//     [0] =&gt; /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202005/source/一些PHP选项参数相关的函数（一）.php\n//     [1] =&gt; /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202005/source/动态查看及加载PHP扩展.php\n// )</code></pre></div><p>get_included_files() 也是非常简洁直观的一个函数，它就是返回我们当前加载了哪些文件。当前运行时的文件总会在第一条，也就是说，这个函数至少会返回一个自身的文件路径。我们可以试试在 Laravel 或其他框架的入口文件或者控制器中使用这个函数打印一下它们的加载文件数量，这样其实也能帮我们理解这个框架的加载执行情况。</p><h2>get_resources()</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">var_dump(get_resources());\n// array(3) {\n//   [1]=&gt;\n//   resource(1) of type (stream)\n//   [2]=&gt;\n//   resource(2) of type (stream)\n//   [3]=&gt;\n//   resource(3) of type (stream)\n// }\n\n$fp = fopen(\'1.txt\',\'r\');\nvar_dump(get_resources());\n// array(4) {\n//   [1]=&gt;\n//   resource(1) of type (stream)\n//   [2]=&gt;\n//   resource(2) of type (stream)\n//   [3]=&gt;\n//   resource(3) of type (stream)\n//   [5]=&gt;\n//   resource(5) of type (stream-context)\n// }</code></pre></div><p>这个函数返回的是活动资源的情况。比如上面例子中，我们先打印了这个函数的内容，只有3条数据，然后我们用 fopen() 加载了一个文件资源，获得了一个资源句柄。这时候再打印这个函数的内容，就会发现多了一条，而且类型是 stream-context 类型的资源句柄。这个函数可以帮我们在调试的时候查看是否有没有释放的资源操作。</p><h2>总结</h2><p>今天先简单的学习了几个函数，其实他们并不是非常常用的函数，但是通过学习之后，竟然发现有不少函数还是能帮助我们对系统进行调优或者在迁移系统的时候能够快速检测运行环境的。学习致用才是最成功的学习，让我们继续加油吧！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202005/source/%E4%B8%80%E4%BA%9BPHP%E9%80%89%E9%A1%B9%E5%8F%82%E6%95%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202005/source/%E4%B8%80%E4%BA%9BPHP%E9%80%89%E9%A1%B9%E5%8F%82%E6%95%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2021-01-14 15:19:13', 1);
INSERT INTO `zy_articles_xs_test` VALUES (95, '一起学习PHP中断言函数的使用', '<h1>一起学习PHP中断言函数的使用</h1><p>原来一直以为断言相关的函数是 PHPUnit 这些单元测试组件提供的，在阅读手册后才发现，这个 assert() 断言函数是 PHP 本身就自带的一个函数。也就是说，我们在代码中进行简单的测试的时候是不需要完全引入整个单元测试组件的。</p><h2>assert() 断言函数</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">\nassert(1==1);\n\nassert(1==2);\n// assert.exception = 0 时，Warning: assert(): assert(1 == 2)\n// assert.exception = 1 时，Fatal error: Uncaught AssertionError: 验证不通过</code></pre></div><p>很明显，第二段代码无法通过断言验证。这时，PHP 就会返回一个警告或者异常错误。为什么有可能是两种错误形式呢？当我们设置 php.ini 中的 assert.exception 为 off 或者 0 时，也就是关闭这个参数的能力时，程序就会以 PHP5 的形式依然返回一个警告，就像上面代码中的注释一样。同时，通过 try...catch 也无法进行异常的捕获了。这个参数其实就是控制是否以正宗的异常对象进行抛出。如果保持这个参数为默认情况也就是设置为 on 或者 1 的话，就会直接抛出异常，程序中止。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从上述代码可以看出，断言的第一个参数是一个表达式，而且是需要一个返回 bool 类型对象的表达式。如果我们传递的是一个字符串或者一个数字呢？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 设置 assert.exception = 0 进行多条测试\n\nassert(\" \");\n// Deprecated: assert(): Calling assert() with a string argument is deprecated\n// Warning: assert(): Assertion \" \" failed\n\nassert(\"1\");\n// Deprecated: assert(): Calling assert() with a string argument is deprecated\n\nassert(0);\n// Warning: assert(): assert(0) failed\n\nassert(1);\n\nassert(\"1==2\");\n// Deprecated: assert(): Calling assert() with a string argument is deprecated\n// Warning: assert(): Assertion \"1==2\" failed </code></pre></div><p>很明显第一个参数的表达式会进行类型强制转换，但是字符串类型会多出一个过时提醒，表明给 assert() 函数传递字符串类型的表达式类型已经过时了。当前的测试版本是 7.3 ，在将来可能就会直接报中止运行的错误或异常了。主要问题在于，如果传递的字符串本身也是一个表达式的话，会以这个表达式的内容为基础进行判断，这样很容易产生歧义，就像最后一段代码一样。当然，已经过时的使用方式还是不推荐的，这里仅是做一个了解即可。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来我们看一下 assert() 函数的其他参数，它的第二个参数是两种类型，要么给一个字符串用来定义错误的信息，要么给一个 异常类 用于抛出异常。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">assert(1==1, \"验证不通过\");\n\nassert(1==2, \"验证不通过\");\n// Warning: assert(): 验证不通过 failed </code></pre></div><p>如果直接给的一个字符串，那么在警告的提示信息中，显示的就是我们定义的这个错误信息的内容。这个非常好理解。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">// 注意 assert.exception 设置不同的区别\n\nassert(1==1,  new Exception(\"验证不通过\"));\n\nassert(1==2,  new Exception(\"验证不通过\"));\n// assert.exception = 1 时，Fatal error: Uncaught Exception: 验证不通过\n// assert.exception = 0 时，Warning: assert(): Exception: 验证不通过</code></pre></div><p>当然，我们也可以给一个 异常类 让断言抛出一个异常。在默认情况下，这个异常的抛出将中止程序的运行。也就是一个正常的异常抛出流程，我们可以使用 try...catch 进行异常的捕获。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">try{\n    assert(1==2,  new Exception(\"验证不通过\"));\n}catch(Exception $e){\n    echo \"验证失败！:\", $e-&gt;getMessage(), PHP_EOL;\n}\n// 验证失败！:验证不通过</code></pre></div><p>另外还有一个参数会对断言的整体运行产生影响，那就是 php.ini 中的 zend.assertions 参数。它包含三个值：</p><ul><li><p>1，生成并执行代码，一般在测试环境使用</p></li><li><p>0，生成代码但是在运行时会路过</p></li><li><p>-1，不生成代码，一般在正式环境使用</p></li></ul><p>这个参数大家可以自行配置测试，默认的 php.ini 中它的默认值是 1 ，也就是正常的执行 assert() 函数。</p><h2>assert_options() 及相对应的 php.ini 中的参数配置</h2><p>PHP 中的断言功能还为我们提供了一个 assert_options() 函数，用于方便地设置和获取一些和断言能力有关的参数配置。它能够设置的断言标志包括：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>标志 | INI设置 | 默认值 | 描述</p><ul><li><p>| :-: | :-: | -:</p><p>ASSERT_ACTIVE | assert.active | 1 | 启用 assert() 断言</p><p>ASSERT_WARNING | assert.warning | 1 | 为每个失败的断言产生一个 PHP 警告（warning）</p><p>ASSERT_BAIL | assert.bail | 0 | 在断言失败时中止执行</p><p>ASSERT_QUIET_EVAL | assert.quiet_eval | 0 | 在断言表达式求值时禁用 error_reporting</p><p>ASSERT_CALLBACK | assert.callback | (NULL) | 断言失败时调用回调函数</p></li></ul><p>这些参数的含义都非常好理解，大家可以自己测试一下。我们就来看一下最后一个 ASSERT_CALLBACK 的作用。其实它的说明也非常清楚，就是断言失败的情况下就进入到这个选项定义的回调函数中。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">assert_options(ASSERT_ACTIVE, 1);\nassert_options(ASSERT_WARNING, 1);\nassert_options(ASSERT_BAIL, 1);\n\nassert_options(ASSERT_CALLBACK, function($params){\n    echo \"====faild====\", PHP_EOL;\n    var_dump($params);\n    echo \"====faild====\", PHP_EOL;\n});\n\nassert(1!=1);\n// ====faild====\n// string(105) \".../source/一起学习PHP中断言函数的使用.php\"\n// ====faild====</code></pre></div><p>当断言失败的时候，我们就进入了回调函数中，在回调函数直接简单的打印了传给回调函数的参数内容。可以看出，这个回调函数里面传递过来的是无法通过断言的文件信息。</p><h2>总结</h2><p>学习掌握一下断言函数的使用及配置，可以为我们将来学习 PHPUnit 单元测试打下基础，当然，本身这个能力的东西就不是很多，大家记住就好啦！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202005/source/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0PHP%E4%B8%AD%E6%96%AD%E8%A8%80%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202005/source/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0PHP%E4%B8%AD%E6%96%AD%E8%A8%80%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.assert-options.php\">https://www.php.net/manual/zh/function.assert-options.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.assert.php\">https://www.php.net/manual/zh/function.assert.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-05-10 04:57:23', 1);
INSERT INTO `zy_articles_xs_test` VALUES (96, '使用OPCache提升PHP的性能', '<h1>使用OPCache提升PHP的性能</h1><p>对于 PHP 这样的解释型语言来说，每次的运行都会将所有的代码进行一次加载解析，这样一方面的好处是代码随时都可以进行热更新修改，因为我们不需要编译。但是这也会带来一个问题，那就是无法承载过大的访问量。毕竟每次加载解析再释放，都会增加 CPU 的负担，通常一台 8核16G 的服务器在2、3000并发左右 CPU 就能达到60%以上的使用率。而且如果你使用的是类似于 Laravel 这种大型的框架，效率将更加低下。这个时候，我们通常会通过增加服务器数量来做负载均衡，从而达到减轻服务器压力的效果。不过，这样做的成本又会增加许多。那么，有没有什么优化的方案呢？</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>鸟哥在他的博客中针对 PHP7 的优化的一篇文章中，第一条建议就是开启 OPcache 。当然，另外一个方案就是使用 Swoole 。关于 Swoole 的内容我们将来再说，今天，我们先学习学习 OPcache 。</p><h2>什么是 OPcache</h2><p><em>OPcache 通过将 PHP 脚本预编译的字节码存储到共享内存中来提升 PHP 的性能， 存储预编译字节码的好处就是 省去了每次加载和解析 PHP 脚本的开销。</em></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>这是 PHP 文档中关于 OPcache 的简介，也就是说，OPcache 节约了每次加载和解析的步骤，将第一次解析编译后的脚本字节码缓存到系统的共享内存中。其实，这就类似于一个不完全的编译。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>类似于 Java 之类的语言，都是要打包编译之后才能上线运行的，比如打包成一个 jar包 。C++ 或 C# 可以打包成一个 .dll 或 .exe 。这些打包之后的文件就是编译完成的文件，将它们运行起来后一般会一直保持运行状态，也就是会成为一个常驻进程，它们的代码就进入内存中了。在程序运行的时候，不需要再进行解释或编译，自然速度就要快很多。而 OPcache 也是起到类似的作用。只不过它并不是完全的一套编译流程，我们还是依赖的 PHP-FPM 来运行脚本，只不过在开启 OPcache 后，PHP-FPM 会先从内存中查找是否已经有相关的已经缓存的字节码在内存中了，如果有的话就直接取用，如果没有的话，会再次进行解释编译后缓存下来。另外，OPcache 是针对文件的，也就是说，一个文件如果是新增加进来的，只有运行过它才会缓存，如果没有运行过，它并不在当前的共享内存中。</p><h2>安装 Opcache</h2><p>OPcache 已经是 PHP 的官方扩展并随安装包一起发布了，所以，我们可以在编译安装 PHP 时使用 --enable-opcache 来开启扩展，它已经是默认扩展。也可以在未安装 OPcache 的系统中使用安装包中的文件来进行安装。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">cd php-7.4.4/ext/opcache/\nphpize\n./configure\nmake &amp;&amp; make install</code></pre></div><p>需要注意的是， OPcache 和 Xdebug 在生产环境中尽量不要一起使用。本身 Xdebug 就是不推荐在生产环境中使用的，如果一定需要同时使用的话，需要先加载 OPcache ，然后再加载 Xdebug 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>扩展安装后，在 php.ini 文件中打开扩展。需要注意的是，OPcache 扩展是 Zend 扩展包，所以我们需要打开的是 Zend 扩展。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">zend_extension=opcache.so</code></pre></div><p>另外，还需要启用它。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">opcache.enable=1</code></pre></div><p>当开启了 OPcache 之后，我们再更新代码将会发现刚刚更新的代码不是我们最新的代码。这是因为代码已经被缓存了，就像 Java 一样，我们需要重启服务才行。那么 PHP 这边重启的是什么呢？当然就是重启下我们的 PHP-FPM 就可以了，直接使用 kill -USR2 命令去重启主进程就行了。这里也给出一个快速重启的命令。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">ps -ef | grep \"php-fpm: master\" | grep -v grep | cut -c 9-15 | xargs kill -USR2</code></pre></div><blockquote><p>感谢知乎大佬的指正，重启 PHP-FPM 不是最佳方案，应该使用 opcache_reset() 手动重启，或者通过 php.ini 文件的配置 opcache.validate_timestamps + opcache.revalidate_freq 自动间隔编译，或者通过 opcache_compile_file() 来直接重新编译修改过的文件</p></blockquote><h2>ab 测试效果</h2><p>我们进行测试的内容是测试环境的一台2核4G的服务器，使用的 PHP 版本是 PHP7.4 ，正常的 Nginx 及 PHP 配置， ulimit 也都开到了最大。代码只是简单的输出了一行文字，不过我们使用的是一个简单的 mvc 框架 ，也就是说这段代码运行起来至少也会加载几个文件，而不是简简单单的一个文件。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>首先我们来看未开启 OPcache 的情况。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/20220724/4437e58cd8a49b7aa065a851ebe087bc.png\" alt=\"//img1.zyblog.com.cn/20220724/4437e58cd8a49b7aa065a851ebe087bc.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来是开启了 OPcache 的情况。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><img src=\"//img1.zyblog.com.cn/20220724/27aeae269fd011268760814a1fe34cea.png\" alt=\"//img1.zyblog.com.cn/20220724/27aeae269fd011268760814a1fe34cea.png\" contenteditable=\"false\"><img class=\"ProseMirror-separator\" alt=\"\"><br class=\"ProseMirror-trailingBreak\"></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>很明显，性能有了很大的提高。不仅速度快了很多，吞吐率也是直接上升了几倍。当然，这只是非常简单的一个测试，不过总体看来，确实对单机的性能提升有很大的帮助。最最主要的是，同样的并发情况下，CPU 资源也比未开启的状态下低了70%。</p><h2>配置参考</h2><p>在 PHP 的官方文档中，已经为我们给出了一套默认的 OPcache 在 php.ini 中的配置。经过测试，基本没什么问题，当然，现在还没有在生产环境中使用过，还需要进行更多的测试。不过文档中指出，这套配置是可以直接运用到线上的，不过需要注意的是某些使用了注解之类功能的高级框架可能需要注意某些参数。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">opcache.memory_consumption=128\nopcache.interned_strings_buffer=8\nopcache.max_accelerated_files=4000\nopcache.revalidate_freq=60\nopcache.fast_shutdown=1\nopcache.enable_cli=1</code></pre></div><p>具体的配置说明以及其他的一些配置选项我们可以参考官方文档进行详细的了解。</p><h2>总结</h2><p>既然是我们的 PHP 大神鸟哥推荐的，而且也是官方推荐的扩展，我觉得在正式生产环境中使用不会有太大问题。另外，官方也给出了一套可以直接运用于线上生产环境的配置参数，也方便我们直接在线上进行测试。目前在生产环境中，我们只使用了一台服务器来进行测试，并且给它多分配了一些负载过来，从目前的情况来看，这一台机器的运行效率比其他几台的高很多。因为它一方面处理了更多的请求，另一方面它的 CPU 资源占用率还没有其他几台机器高。同时，OPcache 也不需要我们去了解更多的进程协程之类的知识，不像 Swoole 一样的会带来更高的学习成本。所以综上所述，在测试完备的情况下，OPcache 绝对是我们最优先考虑的单机优化方案。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><a href=\"https://www.laruence.com/2015/12/04/3086.html\">https://www.laruence.com/2015/12/04/3086.html</a></p><p><a href=\"https://www.php.net/manual/zh/book.opcache.php\">https://www.php.net/manual/zh/book.opcache.php</a></p>', 'PHP', 'PHP基础,性能', '2022-07-23 18:06:29', '2020-04-18 09:43:47', 1);
INSERT INTO `zy_articles_xs_test` VALUES (97, '关于php的ini文件相关操作函数浅析', '<h1>关于php的ini文件相关操作函数浅析</h1><p>在小公司，特别是创业型公司，整个服务器的搭建一般也是我们 PHP 开发工程师的职责之一。其中，最主要的一项就是要配置好服务器的 php.ini 文件。一些参数会对服务器的性能产生深远的影响，而且也有些参数是可以在 PHP 运行时动态指定和获取的。今天，我们就来学习一些和 php.ini 文件有关的操作函数。</p><h2>动态设置ini文件的配置参数</h2><p>这个函数相信大家不会陌生，基本上做过 PHP 开发的都会使用过。但是，有些参数是无法修改的，这个你知道吗？</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">ini_set(\'allow_url_fopen\', 0);\necho ini_get(\'allow_url_fopen\'), PHP_EOL; // 1 ，无法修改，PHP_INI_SYSTEM\n\nini_set(\'memory_limit\', -1);\necho ini_get(\'memory_limit\'), PHP_EOL; // -1，可以修改，PHP_INI_ALL</code></pre></div><p>请注意看注释，第一条注释中写了 ，PHP_INI_SYSTEM ，并且这个参数无法修改。没错，相信聪明的你已经看出来了，这些参数是有对应的类型的。PHP_INI_SYSTEM 的意思就是只能在 php.ini 或者 httpd.conf 中进行修改，无法在语言动态运行时修改。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>不同的 php.ini 配置参数对应有四种类型：</p><ul><li><p>PHP_INI_USER：可在用户脚本（例如 ini_set()）或 Windows 注册表（自 PHP 5.3 起）以及 .user.ini 中设定</p></li><li><p>PHP_INI_PERDIR：可在 php.ini，.htaccess 或 httpd.conf 中设定</p></li><li><p>PHP_INI_SYSTEM：可在 php.ini 或 httpd.conf 中设定</p></li><li><p>PHP_INI_ALL：可在任何地方设定</p></li></ul><p>也就是说，使用 ini_set() 我们可以设定类型为 PHP_INI_USER 和 PHP_INI_ALL 类型的参数，而其它两种只能在 php.ini 或其他配置文件中设置修改。具体的配置参数对应的类型请参考 PHP 相关文档。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/ini.list.php\">https://www.php.net/manual/zh/ini.list.php</a></p><h2>获取ini文件中的配置信息</h2><p>当然，读取 php.ini 文件中的配置信息就没有什么限制了。直接就可以读取，我们可以使用两个函数来进行读取，它们是：get_cfg_var() 和 ini_get() 。另外，还有一个可以获取数组集合形式的配置信息的函数 ini_get_all() 。我们一个一个来看。</p><h3>get_cfg_var() 和 ini_get()</h3><p>都是读取单个配置参数信息。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">echo get_cfg_var(\'error_reporting\'), PHP_EOL; // 32759\necho ini_get(\'error_reporting\'), PHP_EOL; // 32759\n\necho get_cfg_var(\'request_order\'), PHP_EOL; // GP\necho ini_get(\'request_order\'), PHP_EOL; // GP\n\n// php.ini A=TEST_A\necho get_cfg_var(\'A\'), PHP_EOL; // TEST_A\necho ini_get(\'A\'), PHP_EOL; // </code></pre></div><p>上面两条不用多解释，我们需要注意到的是，最后一条。我们在 php.ini 文件中定义了一个自定义的配置参数 A 。可以看到，get_cfg_var() 可以正常获取到这条信息，但 ini_get() 无法获取。我们再看另外一个例子。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">ini_set(\'error_reporting\', E_WARNING);\necho get_cfg_var(\'error_reporting\'), PHP_EOL; // 32759，只返回.ini的内容\necho ini_get(\'error_reporting\'), PHP_EOL; // 2，返回当前配置运行时的状态</code></pre></div><p>使用 ini_set() 动态设置了 error_reporting 参数后，get_cfg_var() 返回是 ini_set() 设置的值，而 ini_get() 获取的依然是 php.ini 文件里面配置的值。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从上面两个例子可以看出这两个函数的区别：</p><ul><li><p>get_cfg_var()，可以获取自定义的配置参数值，但只以 php.ini 文件为准，无法获得动态修改的参数值</p></li><li><p>ini_get()，无法获取自定义的配置参数值，以当前的动态脚本运行时的配置为准，也就是能够获取到 ini_set() 修改后的参数值</p></li></ul><h3>ini_get_all()</h3><p>它获取的是一组数据，比如我们安装的一些扩展 Swoole 、 xDebug 或者 mysqlnd 这类的配置信息。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">print_r(ini_get_all(\'swoole\'));\necho PHP_EOL;\n// Array\n// (\n//     [swoole.display_errors] =&gt; Array\n//         (\n//             [global_value] =&gt; On\n//             [local_value] =&gt; On\n//             [access] =&gt; 7\n//         )\n\n//     [swoole.enable_coroutine] =&gt; Array\n//         (\n//             [global_value] =&gt; On\n//             [local_value] =&gt; On\n//             [access] =&gt; 7\n//         )\n\n//     [swoole.enable_library] =&gt; Array\n//         (\n//             [global_value] =&gt; On\n//             [local_value] =&gt; On\n//             [access] =&gt; 7\n//         )\n\n//     [swoole.enable_preemptive_scheduler] =&gt; Array\n//         (\n//             [global_value] =&gt; Off\n//             [local_value] =&gt; Off\n//             [access] =&gt; 7\n//         )\n\n//     [swoole.unixsock_buffer_size] =&gt; Array\n//         (\n//             [global_value] =&gt; 262144\n//             [local_value] =&gt; 262144\n//             [access] =&gt; 7\n//         )\n\n//     [swoole.use_shortname] =&gt; Array\n//         (\n//             [global_value] =&gt; \n//             [local_value] =&gt; \n//             [access] =&gt; 4\n//         )\n\n// )</code></pre></div><p>可以看出，我们针对 Swoole 所作的所有配置信息都以数组形式返回了。</p><h2>还原配置信息</h2><p>当我们使用了 ini_set() 动态设置了参数信息后，想还原为 php.ini 文件中的默认配置的话，直接使用一个 ini_restore() 函数就可以了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">ini_restore(\'error_reporting\');\necho ini_get(\'error_reporting\'), PHP_EOL; // 32759</code></pre></div><p>依然是沿用上面的代码， error_reporting 已经被我们修改为了 2 ，这时，我们直接使用 ini_restore() 进行了还原，再使用 ini_get() 就可以看到 error_reporting 参数还原回了 php.ini 文件中定义的原始值。</p><h2>获取当前加载的配置文件路径</h2><p>当你接手一台服务器的时候，往往第一步就是找到它的相关应用配置文件，比如 mysql 的 my.ini 或者 nginx 的 conf 相关配置文件路径，而 PHP 中我们第一步就是要找到 php.ini 文件在哪里。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">echo php_ini_loaded_file(), PHP_EOL;\n// /usr/local/etc/php/7.3/php.ini\n\necho php_ini_scanned_files(), PHP_EOL;</code></pre></div><p>我们直接使用 php_ini_loaded_file() 就可以方便的获取到当前运行的脚本环境中加载的 php.ini 文件的路径。而 php_ini_scanned_files() 函数则是会以逗号分隔的形式返回所有可以扫描 php.ini 文件的路径。其实这两个参数在 phpinfo() 中都都有所体现，但很多时候我们并不能直接在生产环境中去使用 phpinfo() 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>其实，相对于这两个函数或 phpinfo() 来说，更好的方案是直接在命令行查找 php.ini 文件的位置。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">php --ini\n# Configuration File (php.ini) Path: /usr/local/etc/php/7.3\n# Loaded Configuration File:         /usr/local/etc/php/7.3/php.ini\n# Scan for additional .ini files in: /usr/local/etc/php/7.3/conf.d\n# Additional .ini files parsed:      /usr/local/etc/php/7.3/conf.d/ext-opcache.ini\n\nphp -i | grep \"Configuration\"\n# Configuration File (php.ini) Path =&gt; /usr/local/etc/php/7.3\n# Loaded Configuration File =&gt; /usr/local/etc/php/7.3/php.ini\n# Configuration</code></pre></div><h2>phpinfo()</h2><p>关于 phpinfo() ，我们不用解释太多，里面的内容都有什么应该是学习使用 PHP 的开发人员的必修课。在这里，我们只是介绍一下 phpinfo() 这个函数的参数。没错，它是有参数的，可以只显示一部分的信息而不是全部都显示出来。</p><ul><li><p>INFO_GENERAL：配置的命令行、 php.ini 的文件位置、建立的时间、Web 服务器、系统及更多其他信息。</p></li><li><p>INFO_CREDITS：PHP 贡献者名单。参加 phpcredits()。</p></li><li><p>INFO_CONFIGURATION：当前PHP指令的本地值和主值。参见 ini_get()。</p></li><li><p>INFO_MODULES：已加载的模块和模块相应的设置。参见 get_loaded_extensions()。</p></li><li><p>INFO_ENVIRONMENT：环境变量信息也可以用 $_ENV 获取。</p></li><li><p>INFO_VARIABLES：显示所有来自 EGPCS (Environment, GET, POST, Cookie, Server) 的 预定义变量。</p></li><li><p>INFO_LICENSE：PHP许可证信息。参见 » license FAQ。</p></li><li><p>INFO_ALL：显示以上所有信息。</p></li></ul><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">phpinfo(INFO_MODULES);</code></pre></div><p>上面的代码在页面中所显示的信息就只是已加载模式相关的配置信息了。phpinfo() 会直接输出到页面上，如果想将它的内容保存在一个变量中，我们需要使用输出缓冲控制来进行操作。我们将在后面的文章中讲到这方面的内容。这里就简单的给一段代码。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">ob_start();\nphpinfo();\n$v = ob_get_contents();\nob_end_clean();\n\necho $v;</code></pre></div><h2>总结</h2><p>不看不知道，一看吓一跳。原来只是使用过 ini_set() 去修改运行时内存大小，但直到今天才知道原来 ini_set() 并不是所有的配置都可以修改的，每个参数是否能动态修改还要看它的参数类型。而且上面还忘了说了，我们并不能使用 ini_set() 去增加配置参数。也就是说，使用 ini_set(\"B\", \"TEST_B\") 增加一个 B 参数，然后直接使用 ini_get() 也是无法获取的。而且简单的获取参数信息的两个函数也有这么多的不同，phpinfo() 原来也有这么多参数。果然，文档才是最好的学习资料。旅程还没有停止，我们刷文档的脚步依然不能停，一起加油冲冲冲！！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202005/source/%E5%85%B3%E4%BA%8Ephp%E7%9A%84ini%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202005/source/%E5%85%B3%E4%BA%8Ephp%E7%9A%84ini%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.get-cfg-var.php\">https://www.php.net/manual/zh/function.get-cfg-var.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.ini-set.php\">https://www.php.net/manual/zh/function.ini-set.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.ini-restore.php\">https://www.php.net/manual/zh/function.ini-restore.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.ini-get.php\">https://www.php.net/manual/zh/function.ini-get.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.ini-get-all.php\">https://www.php.net/manual/zh/function.ini-get-all.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.ini-alter.php\">https://www.php.net/manual/zh/function.ini-alter.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.php-ini-loaded-file.php\">https://www.php.net/manual/zh/function.php-ini-loaded-file.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.php-ini-scanned-files.php\">https://www.php.net/manual/zh/function.php-ini-scanned-files.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/ini.list.php\">https://www.php.net/manual/zh/ini.list.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/configuration.changes.modes.php\">https://www.php.net/manual/zh/configuration.changes.modes.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-03-06 12:53:50', 1);
INSERT INTO `zy_articles_xs_test` VALUES (98, '动态查看及加载PHP扩展', '<p>在编译并完成 php.ini 的配置之后，我们就成功的安装了一个 PHP 的扩展。不过， PHP 也为我们提供了两个在动态运行期间可以查看扩展状态以及加载未在 php.ini 中进行配置的扩展的函数。下面，我们就来看看它们的使用。</p><h2>查看是否已经加载了扩展</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">echo extension_loaded(\"redis\");</code></pre></div><p>非常简单的一个函数，它的作用就是检查一个扩展是否已经加载。它返回的是一个布尔值，当扩展已经加载则返回 true ，如果扩展没有加载，则返回 false 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在 PHP-FPM 的网页中，我们可以通过 phpinfo() 函数来查看当前 PHP 的状态及扩展相关信息。而在 CLI 命令行脚本中，我们可以使用 php -m 命令来查看已加载的扩展。</p><h2>动态加载扩展</h2><p>首先，我们在 php.ini 中关闭 redis 扩展的加载，并且同时需要打开 enable_dl=1 ，这样，我们就可以使用 dl() 函数来动态加载一个扩展了。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">dl(\"redis\");\necho extension_loaded(\"redis\");\n// 1</code></pre></div><p>没错， dl() 函数正是用来动态加载扩展的一个函数。不过它的使用是有许多限制的，这也并不是一个安全的函数。所以在 PHP7 中，它在 php.ini 的配置 enable_dl 已经是默认关闭的了。我们在生产环境也尽量不要使用这种方式进行扩展的加载。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>另外，这个函数在 PHP7 中仅对 CLI 环境有效。也就是说，在 PHP-FPM 的网页环境下，这个函数是没用的，即使已经打开了 php.ini 中的 enable_dl 。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>扩展加载的目录是以 PHP 默认的扩展目录为基础进行加载的，在 windows 环境下注意扩展名为 .dll 文件。当扩展加载失败时，不仅这个函数会返回 false ，同时还会产生一条 E_WARNING 的错误消息。最后，在 PHP 安全模式下，这个函数也同样是无法使用的。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>综上所述，在生产环境中，我们还是尽量不要使用动态加载扩展的能力。这个可以当成我们的一个学习资料，在自己本机电脑上不想一次加载太多扩展的情况下使用，当需要测试某些功能而需要某些特殊的扩展时，再考虑使用这个功能进行本地的测试。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202005/source/%E5%8A%A8%E6%80%81%E6%9F%A5%E7%9C%8B%E5%8F%8A%E5%8A%A0%E8%BD%BDPHP%E6%89%A9%E5%B1%95.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202005/source/%E5%8A%A8%E6%80%81%E6%9F%A5%E7%9C%8B%E5%8F%8A%E5%8A%A0%E8%BD%BDPHP%E6%89%A9%E5%B1%95.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.extension-loaded.php\">https://www.php.net/manual/zh/function.extension-loaded.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.dl.php\">https://www.php.net/manual/zh/function.dl.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-03-10 05:15:01', 1);
INSERT INTO `zy_articles_xs_test` VALUES (99, 'PHPDebug互动扩展【phpdbg】功能浅析', '<h1>PHPDebug互动扩展【phpdbg】功能浅析</h1><p>对于 PHP 开发者来说，单步的断点 Debug 调试并不是我们的必修课，而 Java 、 C# 、 C++ 这些静态语言则会经常性地进行这种调试。其实，我们 PHP 也是支持这类调试方式的，特别是对于了解一些开源框架，或者有非常深层次的 Bug 跟踪时，断点调试会非常有用。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>不少接触过 PHP 断点调试的一定都用过鼎鼎大名的 XDebug 。不过我们今天讲的并不是这款扩展，而是另一个已经集成到 PHP 官方源码中的调试工具，并且，最重要的是，它调试时看到的内容是更为底层的 opcode 执行过程。话不多说，我们直接进入到 phpdbg 这款工具的学习中吧！！</p><h2>phpdbg 命令行功能</h2><p>在我们安装好 PHP 后，默认就有了 phpdbg 这个工具。直接在命令行运行就会进入这个工具。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">% phpdbg\n[Welcome to phpdbg, the interactive PHP debugger, v0.5.0]\nTo get help using phpdbg type \"help\" and press enter\n[Please report bugs to &lt;http://bugs.php.net/report.php&gt;]</code></pre></div><p>没错，它就是随 PHP 安装的时候默认自带的，如果你的环境变量中没有这个工具命令的话，可以在 PHP 安装目录的 bin/ 目录下面找到。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>在进入 phpdbg 环境后，我们使用 help 就可以查看它的操作说明。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">prompt&gt; help\n\nphpdbg is a lightweight, powerful and easy to use debugging platform for PHP5.4+\nIt supports the following commands:\n\nInformation\n  list      list PHP source\n  info      displays information on the debug session\n  print     show opcodes\n  frame     select a stack frame and print a stack frame summary\n  generator show active generators or select a generator frame\n  back      shows the current backtrace\n  help      provide help on a topic\n……</code></pre></div><p>帮忙文档非常长，大家可以自己查看具体的内容，其中有一个 help 命令可以让我们看到许多简写的命令，我们主要使用这些简写的命令别名就可以。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">prompt&gt; help aliases\nBelow are the aliased, short versions of all supported commands\n e     exec                  set execution context\n s     step                  step through execution\n c     continue              continue execution\n r     run                   attempt execution\n u     until                 continue past the current l</code></pre></div><p>命令的简介和查看都很简单，那么我们要如何来调试 PHP 文件呢？这个才是我们最关心的事情。在调试一个文件的时候，我们需要将它载入到当前的执行环境中。可以在当前 phpdbg 环境中使用 e 命令指定文件进行载入，也可以在运行 phpdbg 的时候通过 -e 来指定需要载入的文件。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">% phpdbg -e PHPDebug互动扩展.php\n[Welcome to phpdbg, the interactive PHP debugger, v0.5.0]\nTo get help using phpdbg type \"help\" and press enter\n[Please report bugs to &lt;http://bugs.php.net/report.php&gt;]\n[Successful compilation of /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php]\nprompt&gt; </code></pre></div><p>这里我们使用的是第二种方式，在启动 phpdbg 时使用 -e 参数来指定需要载入的文件。</p><h2>普通断点设置</h2><p>载入了文件，进入了命令行，我们就可以进行断点调试了。首先，我们使用代码方式来设置断点。在上面的测试文件中，我们使用下面的方式来定义断点。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">echo 111;\nphpdbg_break_file(\"PHPDebug互动扩展.php\", 3);\n\necho 222;\nphpdbg_break_file(\"PHPDebug互动扩展.php\", 6);</code></pre></div><p>phpdbg_break_file() 函数就是来定义断点的，它有两个参数，第一个参数是文件名，这个不能乱填。第二个参数是断点的行号。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>接下来，在命令行中，我们运行两次简写的 run 命令 r 。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">prompt&gt; r\n111\n[Breakpoint #0 added at /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php:3]\n222\n[Breakpoint #1 added at /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php:6]\n[Script ended normally]\n\nprompt&gt; r\n[Breakpoint #0 at /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php:3, hits: 1]\n&gt;00003: echo 111;\n 00004: phpdbg_break_file(\"PHPDebug互动扩展.php\", 3);\n 00005: \nprompt&gt; </code></pre></div><p>可以看出，在第一次运行 r 的时候， phpdbg 将整个文件进行了一次扫描并输出了当前的两个断点信息。然后再运行一次 r 则定位到了第3行，也就是第一个断点的位置。接下来，我们就要进行单步调试了，我们直接使用 step 的简写命令 s 。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">prompt&gt; s\n[L3          0x10ecae220 ECHO                    111                                                            /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php]\n111\n[L4          0x10ecae240 EXT_STMT                                                                               /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php]\n&gt;00004: phpdbg_break_file(\"PHPDebug互动扩展.php\", 3);\n 00005: \n 00006: echo 222;\nprompt&gt; </code></pre></div><p>断点位置向下运行了，果然是符合我们的预期，开始了一行一行的单步运行。在上面输出的内容中，我们看到了 opcode 运行的状态。比如 L3 0x10ecae220 ECHO 这一行指的就是第 3 行执行了 ECHO 操作。是不是感觉非常高大上。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>一路 s 下来，走到最后我们就结束了这次断点调试，phpdbg 环境将退出 run 运行时。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">……\nprompt&gt; s\n[Script ended normally]\nprompt&gt; s\n[Not running]\nprompt&gt; </code></pre></div><p>这样，一趟调试就完成了。当我们在第一个断点不想单步调试，想直接进入下一个断点，就可以使用 continue 的简写命令 c 来直接跳到下一个断点。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">prompt&gt; r\nDo you really want to restart execution? (type y or n): y\n[Breakpoint #0 at /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php:3, hits: 1]\n&gt;00003: echo 111;\n 00004: phpdbg_break_file(\"PHPDebug互动扩展.php\", 3);\n 00005: \n\nprompt&gt; c\n111\n[Breakpoint at /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php:3 exists]\n[Breakpoint #1 at /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php:6, hits: 1]\n&gt;00006: echo 222;\n 00007: phpdbg_break_file(\"PHPDebug互动扩展.php\", 6);\n 00008: \nprompt&gt; </code></pre></div><p>另外还有一个命令就是可以直接看到当前载入的文件环境中的所有断点信息的。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">prompt&gt; info break\n------------------------------------------------\nFile Breakpoints:\n#0              /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php:3\n#1              /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php:6</code></pre></div><p>以上，就是一个简单的行断点设置以及调试步骤。当然，我们只是针对一个简单文件的测试，对于复杂的框架型系统，断点的设置和调试就会复杂很多，不过相应地，我们能够看到底层的 opcode 代码的执行情况，也能让我们对所测试的内容有更加深入的了解。</p><h2>方法断点及运行步骤分析</h2><p>接下来我们来设置一个方法断点，并一步步观察 opcode 的情况。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$i = 1;\n// phpdbg -e PHP\\ Debug互动扩展.php\nfunction testFunc(){\n    global $i;\n    $i += 3;\n    echo \"This is testFunc! i：\" . $i, PHP_EOL;\n}\n\ntestFunc();\nphpdbg_break_function(\'testFunc\');</code></pre></div><p>在 PHP 代码中，我们使用 phpdbg_break_function() 来给这个 testFunc() 方法设置一个断点。当代码中调用这个函数的时候，就会进入这个断点中。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">prompt&gt; r\n[Breakpoint #0 in testFunc() at /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php:11, hits: 1]\n&gt;00011: function testFunc(){\n 00012:     global $i;\n 00013:     $i += 3;\n\nprompt&gt; s\n[L12         0x109eef620 EXT_STMT                                                                               /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php]\n&gt;00012:     global $i;\n 00013:     $i += 3;\n 00014:     echo \"This is testFunc! i：\" . $i, PHP_EOL;\n\nprompt&gt; s\n[L12         0x109eef640 BIND_GLOBAL             $i                   \"i\"                                       /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php]\n[L13         0x109eef660 EXT_STMT                                                                               /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php]\n&gt;00013:     $i += 3;\n 00014:     echo \"This is testFunc! i：\" . $i, PHP_EOL;\n 00015: }</code></pre></div><p>直接进行了两次 s 单步，可以看到 global $i 对应的 opcode 操作是 BIND_GLOBAL 。继续向下操作。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">prompt&gt; s\n[L13         0x109eef680 ASSIGN_ADD              $i                   3                                         /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php]\n[L14         0x109eef6a0 EXT_STMT                                                                               /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php]\n&gt;00014:     echo \"This is testFunc! i：\" . $i, PHP_EOL;\n 00015: }\n 00016: \n\nprompt&gt; s\n[L14         0x109eef6c0 CONCAT                  \"This is testFunc!\"+ $i                   ~1                   /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php]\n[L14         0x109eef6e0 ECHO                    ~1                                                             /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php]\nThis is testFunc! i：4\n[L14         0x109eef700 EXT_STMT                                                                               /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php]\n[L14         0x109eef720 ECHO                    \"\\n\"                                                           /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php]\n\n[L15         0x109eef740 EXT_STMT                                                                               /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php]\n&gt;00015: }\n 00016: \n 00017: testFunc();</code></pre></div><p>第 13 行执行的是 $i += 3 的操作，对应的 opcode 操作是 ASSIGN_ADD ，增加的值是 3 。继续 s 后执行了第 14 行，注意这里进行了两步操作。一次是 CONCAT ，一次是 ECHO ，然后代码正常输出了打印出来的语句。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>从上面的几步调试可以清晰的看到 PHP 在 opcode 层面的一步步的执行状态，就像 XDebug 一样，每一次的执行都会有相关的变量、操作的信息输出。</p><h2>类函数断点设置</h2><p>类函数的断点设置其实就和上面的方法断点函数一样，非常的简单方便。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">class A{\n    function testFuncA(){\n        echo \"This is class A testFuncA!\", PHP_EOL;\n    }\n}\n$a = new A;\n$a-&gt;testFuncA();\nphpdbg_break_method(\'A\', \'testFuncA\');</code></pre></div><p>这里就不贴出调试的代码了，大家可以自己尝试一下。</p><h2>命令行增加断点</h2><p>除了在 PHP 代码中给出固定的断点之外，我们还可以在命令行中进行断点的增加，比如我们去掉之前的方法断点函数。然后在命令行中指定在方法中增加一个断点。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">prompt&gt; b testFunc#3\n[Breakpoint #1 added at testFunc#3]</code></pre></div><p>#3 这是什么意思呢？其实就是说我们在这个方法体内部的第 3 行增加一个断点。也就是说，我们在 $i += 3; 这一行增加了一个断点。行数是从方法定义那一行开始算的并且是从 1 开始，如果不加这个行数，就是直接从方法定义那一行开始。</p><div data-language=\"shell\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"shell\">prompt&gt; r\n[Breakpoint #0 resolved at testFunc#3 (opline 0x1050ef660)]\n[Breakpoint #0 resolved at testFunc#3 (opline 0x1050ef660)]\n[Breakpoint #0 resolved at testFunc#3 (opline 0x1050ef660)]\n[Breakpoint #0 resolved at testFunc#3 (opline 0x1050ef660)]\n[Breakpoint #0 in testFunc()#3 at /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source/PHPDebug互动扩展.php:13, hits: 1]\n&gt;00013:     $i += 3;\n 00014:     echo \"This is testFunc! i：\" . $i, PHP_EOL;\n 00015: }</code></pre></div><p>执行 r 后，我们就直接定位到了 testFun() 方法中的第三行。</p><h2>总结</h2><p>今天我们只是简单的学习了一下 phpdbg 这个工具的使用。从 help 命令中就可以看出，这个工具还有非常多的选项参数，可以帮我们完成许多调试工作。在这里只是跟大家一起入个门，将来在学习的过程中再次接触到的时候我们再继续深入的研究。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202006/source/PHPDebug%E4%BA%92%E5%8A%A8%E6%89%A9%E5%B1%95.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202006/source/PHPDebug%E4%BA%92%E5%8A%A8%E6%89%A9%E5%B1%95.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/intro.phpdbg.php\">https://www.php.net/manual/zh/intro.phpdbg.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2020-02-20 09:24:15', 1);
INSERT INTO `zy_articles_xs_test` VALUES (100, 'PHP中环境变量的操作', '<h1>PHP中环境变量的操作</h1><p>在 PHP 中，我们可以通过 phpinfo() 查看到当前系统中的环境变量信息（Environment）。在代码中，我们也可以通过两个函数，查看和修改相应的环境变量信息。</p><h2>getenv() 获取环境变量信息</h2><p>在不传参数的情况下，我们可以通过 getenv() 这个函数获得所有的环境变量信息。不过需要注意的是，在 CLI 环境和 SAPI 环境下它所返回的信息是不一样的。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">print_r(getenv());\n\n// CLI\n// Array\n// (\n//     [USER] =&gt; zhangyue\n//     [PATH] =&gt; /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/VMware Fusion.app/Contents/Public:/Applications/Wireshark.app/Contents/MacOS\n//     [LOGNAME] =&gt; zhangyue\n//     [SSH_AUTH_SOCK] =&gt; /private/tmp/com.apple.launchd.h3szqpYfSH/Listeners\n//     [HOME] =&gt; /Users/zhangyue\n//     [SHELL] =&gt; /bin/zsh\n//     [__CF_USER_TEXT_ENCODING] =&gt; 0x1F5:0x19:0x34\n//     [TMPDIR] =&gt; /var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/\n//     [XPC_SERVICE_NAME] =&gt; 0\n//     [XPC_FLAGS] =&gt; 0x0\n//     [OLDPWD] =&gt; /Users/zhangyue/MyDoc/博客文章\n//     [PWD] =&gt; /Users/zhangyue/MyDoc/博客文章/dev-blog/php/202006/source\n//     [SHLVL] =&gt; 1\n//     [TERM_PROGRAM] =&gt; vscode\n//     [TERM_PROGRAM_VERSION] =&gt; 1.45.1\n//     [LANG] =&gt; en_US.UTF-8\n//     [COLORTERM] =&gt; truecolor\n//     [VSCODE_GIT_IPC_HANDLE] =&gt; /var/folders/wj/t2z1cfhs0m9gq48krm8nc0vm0000gn/T/vscode-git-a282fa5813.sock\n//     [GIT_ASKPASS] =&gt; /Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass.sh\n//     [VSCODE_GIT_ASKPASS_NODE] =&gt; /Applications/Visual Studio Code.app/Contents/Frameworks/Code Helper (Renderer).app/Contents/MacOS/Code Helper (Renderer)\n//     [VSCODE_GIT_ASKPASS_MAIN] =&gt; /Applications/Visual Studio Code.app/Contents/Resources/app/extensions/git/dist/askpass-main.js\n//     [TERM] =&gt; xterm-256color\n//     [_] =&gt; /usr/local/bin/php\n//     [__KMP_REGISTERED_LIB_9282] =&gt; 0x1138dc0f8-cafece1d-libomp.dylib\n// )\n\n// SAPI Nginx\n// Array\n// (\n//     [USER] =&gt; zhangyue\n//     [HOME] =&gt; /Users/zhangyue\n// )</code></pre></div><p>如果 PHP 在诸如 Fast CGI 之类的 SAPI 中运行，则此函数将始终返回由 SAPI 设置的环境变量的值，即使已使用 putenv() 来设置同名的本地环境变量。这个函数是有两个参数的，不过它们都是选填的（PHP7以前必须填变量名）。第一个参数是变量名，也就是可以返回具体的某一个环境变量信息。而第二个参数如果设置为 true 的话，仅返回本地环境变量（由操作系统或 putenv() 设置）。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">echo getenv(\"HOME\"), PHP_EOL;\n// /Users/zhangyue\n\n// Nginx\nprint_r($_SERVER);\necho getenv(\"REQUEST_METHOD\"), PHP_EOL; // GET\necho getenv(\"REQUEST_METHOD\", true), PHP_EOL; // </code></pre></div><p>在第二个参数不为 true 的情况下，我们可以通过 getenv() 获得 \\$_SERVER 、$_ENV 中的所有内容，但是，如果第二个参数为 true 的话，那么类似于 Nginx 为我们添加的那些环境变量就无法获取了。这就是第二个参数的作用，上面代码中 REQUEST_METHOD 就是 Nginx 为我们添加的环境变量，所以第二条输出语句就不会进行输出。</p><h2>putenv() 设置环境变量信息</h2><p>设置环境变量的函数就比较简单了，只有一个参数，不过写法是类似于 Linux 中环境变量的设置写法。</p><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">putenv(\"A=TestA\");\necho getenv(\"A\"), PHP_EOL;\necho getenv(\"A\", true), PHP_EOL;</code></pre></div><p>对于 putenv() 的环境变量，getenv() 的第二个参数设置为 true 也是可以获取到的。环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>设置特定的环境变量也有可能是一个潜在的安全漏洞。 safe_mode_allowed_env_vars 包含了一个以逗号分隔的前缀列表。 在安全模式下，用户可以仅能修改用该指令设定的前缀名称的指令。 默认情况下，用户仅能够修改以 PHP_ 开头的环境变量（例如 PHP_FOO=BAR）。 注意：如果此指令是空的，PHP允许用户设定任意环境变量！</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>safe_mode_protected_env_vars 指令包含了逗号分隔的环境变量列表，使用户最终无法通过 putenv() 修改。 即使 safe_mode_allowed_env_vars 设置允许修改，这些变量也会被保护。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>所以，在 php.ini 中，默认情况下 putenv() 是定义为危险函数的，也就是在 disable_functions 中需要删除掉这个函数才能正常使用，如果要使用 Composer 的话也必须要开启这个函数才能正常使用。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202006/source/PHP%E4%B8%AD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E6%93%8D%E4%BD%9C.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202006/source/PHP%E4%B8%AD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E6%93%8D%E4%BD%9C.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.putenv.php\">https://www.php.net/manual/zh/function.putenv.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/function.getenv.php\">https://www.php.net/manual/zh/function.getenv.php</a></p>', 'PHP', 'PHP基础', '2022-07-23 18:06:29', '2022-10-25 14:28:10', 1);
INSERT INTO `zy_articles_xs_test` VALUES (101, 'PHP的LZF压缩扩展工具', '<h1>PHP的LZF压缩扩展工具</h1><p>这次为大家带来的是另外一个 PHP 的压缩扩展，当然也是非常冷门的一种压缩格式，所以使用的人会比较少，而且在 PHP 中提供的相关的函数也只是对字符串的编码与解码，并没有针对文件的操作。因此，就像 Bzip2 一样，我们也可以用它来进行一些加密传输的操作。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>LZF 扩展直接在 phar.php.net 下载安装即可，也是走得正常的 PHP 的扩展安装的步骤。LZF 压缩算法基于 Lempel-Ziv ，并使用了有限状态熵编码。LZF采用类似 lz77 和 lzss 的混合编码。使用3种 “起始标记” 来代表每段输出的数据串。关于 LZF 压缩的信息非常少，仅有的查询结果显示是它是 Apple 开源的一种非常简单的字符压缩算法。</p><h2>基本函数使用</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$str = \"The 2014 World Cup will be hold in .It is a grand occasion for all the football fans all over the world.My favorite team is the Spainish Team.And my favorite football star is Didier Yves Drogba Tébily.I hope the Chinese Tee\nam can do well in the World Cup.Because China has never won a World Cup before.This year I hope the situation will change.\n\n\nWhen the match begins, I hope I can watch it.But if I am busy studying thenn\n I will not watch it.Because study is always the first priority.I wish one day China can hold a World Cup, then our Chinese can watch the matches withouu\nt going abroad.\n\n\nMaybe one day my dream can come true.\";\n\n$c = lzf_compress($str);\necho $c, PHP_EOL;\n// The 2014 World Cup will be ho in .It is a grand occasion for a *t Bfootb@\n//                                                                          fan * over`w@X.My\n// vorite team@Q@8	Spainish T .A _m�)�Vstar@2Didi WYves Drogba Tébily.I �p \\ �Chchange.	 can do we � �@��.Becau )@1a has ne@�w �a�\'! �e.Thye ��msituatAa9\n\n\n// When`omatch Cgins，�;I`�w`it.Bu!ff !busy �udying@Bn `]not�2��s@)Aalways@0	 first priAsAwAeone day��Aa��� �!\"n our`%AG@\'�� ��!witho �go@�abroad@�May\"=�i!�dr!�`Dcom!�rue.\n\n$v = lzf_decompress($c);\necho $v, PHP_EOL;\n// The 2014 World Cup will be hold in .It is a grand occasion for all the football fans all over the world.My favorite team is the Spainish Team.And my favorite football star is Didier Yves Drogba Tébily.I hope the Chinese Team can do well in the World Cup.Because China has never won a World Cup before.This year I hope the situation will change.\n\n\n// When the match begins，I hope I can watch it.But if I am busy studying then I will not watch it.Because study is always the first priority.I wish one day China can hold a World Cup，then our Chinese can watch the matches without going abroad.\n\necho lzf_optimized_for(), PHP_EOL;\n// 1\n// 如果LZF针对速度进行了优化，则返回1；对于压缩，则返回0。</code></pre></div><p>LZF 全部就只提供了这三个非常简单的函数。lzf_compress() 用于对字符串进行压缩编码，可以看出我们输出的压缩之后的内容已经变成了乱码的形式。但是相对于 Bzip2 完全看不懂的编码内容来说，LZF 是可以看到原文的一部分内容的。lzf_decompress() 用于解码已经编码的字符串内容。lzf_optimized_for() 输出的是 LZF 扩展的编译后运行状态，如果返回的是 1 ，则表明针对当前系统的速度进行了优化，如果返回的是 0 ，表示的是仅仅是进行了压缩编码。</p><h2>中文支持</h2><div data-language=\"php\" class=\"toastui-editor-ww-code-block\"><pre><code data-language=\"php\">$str = \"如今我们站长做网站会越来越多的选择服务器，而不是虚拟主机。但是在选择服务器之后，我们大部分网友会直接使用宝塔面板、LNMP等一键安装WEB系统去配置网站环境。有些软件确实是在不断的升级和维护且安全功能做的不错，但是有些可能还没有考虑到安全问题。\n\n因为大部分软件提供商都更多的考虑到功能，对于细节的安全做的还是不够的，比如前一段时间由于THINKPHP框架的漏洞导致安装THINKPHP的程序被黑，同时也影响到同一台服务器中的其他网站也有被黑掉，所以对于安全问题还是需要单独的处理\";\n\n$c = lzf_compress($str);\necho $c, PHP_EOL;\n// 如今我们站长做网\n//                 会越来 多的选择服务器，而不��虚拟主机。但 在�2之后 8�大部分 q有些软件� 5���@��� �升级和维护且 全功能A系统去配置 H �环境 �\n//                                         �� ,错 ��ՀS可  还没考虑到�&gt;问题 �\n\n// 因为�逋提供商都更�^�C`| p\n//                          对于细节 ��[��@y�� �够  比如前!!\n// THINKPHP框架 .                                           段时间由 A\n//               漏洞导致 U!J�\"\n//                              程序被黑 W同 也影响@��!��台�\n// �aL��他�=��A`D掉 G所以�� s!d�%��\n//                                 需要单独 �处理�\n\n$v = lzf_decompress($c);\necho $v, PHP_EOL;\n// 如今我们站长做网站会越来越多的选择服务器，而不是虚拟主机。但是在选择服务器之后，我们大部分网友会直接使用宝塔面板、LNMP等一键安装WEB系统去配置网站环境。有些软件确实是在不断的升级和维护且安全功能做的不错，但是有些可能还没有考虑到安全问题。\n\n// 因为大部分软件提供商都更多的考虑到功能，对于细节的安全做的还是不够的，比如前一段时间由于THINKPHP框架的漏洞导致安装THINKPHP的程序被黑，同时也影响到同一台服务器中的其他网站也有被黑掉，所以对于安全问题还是需要单独的处理</code></pre></div><p>当然，LZF 对中文也是良好支持的。同样的在编码后的内容中也是有部分内容是可见的。</p><h2>总结</h2><p>全部下来就只有这三个函数的一个压缩算法的扩展，是不是非常的简单方便。就像上面所说的，一是对于字符串的存储节约空间，二是可以做为某些传输的加密实现。当然，这个算法并不是完全的编码，所以我们还是能够看到原文的内容的。其实从这方面我们可以和 Bzip2 对比下，Bzip2 是二进制编码的，所以编码后的内容是完全乱码的。而 LZF 是非二进制的，采用一种熵算法的压缩算法，自然会有很多内容是肉眼可见的。最终，还是要取决于我们的业务形态来决定采用哪种具体的压缩扩展工具。</p><p><br class=\"ProseMirror-trailingBreak\"></p><p>测试代码：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://github.com/zhangyue0503/dev-blog/blob/master/php/202006/source/PHP%E7%9A%84LZF%E5%8E%8B%E7%BC%A9%E6%89%A9%E5%B1%95%E5%B7%A5%E5%85%B7.php\">https://github.com/zhangyue0503/dev-blog/blob/master/php/202006/source/PHP%E7%9A%84LZF%E5%8E%8B%E7%BC%A9%E6%89%A9%E5%B1%95%E5%B7%A5%E5%85%B7.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p>参考文档：</p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.php.net/manual/zh/book.lzf.php\">https://www.php.net/manual/zh/book.lzf.php</a></p><p><br class=\"ProseMirror-trailingBreak\"></p><p><a href=\"https://www.cnblogs.com/pengze0902/p/5998843.html\">https://www.cnblogs.com/pengze0902/p/5998843.html</a></p>', 'PHP', 'PHP基础,压缩', '2022-07-23 18:06:29', '2021-10-18 16:07:20', 1);

SET FOREIGN_KEY_CHECKS = 1;
